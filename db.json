{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"source/images/Cpp-Basics-3-1.png","path":"images/Cpp-Basics-3-1.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1701323793515},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701324224526},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1701324224526},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1701324224526},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1701324224526},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1701324224526},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1701324224526},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1701324224526},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1701324224526},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1701324224526},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1701324224526},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1701324224526},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1701324224526},{"_id":"themes/archer/_config.yml","hash":"abd843f96e168df5f4ecdaa111fea12b6e185e7a","modified":1702031356768},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1701324224526},{"_id":"themes/archer/package.json","hash":"81af75826e854ac80f6337dc4f1ce4b51f066b0b","modified":1701324224530},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1701324224562},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1701324224562},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1701324224562},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1701324224526},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1701324224526},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1701324224526},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1701324224526},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1701324224526},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1701324224526},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1701324224526},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1701324224526},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1701324224526},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1701324224526},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1701324224526},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1701324224526},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1701324224526},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1701324224526},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1701324224526},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1701324224526},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"d8f4236166d058421c2e4ff00660be75a3494704","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"687c08823e7ce43e6ebb44f2fb4b75549abfed29","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1701324224526},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1701324224526},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1701324224526},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1701324224530},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1701324224530},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1701324224530},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1701324224530},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1701324224530},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1701331873778},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1701324224530},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1701324224530},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1701324224530},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1701324224534},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1701324224534},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1701324224534},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1701324224534},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1701324224538},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1701324224538},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1701324224538},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1701324224538},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1701324224538},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1701324224546},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1701324224554},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1701324224562},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1701324224562},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1701324224562},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1701324224562},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1701324224562},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1701324224562},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1701324224562},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1701324224562},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1701324224562},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1701324224562},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1701324224562},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1701324224562},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1701324224562},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1701324224562},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1701324224562},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1701324224562},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1701324224562},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1701324224562},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1701324224562},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1701324224562},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1701324224562},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1701324224562},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1701324224562},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1701324224562},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1701324224526},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1701324224526},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1701324224526},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1701324224526},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1701324224562},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1701324224562},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1701324224562},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1701324224562},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1701324224534},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1701324224534},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1701324224534},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1701324224534},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1701324224534},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1701324224538},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1701324224534},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1701324224538},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1701324224554},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1701324224562},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1701324224526},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1701324224538},{"_id":"themes/archer/package-lock.json","hash":"400ab1cc2a2f1380a5e9ab69abe3a5b93f923d8d","modified":1701324224530},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1701324224558},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1701324224546},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1701324224554},{"_id":"public/2023/11/30/hello-world/index.html","hash":"4667deaed6d0ddfb9717647c7577ee9f6e346105","modified":1701423407982},{"_id":"public/archives/index.html","hash":"9f2398a93c73ed4b3c0a141590248e7f486f7a4c","modified":1702307607790},{"_id":"public/archives/2023/index.html","hash":"1c9441b1005bebd7be32108cc2e5eb031d363193","modified":1702307607790},{"_id":"public/archives/2023/11/index.html","hash":"81ec6255bbd22d58e07ece92952735d2578a12a5","modified":1701423407982},{"_id":"public/index.html","hash":"aad14da2386c9cf3a00bbeeb0fb5581a531d8a9b","modified":1702307607790},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1701328044199},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1701328044199},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1701328044199},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1701328044199},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1701328044199},{"_id":"public/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1701331894451},{"_id":"public/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1701328044199},{"_id":"public/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1701328044199},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1701328044199},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1701328044199},{"_id":"public/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1701328044199},{"_id":"public/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1701328044199},{"_id":"public/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1701328044199},{"_id":"public/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1701328044199},{"_id":"public/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1701328044199},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1701328044199},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1701328044199},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1701328044199},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1701328044199},{"_id":"public/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1701328044199},{"_id":"public/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1701328044199},{"_id":"public/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1701328044199},{"_id":"public/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1701328044199},{"_id":"public/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1701328044199},{"_id":"public/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1701328044199},{"_id":"public/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1701328044199},{"_id":"public/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1701328044199},{"_id":"public/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1701328044199},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1701328044199},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1701328044199},{"_id":"public/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1701328044199},{"_id":"public/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1701328044199},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1701328044199},{"_id":"public/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1701328044199},{"_id":"public/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1701328044199},{"_id":"public/content.json","hash":"5a2da484805e23b8a73a39d4e07c35d3406c01be","modified":1702307607790},{"_id":"source/_posts/C++的无锁编程.md","hash":"1170f243e2d60acb4176a5be764fb0a116b9299e","modified":1701332409838},{"_id":"source/_posts/test-article.md","hash":"d5c9d9b3ea1e4f09230feb341d389d88194d3757","modified":1701354748868},{"_id":"public/2023/11/30/C++的无锁编程/index.html","hash":"5294c5f320a51278b443eb4a273544b112076186","modified":1701332483038},{"_id":"public/2023/11/30/test-article/index.html","hash":"1b625c23fc222fffdcafcaa57d28869e2e35d4c9","modified":1701423407982},{"_id":"source/about/index.md","hash":"80ca524618bebf8ec5a572a1184ed8b2874d4b8d","modified":1701460805533},{"_id":"public/about/index.html","hash":"ce3df3c2076d12fff55af34e2fa91f9013f46128","modified":1702307607790},{"_id":"source/_posts/some-plans.md","hash":"c16282b0a564daefaa6c09f1dc2144370287d664","modified":1701459323498},{"_id":"public/2023/12/02/some-plans/index.html","hash":"ee7d134f58b9df3882d8d194dbbdd6b44b4e6b78","modified":1702307607790},{"_id":"public/archives/2023/12/index.html","hash":"e0b7e0b8303f081365a939764769f5898b74af71","modified":1702307607790},{"_id":"public/tags/Plan/index.html","hash":"05bed34c2a3ae9fc3e53a99783185bddd4ac6c34","modified":1702307607790},{"_id":"source/_posts/Cpp-basics-1.md","hash":"50555c469708548399fe8c4b1ae6a2f9f4cf48cc","modified":1702307543053},{"_id":"source/_posts/Cpp-basics-2.md","hash":"bcf386e8add4df4629dfcc29725fb44483ea4b91","modified":1702307552817},{"_id":"source/_posts/Cpp-basics-3.md","hash":"9bcc295c9921ff50ef4a2f7ba3b79a653abb4400","modified":1702307562049},{"_id":"source/_posts/Cpp-basics-4.md","hash":"0a882acecbc8ac648cde2b5679c28e3c829be067","modified":1702307571509},{"_id":"public/2023/12/03/Cpp-basics-4/index.html","hash":"f271119bffd19d425f2317f66fe55c10d7a3bea2","modified":1702307607790},{"_id":"public/2023/12/03/Cpp-basics-3/index.html","hash":"33b0e31e0029e38782447ad3a3eaad337b38af2a","modified":1702307607790},{"_id":"public/2023/12/03/Cpp-basics-2/index.html","hash":"67d0a1cbbe3dc5c77fcafe4f0032d92544980305","modified":1702307607790},{"_id":"public/2023/12/03/Cpp-basics-1/index.html","hash":"f91ff1ddc61cafbc18b86c2c74add2ee507edd5f","modified":1702307607790},{"_id":"public/tags/Cpp/index.html","hash":"f3ca17a170dc21e9d99e27a580607dfac8c42015","modified":1702307607790},{"_id":"source/images/Cpp-Basics-3-1.png","hash":"d37ee7ca1525dccd14fb09b71a8d84dc9f528bff","modified":1701615551509},{"_id":"public/images/Cpp-Basics-3-1.png","hash":"d37ee7ca1525dccd14fb09b71a8d84dc9f528bff","modified":1701615696256},{"_id":"source/_posts/Cpp-basics-5.md","hash":"23eae02768c2a1c419124ad6af54862ed11598bf","modified":1702307580477},{"_id":"public/2023/12/03/Cpp-basics-5/index.html","hash":"20aab1fc7c55c01cb3e53c601c1bbfe2a807de6e","modified":1702307607790},{"_id":"source/_posts/Template-programming-1.md","hash":"6468a228b5e0df210112afa5fa7f192a8a29b62a","modified":1702307589473},{"_id":"public/2023/12/08/Template-programming-1/index.html","hash":"d776488610cc1902ee426defbacaf74ff7ed16dc","modified":1702307607790},{"_id":"source/_posts/lock-free-programming.md","hash":"cf2343cda0d8898232a69f9ef75247d6d941bdc2","modified":1702307530477},{"_id":"public/2023/12/11/lock-free-programming/index.html","hash":"6e5838a88427c613fbfc40a1cd7cd817a41eb6c8","modified":1702307607790}],"Category":[],"Data":[],"Page":[{"title":"About Me","layout":"about","date":"2023-12-01T08:44:29.000Z","_content":"\n## 教育背景\n**西安交通大学** Bachelor\n　　　　\n## 工作经历\n\n### 阿里巴巴网络技术有限公司 \n**服务端开发工程师**  2021年3月 -- 2022年7月\n在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。\n\n1. 进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。\n2. 解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。\n3. 在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。\n\n### 某量化投资有限公司\n**交易系统开发工程师**  2022年7月 -- 至今\n从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。\n\n1. 进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load/Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。\n2. 负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法/数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。\n3. 优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。\n4. 在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。\n\n## 专业技能\n\n- 熟悉C++ 20的新特性，了解模板编程\n- 了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率\n- 了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验\n- 其他语言的开发能力，包括Rust、Java、Python等\n","source":"about/index.md","raw":"---\ntitle: About Me\nlayout: about\ndate: 2023-12-01 16:44:29\n---\n\n## 教育背景\n**西安交通大学** Bachelor\n　　　　\n## 工作经历\n\n### 阿里巴巴网络技术有限公司 \n**服务端开发工程师**  2021年3月 -- 2022年7月\n在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。\n\n1. 进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。\n2. 解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。\n3. 在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。\n\n### 某量化投资有限公司\n**交易系统开发工程师**  2022年7月 -- 至今\n从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。\n\n1. 进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load/Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。\n2. 负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法/数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。\n3. 优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。\n4. 在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。\n\n## 专业技能\n\n- 熟悉C++ 20的新特性，了解模板编程\n- 了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率\n- 了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验\n- 其他语言的开发能力，包括Rust、Java、Python等\n","updated":"2023-12-01T20:00:05.533Z","path":"about/index.html","_id":"clpmegrwo0000fkx504uy240p","comments":1,"content":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p><strong>西安交通大学</strong> Bachelor\n　　　　</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"阿里巴巴网络技术有限公司\"><a href=\"#阿里巴巴网络技术有限公司\" class=\"headerlink\" title=\"阿里巴巴网络技术有限公司\"></a>阿里巴巴网络技术有限公司</h3><p><strong>服务端开发工程师</strong>  2021年3月 – 2022年7月<br>在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。</p>\n<ol>\n<li>进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。</li>\n<li>解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。</li>\n<li>在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。</li>\n</ol>\n<h3 id=\"某量化投资有限公司\"><a href=\"#某量化投资有限公司\" class=\"headerlink\" title=\"某量化投资有限公司\"></a>某量化投资有限公司</h3><p><strong>交易系统开发工程师</strong>  2022年7月 – 至今<br>从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。</p>\n<ol>\n<li>进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load&#x2F;Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。</li>\n<li>负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法&#x2F;数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。</li>\n<li>优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。</li>\n<li>在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。</li>\n</ol>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>熟悉C++ 20的新特性，了解模板编程</li>\n<li>了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率</li>\n<li>了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验</li>\n<li>其他语言的开发能力，包括Rust、Java、Python等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p><strong>西安交通大学</strong> Bachelor\n　　　　</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"阿里巴巴网络技术有限公司\"><a href=\"#阿里巴巴网络技术有限公司\" class=\"headerlink\" title=\"阿里巴巴网络技术有限公司\"></a>阿里巴巴网络技术有限公司</h3><p><strong>服务端开发工程师</strong>  2021年3月 – 2022年7月<br>在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。</p>\n<ol>\n<li>进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。</li>\n<li>解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。</li>\n<li>在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。</li>\n</ol>\n<h3 id=\"某量化投资有限公司\"><a href=\"#某量化投资有限公司\" class=\"headerlink\" title=\"某量化投资有限公司\"></a>某量化投资有限公司</h3><p><strong>交易系统开发工程师</strong>  2022年7月 – 至今<br>从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。</p>\n<ol>\n<li>进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load&#x2F;Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。</li>\n<li>负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法&#x2F;数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。</li>\n<li>优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。</li>\n<li>在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。</li>\n</ol>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>熟悉C++ 20的新特性，了解模板编程</li>\n<li>了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率</li>\n<li>了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验</li>\n<li>其他语言的开发能力，包括Rust、Java、Python等</li>\n</ul>\n"}],"Post":[{"title":"迁移计划","date":"2023-12-01T18:45:20.000Z","_content":"\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n#### C++语法方面的一些个人笔记\n\n- C++的一些基础知识回顾\n- C++ 20以上的新特性\n#### 计算机体系结构下的读书笔记\n\n- 共享内存整理\n- 异步事件框架\n- 分布式一致性协议\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n#### 探索过的编程模式\n\n- 无锁编程\n- 并发编程\n- 模版编程\n- 无分支编程\n- 缓存友好编程\n#### 工作中遇到过的因为技术层导致的问题\n\n- grafana产生的大量close_wait拖垮数据库\n- 为了效率降低分布式系统的一致性等级造成的异常\n#### 工作中部分项目的总结\n\n- 项目的稳定性治理\n- 重构项目的技巧与总结\n- 基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n#### 一些常用工具的学习和了解\n\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","source":"_posts/some-plans.md","raw":"---\ntitle: 迁移计划\ndate: 2023-12-02 02:45:20\ntags: Plan\n---\n\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n#### C++语法方面的一些个人笔记\n\n- C++的一些基础知识回顾\n- C++ 20以上的新特性\n#### 计算机体系结构下的读书笔记\n\n- 共享内存整理\n- 异步事件框架\n- 分布式一致性协议\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n#### 探索过的编程模式\n\n- 无锁编程\n- 并发编程\n- 模版编程\n- 无分支编程\n- 缓存友好编程\n#### 工作中遇到过的因为技术层导致的问题\n\n- grafana产生的大量close_wait拖垮数据库\n- 为了效率降低分布式系统的一致性等级造成的异常\n#### 工作中部分项目的总结\n\n- 项目的稳定性治理\n- 重构项目的技巧与总结\n- 基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n#### 一些常用工具的学习和了解\n\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","slug":"some-plans","published":1,"updated":"2023-12-01T19:35:23.498Z","_id":"clpn0tde6000004x529vjdu07","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>C++的一些基础知识回顾</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li>分布式一致性协议</li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>无锁编程</li>\n<li>并发编程</li>\n<li>模版编程</li>\n<li>无分支编程</li>\n<li>缓存友好编程</li>\n</ul>\n<h4 id=\"工作中遇到过的因为技术层导致的问题\"><a href=\"#工作中遇到过的因为技术层导致的问题\" class=\"headerlink\" title=\"工作中遇到过的因为技术层导致的问题\"></a>工作中遇到过的因为技术层导致的问题</h4><ul>\n<li>grafana产生的大量close_wait拖垮数据库</li>\n<li>为了效率降低分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li>项目的稳定性治理</li>\n<li>重构项目的技巧与总结</li>\n<li>基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>C++的一些基础知识回顾</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li>分布式一致性协议</li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>无锁编程</li>\n<li>并发编程</li>\n<li>模版编程</li>\n<li>无分支编程</li>\n<li>缓存友好编程</li>\n</ul>\n<h4 id=\"工作中遇到过的因为技术层导致的问题\"><a href=\"#工作中遇到过的因为技术层导致的问题\" class=\"headerlink\" title=\"工作中遇到过的因为技术层导致的问题\"></a>工作中遇到过的因为技术层导致的问题</h4><ul>\n<li>grafana产生的大量close_wait拖垮数据库</li>\n<li>为了效率降低分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li>项目的稳定性治理</li>\n<li>重构项目的技巧与总结</li>\n<li>基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n"},{"title":"Cpp基础知识点(一)","date":"2023-12-03T14:13:11.000Z","abstract":"Cpp语言的常用关键字","_content":"本文是关于一些Cpp语言的常用关键字的整理。\n## volatile特性\n### 易变性\n在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。\n### 不可优化性\nvolatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。\n### 顺序性\n能够保证volatile变量间的顺序性，编译器不会进行乱序优化。\n### 拓展\nvolatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。\nvolatile变量间的操作，是不会被编译器交换顺序的。\n哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。\n## static特性\n静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。\n### 修饰局部变量\n一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。\n但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。\n### 修饰全局变量\n对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。\n### 修饰函数\n用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。\n### 修饰类变量\n如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。\n### 修饰类函数\n如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。\n## const特性\n### 修饰基本数据类型\n修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。\n### 修饰指针或引用\n修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。\n### 修饰函数参数\n调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。\n### 修饰函数返回值\n声明了返回值后，const按照\"修饰原则\"进行修饰，起到相应的保护作用。\n### 修饰类\n不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。\n## extern作用\n### 引用外部依赖\n#### 作用\n修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。\n#### 优势\n其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。\n### 指定调用规范\n在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。\n## final作用\n当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。\n## inline作用\ninline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。\n## explicit作用\n声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。\n## this指针作用\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## Static与Const区别\nconst强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用\n## define与Const区别\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## define与typedef区别\n#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。\n## define与inline区别\n\n1. 内联函数在编译时展开，而宏在预编译时展开。\n2. 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 \n3. 内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 \n4. 宏不是函数，而inline是函数。 \n5. 宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 \n6. inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。\n## 几个不同的函数的拷贝实现\n### strcat: char *strcat(char *dst, char const *src)\n\n- 头文件: #include <string.h>\n- 作用: 将dst和src字符串拼接起来保存在dst上\n- 注意事项:\n   - dst必须有足够的空间保存整个字符串\n   - dst和src都必须是一个由'\\0'结尾的字符串(空字符串也行)\n   - dst和src内存不能发生重叠\n- 函数实现:\n   - 首先找到dst的end\n   - 以src的'\\0'作为结束标志, 将src添加到dst的end上\n```\nchar *strcat (char * dst, const char * src){\n  assert(NULL != dst && NULL != src);   // 源码里没有断言检测\n  char * cp = dst;\n  while(*cp )\n       cp++;                      /* find end of dst */\n  while(*cp++ = *src++) ;         /* Copy src to end of dst */\n  return( dst );                  /* return dst */\n  }\n```\n### strcpy: char *strcpy(char *dst, const char *src)\n\n- 头文件:#include <string.h>\n- 作用: 将src的字符串复制到dst字符串内\n- 注意事项:\n   - src必须有结束符'\\0', 结束符也会被复制\n   - src和dst不能有内存重叠\n   - dst必须有足够的内存\n- 函数实现:\n```\nchar *strcpy(char *dst, const char *src){   // 实现src到dst的复制\n  if(dst == src) return dst;              //源码中没有此项\n  　  assert((dst != NULL) && (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性\n  　　char *cp = dst;                         //保存目标字符串的首地址\n  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下\n  　　return dst;\n  }\n```\n### strncpy: char *strncpy(char *dst, char const *src, size_t len)\n\n- 头文件: #include <string.h>\n- 作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾\n- 注意事项:\n   - strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。\n   - 如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。\n   - 如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。\n- 函数实现:\n```\nchar *strncpy(char *dst, const char *src, size_t len)\n  {\n  assert(dst != NULL && src != NULL);     //源码没有此项\n  char *cp = dst;\n  while (len-- > 0 && *src != '\\0')\n      *cp++ = *src++;\n  *cp = '\\0';                             //源码没有此项\n  return dst;\n  }\n```\n### memset: void *memset(void *a, int ch, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。\n   - 在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。\n   - 一定要保证a有这么多字节\n- 函数实现:\n```\nvoid *memset(void *a, int ch, size_t length){\n  assert(a != NULL);     \n  void *s = a;     \n  while (length--)     \n  {     \n      *(char *)s = (char) ch;     \n      s = (char *)s + 1;     \n  }     \n  return a;     \n  }\n```\n### memcpy：void *memcpy(void *dst, const void *src, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。\n   - 可以用这种方法复制任何类型的值，\n   - 如果src和dst以任何形式出现了重叠，它的结果将是未定义的。\n- 函数实现:\n```\nvoid *memcpy(void *dst, const void *src, size_t length)\n  {\n  assert((dst != NULL) && (src != NULL));\n  　　char *tempSrc= (char *)src;            //保存src首地址\n  　　char *tempDst = (char *)dst;           //保存dst首地址\n  　　while(length-- > 0)                    //循环length次，复制src的值到dst中\n     　　*tempDst++ = *tempSrc++ ;\n  　　return dst;\n  }\n```\n### strcpy 和 memcpy 的主要区别\n\n- 复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。\n- 复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符'\\0'才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到'\\0'并不结束。\n- 用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy\n## auto&decltype作用\n使用他们可以在编译期就推导出变量或者表达式的类型。\n## 强制类型转换\n### static_cast\n用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。\n特性:\n\n1. 它没有运行时类型检查，所以是有安全隐患的。\n2. 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。\n3. static_cast不能转换const，volatile等属性\n### dynamic_cast\n用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。\n### const_cast\n用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。\n### reinterpret_cast\n除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。\n","source":"_posts/Cpp-basics-1.md","raw":"---\ntitle: Cpp基础知识点(一)\ndate: 2023-12-03 22:13:11\ntags: Cpp\nabstract: Cpp语言的常用关键字\n---\n本文是关于一些Cpp语言的常用关键字的整理。\n## volatile特性\n### 易变性\n在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。\n### 不可优化性\nvolatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。\n### 顺序性\n能够保证volatile变量间的顺序性，编译器不会进行乱序优化。\n### 拓展\nvolatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。\nvolatile变量间的操作，是不会被编译器交换顺序的。\n哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。\n## static特性\n静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。\n### 修饰局部变量\n一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。\n但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。\n### 修饰全局变量\n对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。\n### 修饰函数\n用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。\n### 修饰类变量\n如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。\n### 修饰类函数\n如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。\n## const特性\n### 修饰基本数据类型\n修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。\n### 修饰指针或引用\n修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。\n### 修饰函数参数\n调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。\n### 修饰函数返回值\n声明了返回值后，const按照\"修饰原则\"进行修饰，起到相应的保护作用。\n### 修饰类\n不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。\n## extern作用\n### 引用外部依赖\n#### 作用\n修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。\n#### 优势\n其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。\n### 指定调用规范\n在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。\n## final作用\n当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。\n## inline作用\ninline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。\n## explicit作用\n声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。\n## this指针作用\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## Static与Const区别\nconst强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用\n## define与Const区别\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## define与typedef区别\n#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。\n## define与inline区别\n\n1. 内联函数在编译时展开，而宏在预编译时展开。\n2. 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 \n3. 内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 \n4. 宏不是函数，而inline是函数。 \n5. 宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 \n6. inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。\n## 几个不同的函数的拷贝实现\n### strcat: char *strcat(char *dst, char const *src)\n\n- 头文件: #include <string.h>\n- 作用: 将dst和src字符串拼接起来保存在dst上\n- 注意事项:\n   - dst必须有足够的空间保存整个字符串\n   - dst和src都必须是一个由'\\0'结尾的字符串(空字符串也行)\n   - dst和src内存不能发生重叠\n- 函数实现:\n   - 首先找到dst的end\n   - 以src的'\\0'作为结束标志, 将src添加到dst的end上\n```\nchar *strcat (char * dst, const char * src){\n  assert(NULL != dst && NULL != src);   // 源码里没有断言检测\n  char * cp = dst;\n  while(*cp )\n       cp++;                      /* find end of dst */\n  while(*cp++ = *src++) ;         /* Copy src to end of dst */\n  return( dst );                  /* return dst */\n  }\n```\n### strcpy: char *strcpy(char *dst, const char *src)\n\n- 头文件:#include <string.h>\n- 作用: 将src的字符串复制到dst字符串内\n- 注意事项:\n   - src必须有结束符'\\0', 结束符也会被复制\n   - src和dst不能有内存重叠\n   - dst必须有足够的内存\n- 函数实现:\n```\nchar *strcpy(char *dst, const char *src){   // 实现src到dst的复制\n  if(dst == src) return dst;              //源码中没有此项\n  　  assert((dst != NULL) && (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性\n  　　char *cp = dst;                         //保存目标字符串的首地址\n  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下\n  　　return dst;\n  }\n```\n### strncpy: char *strncpy(char *dst, char const *src, size_t len)\n\n- 头文件: #include <string.h>\n- 作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾\n- 注意事项:\n   - strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。\n   - 如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。\n   - 如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。\n- 函数实现:\n```\nchar *strncpy(char *dst, const char *src, size_t len)\n  {\n  assert(dst != NULL && src != NULL);     //源码没有此项\n  char *cp = dst;\n  while (len-- > 0 && *src != '\\0')\n      *cp++ = *src++;\n  *cp = '\\0';                             //源码没有此项\n  return dst;\n  }\n```\n### memset: void *memset(void *a, int ch, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。\n   - 在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。\n   - 一定要保证a有这么多字节\n- 函数实现:\n```\nvoid *memset(void *a, int ch, size_t length){\n  assert(a != NULL);     \n  void *s = a;     \n  while (length--)     \n  {     \n      *(char *)s = (char) ch;     \n      s = (char *)s + 1;     \n  }     \n  return a;     \n  }\n```\n### memcpy：void *memcpy(void *dst, const void *src, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。\n   - 可以用这种方法复制任何类型的值，\n   - 如果src和dst以任何形式出现了重叠，它的结果将是未定义的。\n- 函数实现:\n```\nvoid *memcpy(void *dst, const void *src, size_t length)\n  {\n  assert((dst != NULL) && (src != NULL));\n  　　char *tempSrc= (char *)src;            //保存src首地址\n  　　char *tempDst = (char *)dst;           //保存dst首地址\n  　　while(length-- > 0)                    //循环length次，复制src的值到dst中\n     　　*tempDst++ = *tempSrc++ ;\n  　　return dst;\n  }\n```\n### strcpy 和 memcpy 的主要区别\n\n- 复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。\n- 复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符'\\0'才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到'\\0'并不结束。\n- 用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy\n## auto&decltype作用\n使用他们可以在编译期就推导出变量或者表达式的类型。\n## 强制类型转换\n### static_cast\n用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。\n特性:\n\n1. 它没有运行时类型检查，所以是有安全隐患的。\n2. 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。\n3. static_cast不能转换const，volatile等属性\n### dynamic_cast\n用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。\n### const_cast\n用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。\n### reinterpret_cast\n除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。\n","slug":"Cpp-basics-1","published":1,"updated":"2023-12-11T15:12:23.053Z","_id":"clppkl91m00000ix53f2wctgr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是关于一些Cpp语言的常用关键字的整理。</p>\n<h2 id=\"volatile特性\"><a href=\"#volatile特性\" class=\"headerlink\" title=\"volatile特性\"></a>volatile特性</h2><h3 id=\"易变性\"><a href=\"#易变性\" class=\"headerlink\" title=\"易变性\"></a>易变性</h3><p>在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</p>\n<h3 id=\"不可优化性\"><a href=\"#不可优化性\" class=\"headerlink\" title=\"不可优化性\"></a>不可优化性</h3><p>volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</p>\n<h3 id=\"顺序性\"><a href=\"#顺序性\" class=\"headerlink\" title=\"顺序性\"></a>顺序性</h3><p>能够保证volatile变量间的顺序性，编译器不会进行乱序优化。</p>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><p>volatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。<br>volatile变量间的操作，是不会被编译器交换顺序的。<br>哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。</p>\n<h2 id=\"static特性\"><a href=\"#static特性\" class=\"headerlink\" title=\"static特性\"></a>static特性</h2><p>静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。</p>\n<h3 id=\"修饰局部变量\"><a href=\"#修饰局部变量\" class=\"headerlink\" title=\"修饰局部变量\"></a>修饰局部变量</h3><p>一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。<br>但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。</p>\n<h3 id=\"修饰全局变量\"><a href=\"#修饰全局变量\" class=\"headerlink\" title=\"修饰全局变量\"></a>修饰全局变量</h3><p>对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p>\n<h3 id=\"修饰函数\"><a href=\"#修饰函数\" class=\"headerlink\" title=\"修饰函数\"></a>修饰函数</h3><p>用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。</p>\n<h3 id=\"修饰类变量\"><a href=\"#修饰类变量\" class=\"headerlink\" title=\"修饰类变量\"></a>修饰类变量</h3><p>如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。</p>\n<h3 id=\"修饰类函数\"><a href=\"#修饰类函数\" class=\"headerlink\" title=\"修饰类函数\"></a>修饰类函数</h3><p>如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。</p>\n<h2 id=\"const特性\"><a href=\"#const特性\" class=\"headerlink\" title=\"const特性\"></a>const特性</h2><h3 id=\"修饰基本数据类型\"><a href=\"#修饰基本数据类型\" class=\"headerlink\" title=\"修饰基本数据类型\"></a>修饰基本数据类型</h3><p>修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。</p>\n<h3 id=\"修饰指针或引用\"><a href=\"#修饰指针或引用\" class=\"headerlink\" title=\"修饰指针或引用\"></a>修饰指针或引用</h3><p>修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p>\n<h3 id=\"修饰函数参数\"><a href=\"#修饰函数参数\" class=\"headerlink\" title=\"修饰函数参数\"></a>修饰函数参数</h3><p>调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。</p>\n<h3 id=\"修饰函数返回值\"><a href=\"#修饰函数返回值\" class=\"headerlink\" title=\"修饰函数返回值\"></a>修饰函数返回值</h3><p>声明了返回值后，const按照”修饰原则”进行修饰，起到相应的保护作用。</p>\n<h3 id=\"修饰类\"><a href=\"#修饰类\" class=\"headerlink\" title=\"修饰类\"></a>修饰类</h3><p>不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。</p>\n<h2 id=\"extern作用\"><a href=\"#extern作用\" class=\"headerlink\" title=\"extern作用\"></a>extern作用</h2><h3 id=\"引用外部依赖\"><a href=\"#引用外部依赖\" class=\"headerlink\" title=\"引用外部依赖\"></a>引用外部依赖</h3><h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p>其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。</p>\n<h3 id=\"指定调用规范\"><a href=\"#指定调用规范\" class=\"headerlink\" title=\"指定调用规范\"></a>指定调用规范</h3><p>在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</p>\n<h2 id=\"final作用\"><a href=\"#final作用\" class=\"headerlink\" title=\"final作用\"></a>final作用</h2><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p>\n<h2 id=\"inline作用\"><a href=\"#inline作用\" class=\"headerlink\" title=\"inline作用\"></a>inline作用</h2><p>inline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>\n<h2 id=\"explicit作用\"><a href=\"#explicit作用\" class=\"headerlink\" title=\"explicit作用\"></a>explicit作用</h2><p>声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。</p>\n<h2 id=\"this指针作用\"><a href=\"#this指针作用\" class=\"headerlink\" title=\"this指针作用\"></a>this指针作用</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"Static与Const区别\"><a href=\"#Static与Const区别\" class=\"headerlink\" title=\"Static与Const区别\"></a>Static与Const区别</h2><p>const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用</p>\n<h2 id=\"define与Const区别\"><a href=\"#define与Const区别\" class=\"headerlink\" title=\"define与Const区别\"></a>define与Const区别</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"define与typedef区别\"><a href=\"#define与typedef区别\" class=\"headerlink\" title=\"define与typedef区别\"></a>define与typedef区别</h2><p>#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。</p>\n<h2 id=\"define与inline区别\"><a href=\"#define与inline区别\" class=\"headerlink\" title=\"define与inline区别\"></a>define与inline区别</h2><ol>\n<li>内联函数在编译时展开，而宏在预编译时展开。</li>\n<li>在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 </li>\n<li>内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 </li>\n<li>宏不是函数，而inline是函数。 </li>\n<li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 </li>\n<li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</li>\n</ol>\n<h2 id=\"几个不同的函数的拷贝实现\"><a href=\"#几个不同的函数的拷贝实现\" class=\"headerlink\" title=\"几个不同的函数的拷贝实现\"></a>几个不同的函数的拷贝实现</h2><h3 id=\"strcat-char-strcat-char-dst-char-const-src\"><a href=\"#strcat-char-strcat-char-dst-char-const-src\" class=\"headerlink\" title=\"strcat: char *strcat(char *dst, char const *src)\"></a>strcat: char *strcat(char *dst, char const *src)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 将dst和src字符串拼接起来保存在dst上</li>\n<li>注意事项:<ul>\n<li>dst必须有足够的空间保存整个字符串</li>\n<li>dst和src都必须是一个由’\\0’结尾的字符串(空字符串也行)</li>\n<li>dst和src内存不能发生重叠</li>\n</ul>\n</li>\n<li>函数实现:<ul>\n<li>首先找到dst的end</li>\n<li>以src的’\\0’作为结束标志, 将src添加到dst的end上<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcat (char * dst, const char * src)&#123;</span><br><span class=\"line\">  assert(NULL != dst &amp;&amp; NULL != src);   // 源码里没有断言检测</span><br><span class=\"line\">  char * cp = dst;</span><br><span class=\"line\">  while(*cp )</span><br><span class=\"line\">       cp++;                      /* find end of dst */</span><br><span class=\"line\">  while(*cp++ = *src++) ;         /* Copy src to end of dst */</span><br><span class=\"line\">  return( dst );                  /* return dst */</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"strcpy-char-strcpy-char-dst-const-char-src\"><a href=\"#strcpy-char-strcpy-char-dst-const-char-src\" class=\"headerlink\" title=\"strcpy: char *strcpy(char *dst, const char *src)\"></a>strcpy: char *strcpy(char *dst, const char *src)</h3><ul>\n<li>头文件:#include &lt;string.h&gt;</li>\n<li>作用: 将src的字符串复制到dst字符串内</li>\n<li>注意事项:<ul>\n<li>src必须有结束符’\\0’, 结束符也会被复制</li>\n<li>src和dst不能有内存重叠</li>\n<li>dst必须有足够的内存</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcpy(char *dst, const char *src)&#123;   // 实现src到dst的复制</span><br><span class=\"line\">  if(dst == src) return dst;              //源码中没有此项</span><br><span class=\"line\">  　  assert((dst != NULL) &amp;&amp; (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性</span><br><span class=\"line\">  　　char *cp = dst;                         //保存目标字符串的首地址</span><br><span class=\"line\">  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strncpy-char-strncpy-char-dst-char-const-src-size-t-len\"><a href=\"#strncpy-char-strncpy-char-dst-char-const-src-size-t-len\" class=\"headerlink\" title=\"strncpy: char *strncpy(char *dst, char const *src, size_t len)\"></a>strncpy: char *strncpy(char *dst, char const *src, size_t len)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾</li>\n<li>注意事项:<ul>\n<li>strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。</li>\n<li>如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。</li>\n<li>如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strncpy(char *dst, const char *src, size_t len)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert(dst != NULL &amp;&amp; src != NULL);     //源码没有此项</span><br><span class=\"line\">  char *cp = dst;</span><br><span class=\"line\">  while (len-- &gt; 0 &amp;&amp; *src != &#x27;\\0&#x27;)</span><br><span class=\"line\">      *cp++ = *src++;</span><br><span class=\"line\">  *cp = &#x27;\\0&#x27;;                             //源码没有此项</span><br><span class=\"line\">  return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memset-void-memset-void-a-int-ch-size-t-length\"><a href=\"#memset-void-memset-void-a-int-ch-size-t-length\" class=\"headerlink\" title=\"memset: void *memset(void *a, int ch, size_t length)\"></a>memset: void *memset(void *a, int ch, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。</li>\n<li>在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。</li>\n<li>一定要保证a有这么多字节</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memset(void *a, int ch, size_t length)&#123;</span><br><span class=\"line\">  assert(a != NULL);     </span><br><span class=\"line\">  void *s = a;     </span><br><span class=\"line\">  while (length--)     </span><br><span class=\"line\">  &#123;     </span><br><span class=\"line\">      *(char *)s = (char) ch;     </span><br><span class=\"line\">      s = (char *)s + 1;     </span><br><span class=\"line\">  &#125;     </span><br><span class=\"line\">  return a;     </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memcpy：void-memcpy-void-dst-const-void-src-size-t-length\"><a href=\"#memcpy：void-memcpy-void-dst-const-void-src-size-t-length\" class=\"headerlink\" title=\"memcpy：void *memcpy(void *dst, const void *src, size_t length)\"></a>memcpy：void *memcpy(void *dst, const void *src, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。</li>\n<li>可以用这种方法复制任何类型的值，</li>\n<li>如果src和dst以任何形式出现了重叠，它的结果将是未定义的。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memcpy(void *dst, const void *src, size_t length)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert((dst != NULL) &amp;&amp; (src != NULL));</span><br><span class=\"line\">  　　char *tempSrc= (char *)src;            //保存src首地址</span><br><span class=\"line\">  　　char *tempDst = (char *)dst;           //保存dst首地址</span><br><span class=\"line\">  　　while(length-- &gt; 0)                    //循环length次，复制src的值到dst中</span><br><span class=\"line\">     　　*tempDst++ = *tempSrc++ ;</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strcpy-和-memcpy-的主要区别\"><a href=\"#strcpy-和-memcpy-的主要区别\" class=\"headerlink\" title=\"strcpy 和 memcpy 的主要区别\"></a>strcpy 和 memcpy 的主要区别</h3><ul>\n<li>复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。</li>\n<li>复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符’\\0’才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到’\\0’并不结束。</li>\n<li>用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy</li>\n</ul>\n<h2 id=\"auto-decltype作用\"><a href=\"#auto-decltype作用\" class=\"headerlink\" title=\"auto&amp;decltype作用\"></a>auto&amp;decltype作用</h2><p>使用他们可以在编译期就推导出变量或者表达式的类型。</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<br>特性:</p>\n<ol>\n<li>它没有运行时类型检查，所以是有安全隐患的。</li>\n<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>\n<li>static_cast不能转换const，volatile等属性</li>\n</ol>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。</p>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是关于一些Cpp语言的常用关键字的整理。</p>\n<h2 id=\"volatile特性\"><a href=\"#volatile特性\" class=\"headerlink\" title=\"volatile特性\"></a>volatile特性</h2><h3 id=\"易变性\"><a href=\"#易变性\" class=\"headerlink\" title=\"易变性\"></a>易变性</h3><p>在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</p>\n<h3 id=\"不可优化性\"><a href=\"#不可优化性\" class=\"headerlink\" title=\"不可优化性\"></a>不可优化性</h3><p>volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</p>\n<h3 id=\"顺序性\"><a href=\"#顺序性\" class=\"headerlink\" title=\"顺序性\"></a>顺序性</h3><p>能够保证volatile变量间的顺序性，编译器不会进行乱序优化。</p>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><p>volatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。<br>volatile变量间的操作，是不会被编译器交换顺序的。<br>哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。</p>\n<h2 id=\"static特性\"><a href=\"#static特性\" class=\"headerlink\" title=\"static特性\"></a>static特性</h2><p>静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。</p>\n<h3 id=\"修饰局部变量\"><a href=\"#修饰局部变量\" class=\"headerlink\" title=\"修饰局部变量\"></a>修饰局部变量</h3><p>一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。<br>但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。</p>\n<h3 id=\"修饰全局变量\"><a href=\"#修饰全局变量\" class=\"headerlink\" title=\"修饰全局变量\"></a>修饰全局变量</h3><p>对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p>\n<h3 id=\"修饰函数\"><a href=\"#修饰函数\" class=\"headerlink\" title=\"修饰函数\"></a>修饰函数</h3><p>用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。</p>\n<h3 id=\"修饰类变量\"><a href=\"#修饰类变量\" class=\"headerlink\" title=\"修饰类变量\"></a>修饰类变量</h3><p>如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。</p>\n<h3 id=\"修饰类函数\"><a href=\"#修饰类函数\" class=\"headerlink\" title=\"修饰类函数\"></a>修饰类函数</h3><p>如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。</p>\n<h2 id=\"const特性\"><a href=\"#const特性\" class=\"headerlink\" title=\"const特性\"></a>const特性</h2><h3 id=\"修饰基本数据类型\"><a href=\"#修饰基本数据类型\" class=\"headerlink\" title=\"修饰基本数据类型\"></a>修饰基本数据类型</h3><p>修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。</p>\n<h3 id=\"修饰指针或引用\"><a href=\"#修饰指针或引用\" class=\"headerlink\" title=\"修饰指针或引用\"></a>修饰指针或引用</h3><p>修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p>\n<h3 id=\"修饰函数参数\"><a href=\"#修饰函数参数\" class=\"headerlink\" title=\"修饰函数参数\"></a>修饰函数参数</h3><p>调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。</p>\n<h3 id=\"修饰函数返回值\"><a href=\"#修饰函数返回值\" class=\"headerlink\" title=\"修饰函数返回值\"></a>修饰函数返回值</h3><p>声明了返回值后，const按照”修饰原则”进行修饰，起到相应的保护作用。</p>\n<h3 id=\"修饰类\"><a href=\"#修饰类\" class=\"headerlink\" title=\"修饰类\"></a>修饰类</h3><p>不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。</p>\n<h2 id=\"extern作用\"><a href=\"#extern作用\" class=\"headerlink\" title=\"extern作用\"></a>extern作用</h2><h3 id=\"引用外部依赖\"><a href=\"#引用外部依赖\" class=\"headerlink\" title=\"引用外部依赖\"></a>引用外部依赖</h3><h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p>其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。</p>\n<h3 id=\"指定调用规范\"><a href=\"#指定调用规范\" class=\"headerlink\" title=\"指定调用规范\"></a>指定调用规范</h3><p>在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</p>\n<h2 id=\"final作用\"><a href=\"#final作用\" class=\"headerlink\" title=\"final作用\"></a>final作用</h2><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p>\n<h2 id=\"inline作用\"><a href=\"#inline作用\" class=\"headerlink\" title=\"inline作用\"></a>inline作用</h2><p>inline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>\n<h2 id=\"explicit作用\"><a href=\"#explicit作用\" class=\"headerlink\" title=\"explicit作用\"></a>explicit作用</h2><p>声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。</p>\n<h2 id=\"this指针作用\"><a href=\"#this指针作用\" class=\"headerlink\" title=\"this指针作用\"></a>this指针作用</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"Static与Const区别\"><a href=\"#Static与Const区别\" class=\"headerlink\" title=\"Static与Const区别\"></a>Static与Const区别</h2><p>const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用</p>\n<h2 id=\"define与Const区别\"><a href=\"#define与Const区别\" class=\"headerlink\" title=\"define与Const区别\"></a>define与Const区别</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"define与typedef区别\"><a href=\"#define与typedef区别\" class=\"headerlink\" title=\"define与typedef区别\"></a>define与typedef区别</h2><p>#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。</p>\n<h2 id=\"define与inline区别\"><a href=\"#define与inline区别\" class=\"headerlink\" title=\"define与inline区别\"></a>define与inline区别</h2><ol>\n<li>内联函数在编译时展开，而宏在预编译时展开。</li>\n<li>在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 </li>\n<li>内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 </li>\n<li>宏不是函数，而inline是函数。 </li>\n<li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 </li>\n<li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</li>\n</ol>\n<h2 id=\"几个不同的函数的拷贝实现\"><a href=\"#几个不同的函数的拷贝实现\" class=\"headerlink\" title=\"几个不同的函数的拷贝实现\"></a>几个不同的函数的拷贝实现</h2><h3 id=\"strcat-char-strcat-char-dst-char-const-src\"><a href=\"#strcat-char-strcat-char-dst-char-const-src\" class=\"headerlink\" title=\"strcat: char *strcat(char *dst, char const *src)\"></a>strcat: char *strcat(char *dst, char const *src)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 将dst和src字符串拼接起来保存在dst上</li>\n<li>注意事项:<ul>\n<li>dst必须有足够的空间保存整个字符串</li>\n<li>dst和src都必须是一个由’\\0’结尾的字符串(空字符串也行)</li>\n<li>dst和src内存不能发生重叠</li>\n</ul>\n</li>\n<li>函数实现:<ul>\n<li>首先找到dst的end</li>\n<li>以src的’\\0’作为结束标志, 将src添加到dst的end上<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcat (char * dst, const char * src)&#123;</span><br><span class=\"line\">  assert(NULL != dst &amp;&amp; NULL != src);   // 源码里没有断言检测</span><br><span class=\"line\">  char * cp = dst;</span><br><span class=\"line\">  while(*cp )</span><br><span class=\"line\">       cp++;                      /* find end of dst */</span><br><span class=\"line\">  while(*cp++ = *src++) ;         /* Copy src to end of dst */</span><br><span class=\"line\">  return( dst );                  /* return dst */</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"strcpy-char-strcpy-char-dst-const-char-src\"><a href=\"#strcpy-char-strcpy-char-dst-const-char-src\" class=\"headerlink\" title=\"strcpy: char *strcpy(char *dst, const char *src)\"></a>strcpy: char *strcpy(char *dst, const char *src)</h3><ul>\n<li>头文件:#include &lt;string.h&gt;</li>\n<li>作用: 将src的字符串复制到dst字符串内</li>\n<li>注意事项:<ul>\n<li>src必须有结束符’\\0’, 结束符也会被复制</li>\n<li>src和dst不能有内存重叠</li>\n<li>dst必须有足够的内存</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcpy(char *dst, const char *src)&#123;   // 实现src到dst的复制</span><br><span class=\"line\">  if(dst == src) return dst;              //源码中没有此项</span><br><span class=\"line\">  　  assert((dst != NULL) &amp;&amp; (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性</span><br><span class=\"line\">  　　char *cp = dst;                         //保存目标字符串的首地址</span><br><span class=\"line\">  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strncpy-char-strncpy-char-dst-char-const-src-size-t-len\"><a href=\"#strncpy-char-strncpy-char-dst-char-const-src-size-t-len\" class=\"headerlink\" title=\"strncpy: char *strncpy(char *dst, char const *src, size_t len)\"></a>strncpy: char *strncpy(char *dst, char const *src, size_t len)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾</li>\n<li>注意事项:<ul>\n<li>strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。</li>\n<li>如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。</li>\n<li>如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strncpy(char *dst, const char *src, size_t len)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert(dst != NULL &amp;&amp; src != NULL);     //源码没有此项</span><br><span class=\"line\">  char *cp = dst;</span><br><span class=\"line\">  while (len-- &gt; 0 &amp;&amp; *src != &#x27;\\0&#x27;)</span><br><span class=\"line\">      *cp++ = *src++;</span><br><span class=\"line\">  *cp = &#x27;\\0&#x27;;                             //源码没有此项</span><br><span class=\"line\">  return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memset-void-memset-void-a-int-ch-size-t-length\"><a href=\"#memset-void-memset-void-a-int-ch-size-t-length\" class=\"headerlink\" title=\"memset: void *memset(void *a, int ch, size_t length)\"></a>memset: void *memset(void *a, int ch, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。</li>\n<li>在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。</li>\n<li>一定要保证a有这么多字节</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memset(void *a, int ch, size_t length)&#123;</span><br><span class=\"line\">  assert(a != NULL);     </span><br><span class=\"line\">  void *s = a;     </span><br><span class=\"line\">  while (length--)     </span><br><span class=\"line\">  &#123;     </span><br><span class=\"line\">      *(char *)s = (char) ch;     </span><br><span class=\"line\">      s = (char *)s + 1;     </span><br><span class=\"line\">  &#125;     </span><br><span class=\"line\">  return a;     </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memcpy：void-memcpy-void-dst-const-void-src-size-t-length\"><a href=\"#memcpy：void-memcpy-void-dst-const-void-src-size-t-length\" class=\"headerlink\" title=\"memcpy：void *memcpy(void *dst, const void *src, size_t length)\"></a>memcpy：void *memcpy(void *dst, const void *src, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。</li>\n<li>可以用这种方法复制任何类型的值，</li>\n<li>如果src和dst以任何形式出现了重叠，它的结果将是未定义的。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memcpy(void *dst, const void *src, size_t length)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert((dst != NULL) &amp;&amp; (src != NULL));</span><br><span class=\"line\">  　　char *tempSrc= (char *)src;            //保存src首地址</span><br><span class=\"line\">  　　char *tempDst = (char *)dst;           //保存dst首地址</span><br><span class=\"line\">  　　while(length-- &gt; 0)                    //循环length次，复制src的值到dst中</span><br><span class=\"line\">     　　*tempDst++ = *tempSrc++ ;</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strcpy-和-memcpy-的主要区别\"><a href=\"#strcpy-和-memcpy-的主要区别\" class=\"headerlink\" title=\"strcpy 和 memcpy 的主要区别\"></a>strcpy 和 memcpy 的主要区别</h3><ul>\n<li>复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。</li>\n<li>复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符’\\0’才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到’\\0’并不结束。</li>\n<li>用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy</li>\n</ul>\n<h2 id=\"auto-decltype作用\"><a href=\"#auto-decltype作用\" class=\"headerlink\" title=\"auto&amp;decltype作用\"></a>auto&amp;decltype作用</h2><p>使用他们可以在编译期就推导出变量或者表达式的类型。</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<br>特性:</p>\n<ol>\n<li>它没有运行时类型检查，所以是有安全隐患的。</li>\n<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>\n<li>static_cast不能转换const，volatile等属性</li>\n</ol>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。</p>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。</p>\n"},{"title":"Cpp基础知识点(二)","date":"2023-12-03T14:13:24.000Z","abstract":"Cpp中的一些基础概念","_content":"本文是关于一些Cpp中一些基础概念的整理。\n## main函数执行前过程\n1. 设置栈指针\n2. 初始化静态static变量和global全局变量，即.data段的内容\n3. 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容\n4. 全局对象初始化，在main之前调用构造函数\n5. 将main函数的参数argc，argv等传递给main函数，真正运行main函数\n## 普通函数调用过程\n\n1. 设置栈指针，在栈中放入下一条指令的地址\n2. 然后为形参和局部变量分配存储空间\n3. 将实参的值复制给形参\n4. 进行函数内操作\n5. return 语句返回时，从栈中回收形参和局部变量占用的存储空间\n6. 从栈中取出返回地址\n7. 跳转到该地址继续执行\n## 代码编译过程\n预处理：对预处理命令进行替换等预处理操作\n编译：代码优化和生成汇编代码\n汇编：将汇编代码转化为机器语言\n链接：将目标文件彼此链接起来\n## 动态链接和静态链接\n### 静态链接\n函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 \n**空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本； \n**更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 \n**运行速度快**：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。\n### 动态链接\n动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 \n**共享库**：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；\n**更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 \n**性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。\n### 区别\n\n1. 使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份\n2. 使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂\n3. **静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.**\n## 指针与引用\n### 概念\n\n1. 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量\n2. 引用是一个别名，对引用的操作就是对变量的本身进行操作\n### 区别\n\n1. 指针可以有多级，引用只有一级 \n2. 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 \n3. 指针可以为空，引用不可以\n### 使用场景\n\n1. 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的\n2. 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小;类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。\n### 引用和指针在汇编层\n引用和指针在汇编层完全一样，引用就是指针。\n但在开发使用过程中，引用是等效于常量指针的（指向固定的对象），意味着两者在汇编层完全相同。\n借此可以推导一些const关键词的特性：如果在汇编层完全相同的话，这个在使用上隐晦存在的（const）其实是由编译器保证的，它通过静态检查的方式确保引用无法被修改。\n## 声明与定义\n\n1. 声明是告诉编译器变量的类型和名字，不会为变量分配空间\n2. 定义是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。\n## struct与class\n\n1. 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的\n2. struct的继承默认是public继承，而class的继承默认是private继承\n3. class可以用作模板，而struct不能\n## 拷贝\n### 浅拷贝\n将对象的指针进行简单的复制，原对象和副本指向的是相同的资源\n### 深拷贝\n新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址\n### 深浅拷贝的区别\n深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。\n### 零拷贝\n零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。用程序调用mmap()，磁盘上的数据会通过DMA被拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。\n## 友元\n### 概念\n友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。\n### 友元函数\n友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中用friend关键字声明所有可以访问它的友元函数。\n### 友元类\n友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。\n### 友元类的注意点\n\n1. 友元关系不能被继承。 \n2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 \n3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明\n## 列表成员初始化\n\n- 赋值初始化，通过在函数体内进行赋值初始化；\n- 列表初始化，在冒号后使用初始化列表进行初始化。\n\n相对而言，列表成员初始化的效率会更高，列表初始化是给数据成员分配内存空间时就进行初始化, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数。\n## 右值与移动构造\n\n- 右值的概念: 将亡值, 不具名变量\n- 右值引用\n   - 概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.\n   - 优点:\n      - 转移语意\n      - 精确语意传递(参数列表分别为**左值引用**和**右值引用**形成参数重载)\n- 移动构造函数:\n   - 概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.\n   - 实现:\n      - 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。\n      - 也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。\n      - **作为参数的右值将不会再调用析构函数。**\n      - move语句，就是将一个左值变成一个将亡值。\n   - 优点\n      - 避免了无谓的对下销毁和构造的开销\n      - 当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生\n## 函数指针\n\n- 什么是函数指针?\n   - 函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.\n- 函数指针的声明方法\n   - int (*pf)(const int&, const int&); (1)\n   - pf是一个返回类型为int, 参数为两个const int&的函数。**注意*pf 两边的括号是必须的**\n      - 否则上面的定义就变成了：\n      - int *pf(const int&, const int&); // 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&参数.\n- 为什么有函数指针\n   - 可以通过函数指针进行函数调用\n   - 而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数\n   - 另外还能将函数指针作为函数参数进行传递.\n   - 通过函数指针可以把函数的调用者与被调函数分开。\n      - 调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,\n      - 而不需要知道具体是哪个函数被调用.\n- 两种方法赋值：\n   - 指针名 = 函数名\n   - 指针名 = &函数名\n## C++和其他语言的区别\n### 和C的区别\n\n1. C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性\n2. C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete\n3. C++中有函数重载和引用等概念，C中没有\n### 和Java的区别\n\n1. C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高\n2. C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法\n3. C++有指针，Java没有指针，只有引用\n4. JAVA和C++都有构造函数，但是C++有析构函数但是Java没有\n### 和python的区别\n\n1. python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。\n2. python可以很方便的跨平台，但是效率没有C++高\n","source":"_posts/Cpp-basics-2.md","raw":"---\ntitle: Cpp基础知识点(二)\ndate: 2023-12-03 22:13:24\ntags: Cpp\nabstract: Cpp中的一些基础概念\n---\n本文是关于一些Cpp中一些基础概念的整理。\n## main函数执行前过程\n1. 设置栈指针\n2. 初始化静态static变量和global全局变量，即.data段的内容\n3. 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容\n4. 全局对象初始化，在main之前调用构造函数\n5. 将main函数的参数argc，argv等传递给main函数，真正运行main函数\n## 普通函数调用过程\n\n1. 设置栈指针，在栈中放入下一条指令的地址\n2. 然后为形参和局部变量分配存储空间\n3. 将实参的值复制给形参\n4. 进行函数内操作\n5. return 语句返回时，从栈中回收形参和局部变量占用的存储空间\n6. 从栈中取出返回地址\n7. 跳转到该地址继续执行\n## 代码编译过程\n预处理：对预处理命令进行替换等预处理操作\n编译：代码优化和生成汇编代码\n汇编：将汇编代码转化为机器语言\n链接：将目标文件彼此链接起来\n## 动态链接和静态链接\n### 静态链接\n函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 \n**空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本； \n**更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 \n**运行速度快**：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。\n### 动态链接\n动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 \n**共享库**：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；\n**更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 \n**性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。\n### 区别\n\n1. 使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份\n2. 使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂\n3. **静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.**\n## 指针与引用\n### 概念\n\n1. 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量\n2. 引用是一个别名，对引用的操作就是对变量的本身进行操作\n### 区别\n\n1. 指针可以有多级，引用只有一级 \n2. 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 \n3. 指针可以为空，引用不可以\n### 使用场景\n\n1. 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的\n2. 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小;类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。\n### 引用和指针在汇编层\n引用和指针在汇编层完全一样，引用就是指针。\n但在开发使用过程中，引用是等效于常量指针的（指向固定的对象），意味着两者在汇编层完全相同。\n借此可以推导一些const关键词的特性：如果在汇编层完全相同的话，这个在使用上隐晦存在的（const）其实是由编译器保证的，它通过静态检查的方式确保引用无法被修改。\n## 声明与定义\n\n1. 声明是告诉编译器变量的类型和名字，不会为变量分配空间\n2. 定义是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。\n## struct与class\n\n1. 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的\n2. struct的继承默认是public继承，而class的继承默认是private继承\n3. class可以用作模板，而struct不能\n## 拷贝\n### 浅拷贝\n将对象的指针进行简单的复制，原对象和副本指向的是相同的资源\n### 深拷贝\n新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址\n### 深浅拷贝的区别\n深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。\n### 零拷贝\n零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。用程序调用mmap()，磁盘上的数据会通过DMA被拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。\n## 友元\n### 概念\n友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。\n### 友元函数\n友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中用friend关键字声明所有可以访问它的友元函数。\n### 友元类\n友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。\n### 友元类的注意点\n\n1. 友元关系不能被继承。 \n2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 \n3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明\n## 列表成员初始化\n\n- 赋值初始化，通过在函数体内进行赋值初始化；\n- 列表初始化，在冒号后使用初始化列表进行初始化。\n\n相对而言，列表成员初始化的效率会更高，列表初始化是给数据成员分配内存空间时就进行初始化, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数。\n## 右值与移动构造\n\n- 右值的概念: 将亡值, 不具名变量\n- 右值引用\n   - 概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.\n   - 优点:\n      - 转移语意\n      - 精确语意传递(参数列表分别为**左值引用**和**右值引用**形成参数重载)\n- 移动构造函数:\n   - 概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.\n   - 实现:\n      - 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。\n      - 也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。\n      - **作为参数的右值将不会再调用析构函数。**\n      - move语句，就是将一个左值变成一个将亡值。\n   - 优点\n      - 避免了无谓的对下销毁和构造的开销\n      - 当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生\n## 函数指针\n\n- 什么是函数指针?\n   - 函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.\n- 函数指针的声明方法\n   - int (*pf)(const int&, const int&); (1)\n   - pf是一个返回类型为int, 参数为两个const int&的函数。**注意*pf 两边的括号是必须的**\n      - 否则上面的定义就变成了：\n      - int *pf(const int&, const int&); // 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&参数.\n- 为什么有函数指针\n   - 可以通过函数指针进行函数调用\n   - 而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数\n   - 另外还能将函数指针作为函数参数进行传递.\n   - 通过函数指针可以把函数的调用者与被调函数分开。\n      - 调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,\n      - 而不需要知道具体是哪个函数被调用.\n- 两种方法赋值：\n   - 指针名 = 函数名\n   - 指针名 = &函数名\n## C++和其他语言的区别\n### 和C的区别\n\n1. C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性\n2. C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete\n3. C++中有函数重载和引用等概念，C中没有\n### 和Java的区别\n\n1. C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高\n2. C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法\n3. C++有指针，Java没有指针，只有引用\n4. JAVA和C++都有构造函数，但是C++有析构函数但是Java没有\n### 和python的区别\n\n1. python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。\n2. python可以很方便的跨平台，但是效率没有C++高\n","slug":"Cpp-basics-2","published":1,"updated":"2023-12-11T15:12:32.817Z","_id":"clppkl91r00010ix58yax4m3a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是关于一些Cpp中一些基础概念的整理。</p>\n<h2 id=\"main函数执行前过程\"><a href=\"#main函数执行前过程\" class=\"headerlink\" title=\"main函数执行前过程\"></a>main函数执行前过程</h2><ol>\n<li>设置栈指针</li>\n<li>初始化静态static变量和global全局变量，即.data段的内容</li>\n<li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容</li>\n<li>全局对象初始化，在main之前调用构造函数</li>\n<li>将main函数的参数argc，argv等传递给main函数，真正运行main函数</li>\n</ol>\n<h2 id=\"普通函数调用过程\"><a href=\"#普通函数调用过程\" class=\"headerlink\" title=\"普通函数调用过程\"></a>普通函数调用过程</h2><ol>\n<li>设置栈指针，在栈中放入下一条指令的地址</li>\n<li>然后为形参和局部变量分配存储空间</li>\n<li>将实参的值复制给形参</li>\n<li>进行函数内操作</li>\n<li>return 语句返回时，从栈中回收形参和局部变量占用的存储空间</li>\n<li>从栈中取出返回地址</li>\n<li>跳转到该地址继续执行</li>\n</ol>\n<h2 id=\"代码编译过程\"><a href=\"#代码编译过程\" class=\"headerlink\" title=\"代码编译过程\"></a>代码编译过程</h2><p>预处理：对预处理命令进行替换等预处理操作<br>编译：代码优化和生成汇编代码<br>汇编：将汇编代码转化为机器语言<br>链接：将目标文件彼此链接起来</p>\n<h2 id=\"动态链接和静态链接\"><a href=\"#动态链接和静态链接\" class=\"headerlink\" title=\"动态链接和静态链接\"></a>动态链接和静态链接</h2><h3 id=\"静态链接\"><a href=\"#静态链接\" class=\"headerlink\" title=\"静态链接\"></a>静态链接</h3><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。<br><strong>空间浪费</strong>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本；<br><strong>更新困难</strong>：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。<br><strong>运行速度快</strong>：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>\n<h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。<br><strong>共享库</strong>：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；<br><strong>更新方便</strong>：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。<br><strong>性能损耗</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份</li>\n<li>使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂</li>\n<li><strong>静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.</strong></li>\n</ol>\n<h2 id=\"指针与引用\"><a href=\"#指针与引用\" class=\"headerlink\" title=\"指针与引用\"></a>指针与引用</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ol>\n<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量</li>\n<li>引用是一个别名，对引用的操作就是对变量的本身进行操作</li>\n</ol>\n<h3 id=\"区别-1\"><a href=\"#区别-1\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>指针可以有多级，引用只有一级 </li>\n<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 </li>\n<li>指针可以为空，引用不可以</li>\n</ol>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ol>\n<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>\n<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小;类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li>\n</ol>\n<h3 id=\"引用和指针在汇编层\"><a href=\"#引用和指针在汇编层\" class=\"headerlink\" title=\"引用和指针在汇编层\"></a>引用和指针在汇编层</h3><p>引用和指针在汇编层完全一样，引用就是指针。<br>但在开发使用过程中，引用是等效于常量指针的（指向固定的对象），意味着两者在汇编层完全相同。<br>借此可以推导一些const关键词的特性：如果在汇编层完全相同的话，这个在使用上隐晦存在的（const）其实是由编译器保证的，它通过静态检查的方式确保引用无法被修改。</p>\n<h2 id=\"声明与定义\"><a href=\"#声明与定义\" class=\"headerlink\" title=\"声明与定义\"></a>声明与定义</h2><ol>\n<li>声明是告诉编译器变量的类型和名字，不会为变量分配空间</li>\n<li>定义是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。</li>\n</ol>\n<h2 id=\"struct与class\"><a href=\"#struct与class\" class=\"headerlink\" title=\"struct与class\"></a>struct与class</h2><ol>\n<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>\n<li>struct的继承默认是public继承，而class的继承默认是private继承</li>\n<li>class可以用作模板，而struct不能</li>\n</ol>\n<h2 id=\"拷贝\"><a href=\"#拷贝\" class=\"headerlink\" title=\"拷贝\"></a>拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>将对象的指针进行简单的复制，原对象和副本指向的是相同的资源</p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址</p>\n<h3 id=\"深浅拷贝的区别\"><a href=\"#深浅拷贝的区别\" class=\"headerlink\" title=\"深浅拷贝的区别\"></a>深浅拷贝的区别</h3><p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>\n<h3 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h3><p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。用程序调用mmap()，磁盘上的数据会通过DMA被拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>\n<h2 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>\n<h3 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h3><p>友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中用friend关键字声明所有可以访问它的友元函数。</p>\n<h3 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。</p>\n<h3 id=\"友元类的注意点\"><a href=\"#友元类的注意点\" class=\"headerlink\" title=\"友元类的注意点\"></a>友元类的注意点</h3><ol>\n<li>友元关系不能被继承。 </li>\n<li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </li>\n<li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>\n</ol>\n<h2 id=\"列表成员初始化\"><a href=\"#列表成员初始化\" class=\"headerlink\" title=\"列表成员初始化\"></a>列表成员初始化</h2><ul>\n<li>赋值初始化，通过在函数体内进行赋值初始化；</li>\n<li>列表初始化，在冒号后使用初始化列表进行初始化。</li>\n</ul>\n<p>相对而言，列表成员初始化的效率会更高，列表初始化是给数据成员分配内存空间时就进行初始化, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数。</p>\n<h2 id=\"右值与移动构造\"><a href=\"#右值与移动构造\" class=\"headerlink\" title=\"右值与移动构造\"></a>右值与移动构造</h2><ul>\n<li>右值的概念: 将亡值, 不具名变量</li>\n<li>右值引用<ul>\n<li>概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.</li>\n<li>优点:<ul>\n<li>转移语意</li>\n<li>精确语意传递(参数列表分别为<strong>左值引用</strong>和<strong>右值引用</strong>形成参数重载)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>移动构造函数:<ul>\n<li>概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.</li>\n<li>实现:<ul>\n<li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</li>\n<li>也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。</li>\n<li><strong>作为参数的右值将不会再调用析构函数。</strong></li>\n<li>move语句，就是将一个左值变成一个将亡值。</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>避免了无谓的对下销毁和构造的开销</li>\n<li>当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><ul>\n<li>什么是函数指针?<ul>\n<li>函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.</li>\n</ul>\n</li>\n<li>函数指针的声明方法<ul>\n<li>int (*pf)(const int&amp;, const int&amp;); (1)</li>\n<li>pf是一个返回类型为int, 参数为两个const int&amp;的函数。<strong>注意*pf 两边的括号是必须的</strong><ul>\n<li>否则上面的定义就变成了：</li>\n<li>int *pf(const int&amp;, const int&amp;); &#x2F;&#x2F; 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&amp;参数.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>为什么有函数指针<ul>\n<li>可以通过函数指针进行函数调用</li>\n<li>而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数</li>\n<li>另外还能将函数指针作为函数参数进行传递.</li>\n<li>通过函数指针可以把函数的调用者与被调函数分开。<ul>\n<li>调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,</li>\n<li>而不需要知道具体是哪个函数被调用.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>两种方法赋值：<ul>\n<li>指针名 &#x3D; 函数名</li>\n<li>指针名 &#x3D; &amp;函数名</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"C-和其他语言的区别\"><a href=\"#C-和其他语言的区别\" class=\"headerlink\" title=\"C++和其他语言的区别\"></a>C++和其他语言的区别</h2><h3 id=\"和C的区别\"><a href=\"#和C的区别\" class=\"headerlink\" title=\"和C的区别\"></a>和C的区别</h3><ol>\n<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性</li>\n<li>C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete</li>\n<li>C++中有函数重载和引用等概念，C中没有</li>\n</ol>\n<h3 id=\"和Java的区别\"><a href=\"#和Java的区别\" class=\"headerlink\" title=\"和Java的区别\"></a>和Java的区别</h3><ol>\n<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高</li>\n<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>\n<li>C++有指针，Java没有指针，只有引用</li>\n<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>\n</ol>\n<h3 id=\"和python的区别\"><a href=\"#和python的区别\" class=\"headerlink\" title=\"和python的区别\"></a>和python的区别</h3><ol>\n<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。</li>\n<li>python可以很方便的跨平台，但是效率没有C++高</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是关于一些Cpp中一些基础概念的整理。</p>\n<h2 id=\"main函数执行前过程\"><a href=\"#main函数执行前过程\" class=\"headerlink\" title=\"main函数执行前过程\"></a>main函数执行前过程</h2><ol>\n<li>设置栈指针</li>\n<li>初始化静态static变量和global全局变量，即.data段的内容</li>\n<li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容</li>\n<li>全局对象初始化，在main之前调用构造函数</li>\n<li>将main函数的参数argc，argv等传递给main函数，真正运行main函数</li>\n</ol>\n<h2 id=\"普通函数调用过程\"><a href=\"#普通函数调用过程\" class=\"headerlink\" title=\"普通函数调用过程\"></a>普通函数调用过程</h2><ol>\n<li>设置栈指针，在栈中放入下一条指令的地址</li>\n<li>然后为形参和局部变量分配存储空间</li>\n<li>将实参的值复制给形参</li>\n<li>进行函数内操作</li>\n<li>return 语句返回时，从栈中回收形参和局部变量占用的存储空间</li>\n<li>从栈中取出返回地址</li>\n<li>跳转到该地址继续执行</li>\n</ol>\n<h2 id=\"代码编译过程\"><a href=\"#代码编译过程\" class=\"headerlink\" title=\"代码编译过程\"></a>代码编译过程</h2><p>预处理：对预处理命令进行替换等预处理操作<br>编译：代码优化和生成汇编代码<br>汇编：将汇编代码转化为机器语言<br>链接：将目标文件彼此链接起来</p>\n<h2 id=\"动态链接和静态链接\"><a href=\"#动态链接和静态链接\" class=\"headerlink\" title=\"动态链接和静态链接\"></a>动态链接和静态链接</h2><h3 id=\"静态链接\"><a href=\"#静态链接\" class=\"headerlink\" title=\"静态链接\"></a>静态链接</h3><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。<br><strong>空间浪费</strong>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本；<br><strong>更新困难</strong>：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。<br><strong>运行速度快</strong>：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>\n<h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。<br><strong>共享库</strong>：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；<br><strong>更新方便</strong>：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。<br><strong>性能损耗</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份</li>\n<li>使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂</li>\n<li><strong>静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.</strong></li>\n</ol>\n<h2 id=\"指针与引用\"><a href=\"#指针与引用\" class=\"headerlink\" title=\"指针与引用\"></a>指针与引用</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ol>\n<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量</li>\n<li>引用是一个别名，对引用的操作就是对变量的本身进行操作</li>\n</ol>\n<h3 id=\"区别-1\"><a href=\"#区别-1\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>指针可以有多级，引用只有一级 </li>\n<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 </li>\n<li>指针可以为空，引用不可以</li>\n</ol>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ol>\n<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>\n<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小;类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li>\n</ol>\n<h3 id=\"引用和指针在汇编层\"><a href=\"#引用和指针在汇编层\" class=\"headerlink\" title=\"引用和指针在汇编层\"></a>引用和指针在汇编层</h3><p>引用和指针在汇编层完全一样，引用就是指针。<br>但在开发使用过程中，引用是等效于常量指针的（指向固定的对象），意味着两者在汇编层完全相同。<br>借此可以推导一些const关键词的特性：如果在汇编层完全相同的话，这个在使用上隐晦存在的（const）其实是由编译器保证的，它通过静态检查的方式确保引用无法被修改。</p>\n<h2 id=\"声明与定义\"><a href=\"#声明与定义\" class=\"headerlink\" title=\"声明与定义\"></a>声明与定义</h2><ol>\n<li>声明是告诉编译器变量的类型和名字，不会为变量分配空间</li>\n<li>定义是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。</li>\n</ol>\n<h2 id=\"struct与class\"><a href=\"#struct与class\" class=\"headerlink\" title=\"struct与class\"></a>struct与class</h2><ol>\n<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>\n<li>struct的继承默认是public继承，而class的继承默认是private继承</li>\n<li>class可以用作模板，而struct不能</li>\n</ol>\n<h2 id=\"拷贝\"><a href=\"#拷贝\" class=\"headerlink\" title=\"拷贝\"></a>拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>将对象的指针进行简单的复制，原对象和副本指向的是相同的资源</p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址</p>\n<h3 id=\"深浅拷贝的区别\"><a href=\"#深浅拷贝的区别\" class=\"headerlink\" title=\"深浅拷贝的区别\"></a>深浅拷贝的区别</h3><p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>\n<h3 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h3><p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。用程序调用mmap()，磁盘上的数据会通过DMA被拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>\n<h2 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>\n<h3 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h3><p>友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中用friend关键字声明所有可以访问它的友元函数。</p>\n<h3 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。</p>\n<h3 id=\"友元类的注意点\"><a href=\"#友元类的注意点\" class=\"headerlink\" title=\"友元类的注意点\"></a>友元类的注意点</h3><ol>\n<li>友元关系不能被继承。 </li>\n<li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </li>\n<li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>\n</ol>\n<h2 id=\"列表成员初始化\"><a href=\"#列表成员初始化\" class=\"headerlink\" title=\"列表成员初始化\"></a>列表成员初始化</h2><ul>\n<li>赋值初始化，通过在函数体内进行赋值初始化；</li>\n<li>列表初始化，在冒号后使用初始化列表进行初始化。</li>\n</ul>\n<p>相对而言，列表成员初始化的效率会更高，列表初始化是给数据成员分配内存空间时就进行初始化, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数。</p>\n<h2 id=\"右值与移动构造\"><a href=\"#右值与移动构造\" class=\"headerlink\" title=\"右值与移动构造\"></a>右值与移动构造</h2><ul>\n<li>右值的概念: 将亡值, 不具名变量</li>\n<li>右值引用<ul>\n<li>概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.</li>\n<li>优点:<ul>\n<li>转移语意</li>\n<li>精确语意传递(参数列表分别为<strong>左值引用</strong>和<strong>右值引用</strong>形成参数重载)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>移动构造函数:<ul>\n<li>概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.</li>\n<li>实现:<ul>\n<li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</li>\n<li>也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。</li>\n<li><strong>作为参数的右值将不会再调用析构函数。</strong></li>\n<li>move语句，就是将一个左值变成一个将亡值。</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>避免了无谓的对下销毁和构造的开销</li>\n<li>当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><ul>\n<li>什么是函数指针?<ul>\n<li>函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.</li>\n</ul>\n</li>\n<li>函数指针的声明方法<ul>\n<li>int (*pf)(const int&amp;, const int&amp;); (1)</li>\n<li>pf是一个返回类型为int, 参数为两个const int&amp;的函数。<strong>注意*pf 两边的括号是必须的</strong><ul>\n<li>否则上面的定义就变成了：</li>\n<li>int *pf(const int&amp;, const int&amp;); &#x2F;&#x2F; 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&amp;参数.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>为什么有函数指针<ul>\n<li>可以通过函数指针进行函数调用</li>\n<li>而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数</li>\n<li>另外还能将函数指针作为函数参数进行传递.</li>\n<li>通过函数指针可以把函数的调用者与被调函数分开。<ul>\n<li>调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,</li>\n<li>而不需要知道具体是哪个函数被调用.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>两种方法赋值：<ul>\n<li>指针名 &#x3D; 函数名</li>\n<li>指针名 &#x3D; &amp;函数名</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"C-和其他语言的区别\"><a href=\"#C-和其他语言的区别\" class=\"headerlink\" title=\"C++和其他语言的区别\"></a>C++和其他语言的区别</h2><h3 id=\"和C的区别\"><a href=\"#和C的区别\" class=\"headerlink\" title=\"和C的区别\"></a>和C的区别</h3><ol>\n<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性</li>\n<li>C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete</li>\n<li>C++中有函数重载和引用等概念，C中没有</li>\n</ol>\n<h3 id=\"和Java的区别\"><a href=\"#和Java的区别\" class=\"headerlink\" title=\"和Java的区别\"></a>和Java的区别</h3><ol>\n<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高</li>\n<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>\n<li>C++有指针，Java没有指针，只有引用</li>\n<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>\n</ol>\n<h3 id=\"和python的区别\"><a href=\"#和python的区别\" class=\"headerlink\" title=\"和python的区别\"></a>和python的区别</h3><ol>\n<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。</li>\n<li>python可以很方便的跨平台，但是效率没有C++高</li>\n</ol>\n"},{"title":"Cpp基础知识点(三)","date":"2023-12-03T14:13:30.000Z","abstract":"Cpp中的内存模型","_content":"本文是关于一些Cpp中内存模型的整理。\n## 内存分类\n![image.png](/images/Cpp-Basics-3-1.png)\n### .text 代码区\n存放程序的二进制代码。\n### .data 数据段(静态存储区)\n存放可执行文件中已初始化的静态变量和全局变量\n### .bss\n存放程序中未初始化的全局变量，在内存中bss段全部置零\n### 堆区\n亦称动态内存分配,可能会产生内存碎片。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。\n### 栈区\n在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。\n## 堆与栈的区别\n### 速度区别\n栈快。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。\n### 管理区别\n对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。\n### 大小区别\n一般来讲在32位系统下，堆内存可以达到4G的空间,但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。\n### 碎片区别\n对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出\n## 类的内存占用\n### 空类\n1字节,在C++中空类会占1个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。\n### 含普通函数的类\n1字节,普通函数不占用类大小。\n### 含虚函数的类\n4字节,因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节。\n### 含静态成员的类\n1字节,静态成员存放在静态存储区，不占用类的大小。\n## 操作内存关键字\n### new的实现\n首先会调用malloc为对象分配内存空间，然后进行强制类型转换,然后调用对象的构造函数。\n### delete的实现\n调用对象的析构函数，然后调用free回收内存。\n### 为什么需要new/delete\n在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。\n### malloc和new的区别\nmalloc需要给定空间大小，而new只需要对象名；malloc类型不安全，new类型安全。\n### delete和delete[]的区别\n\n- delete只会调用一次析构函数，而delete[ ]会调用每个成员的析构函数。\n- 用new分配的内存用delete释放，用new[ ]分配的内存用delete[ ]释放。\n### free的实现细节\n不会被立即返还给操作系统,被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。\n## 内存泄漏\n### 概念\n动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存。\n### 原因\n\n1. 类的构造函数和析构函数中new和delete没有配套\n2. 在释放对象数组时没有使用delete[]，使用了delete\n3. 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露\n4. 没有正确的清楚清除的对象指针\n### 检测方法\n\n1. 从监视工具收集一段时间内的堆栈内存信息，观测增长趋势，来确定是否有内存泄漏\n2. 静态编译工具Beam\n3. 动态检验工具valgrind\n### 解决方法\n\n1. malloc/free要配套\n2. 使用智能指针\n3. 将基类的析构函数设为虚函数\n## 内存的结构对齐\n### 原因\n因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。\n### 规则\n\n1. 第一个成员在与结构体变量偏移量为0的地址 \n2. 对齐数=Min（编译器默认的对齐数，该成员大小），linux 中默认为4，vs 中的默认值为8。\n3. 其他成员变量要对齐到对齐数的整数倍的地址处\n## 如何在共享内存中使用容器\n问题的根源是容器内存储的是绝对地址，而不同的进程、或者相同的进程的不同的启动，都会使得共享内存映射到当前进程内的不同地址。\n解决方案是三种：\n一种是定制STL的容器内存分配器，一种是ACE提供的使用地址无关的分配方法，一种是BOOST的interprocess的实现。\n参考链接：\n[https://blog.csdn.net/fullsail/article/details/8540078](https://blog.csdn.net/fullsail/article/details/8540078)\n## 垃圾回收\n### Cpp为什么没有垃圾回收\n\n- 实现一个垃圾回收器会带来额外的空间和时间开销,需要开辟一定的空间保存指针的引用计数和对他们进行标记mark,然后需要单独开辟一个线程在空闲的时候进行free操作。\n- 垃圾回收会使得C++不适合进行很多底层的操作。\n### 如果要为Cpp设计垃圾回收\nC/C++ 中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。\n首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。\n其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量(包括函数内的静态变量)都是集中存在于 bss 段或 data段中。垃圾回收的时候，只需要扫描 bss 段, data 段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。\n","source":"_posts/Cpp-basics-3.md","raw":"---\ntitle: Cpp基础知识点(三)\ndate: 2023-12-03 22:13:30\ntags: Cpp\nabstract: Cpp中的内存模型\n---\n本文是关于一些Cpp中内存模型的整理。\n## 内存分类\n![image.png](/images/Cpp-Basics-3-1.png)\n### .text 代码区\n存放程序的二进制代码。\n### .data 数据段(静态存储区)\n存放可执行文件中已初始化的静态变量和全局变量\n### .bss\n存放程序中未初始化的全局变量，在内存中bss段全部置零\n### 堆区\n亦称动态内存分配,可能会产生内存碎片。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。\n### 栈区\n在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。\n## 堆与栈的区别\n### 速度区别\n栈快。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。\n### 管理区别\n对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。\n### 大小区别\n一般来讲在32位系统下，堆内存可以达到4G的空间,但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。\n### 碎片区别\n对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出\n## 类的内存占用\n### 空类\n1字节,在C++中空类会占1个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。\n### 含普通函数的类\n1字节,普通函数不占用类大小。\n### 含虚函数的类\n4字节,因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节。\n### 含静态成员的类\n1字节,静态成员存放在静态存储区，不占用类的大小。\n## 操作内存关键字\n### new的实现\n首先会调用malloc为对象分配内存空间，然后进行强制类型转换,然后调用对象的构造函数。\n### delete的实现\n调用对象的析构函数，然后调用free回收内存。\n### 为什么需要new/delete\n在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。\n### malloc和new的区别\nmalloc需要给定空间大小，而new只需要对象名；malloc类型不安全，new类型安全。\n### delete和delete[]的区别\n\n- delete只会调用一次析构函数，而delete[ ]会调用每个成员的析构函数。\n- 用new分配的内存用delete释放，用new[ ]分配的内存用delete[ ]释放。\n### free的实现细节\n不会被立即返还给操作系统,被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。\n## 内存泄漏\n### 概念\n动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存。\n### 原因\n\n1. 类的构造函数和析构函数中new和delete没有配套\n2. 在释放对象数组时没有使用delete[]，使用了delete\n3. 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露\n4. 没有正确的清楚清除的对象指针\n### 检测方法\n\n1. 从监视工具收集一段时间内的堆栈内存信息，观测增长趋势，来确定是否有内存泄漏\n2. 静态编译工具Beam\n3. 动态检验工具valgrind\n### 解决方法\n\n1. malloc/free要配套\n2. 使用智能指针\n3. 将基类的析构函数设为虚函数\n## 内存的结构对齐\n### 原因\n因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。\n### 规则\n\n1. 第一个成员在与结构体变量偏移量为0的地址 \n2. 对齐数=Min（编译器默认的对齐数，该成员大小），linux 中默认为4，vs 中的默认值为8。\n3. 其他成员变量要对齐到对齐数的整数倍的地址处\n## 如何在共享内存中使用容器\n问题的根源是容器内存储的是绝对地址，而不同的进程、或者相同的进程的不同的启动，都会使得共享内存映射到当前进程内的不同地址。\n解决方案是三种：\n一种是定制STL的容器内存分配器，一种是ACE提供的使用地址无关的分配方法，一种是BOOST的interprocess的实现。\n参考链接：\n[https://blog.csdn.net/fullsail/article/details/8540078](https://blog.csdn.net/fullsail/article/details/8540078)\n## 垃圾回收\n### Cpp为什么没有垃圾回收\n\n- 实现一个垃圾回收器会带来额外的空间和时间开销,需要开辟一定的空间保存指针的引用计数和对他们进行标记mark,然后需要单独开辟一个线程在空闲的时候进行free操作。\n- 垃圾回收会使得C++不适合进行很多底层的操作。\n### 如果要为Cpp设计垃圾回收\nC/C++ 中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。\n首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。\n其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量(包括函数内的静态变量)都是集中存在于 bss 段或 data段中。垃圾回收的时候，只需要扫描 bss 段, data 段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。\n","slug":"Cpp-basics-3","published":1,"updated":"2023-12-11T15:12:42.049Z","_id":"clppkl91v00030ix5gsag2hlu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是关于一些Cpp中内存模型的整理。</p>\n<h2 id=\"内存分类\"><a href=\"#内存分类\" class=\"headerlink\" title=\"内存分类\"></a>内存分类</h2><p><img src=\"/images/Cpp-Basics-3-1.png\" alt=\"image.png\"></p>\n<h3 id=\"text-代码区\"><a href=\"#text-代码区\" class=\"headerlink\" title=\".text 代码区\"></a>.text 代码区</h3><p>存放程序的二进制代码。</p>\n<h3 id=\"data-数据段-静态存储区\"><a href=\"#data-数据段-静态存储区\" class=\"headerlink\" title=\".data 数据段(静态存储区)\"></a>.data 数据段(静态存储区)</h3><p>存放可执行文件中已初始化的静态变量和全局变量</p>\n<h3 id=\"bss\"><a href=\"#bss\" class=\"headerlink\" title=\".bss\"></a>.bss</h3><p>存放程序中未初始化的全局变量，在内存中bss段全部置零</p>\n<h3 id=\"堆区\"><a href=\"#堆区\" class=\"headerlink\" title=\"堆区\"></a>堆区</h3><p>亦称动态内存分配,可能会产生内存碎片。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>\n<h3 id=\"栈区\"><a href=\"#栈区\" class=\"headerlink\" title=\"栈区\"></a>栈区</h3><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>\n<h2 id=\"堆与栈的区别\"><a href=\"#堆与栈的区别\" class=\"headerlink\" title=\"堆与栈的区别\"></a>堆与栈的区别</h2><h3 id=\"速度区别\"><a href=\"#速度区别\" class=\"headerlink\" title=\"速度区别\"></a>速度区别</h3><p>栈快。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>\n<h3 id=\"管理区别\"><a href=\"#管理区别\" class=\"headerlink\" title=\"管理区别\"></a>管理区别</h3><p>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>\n<h3 id=\"大小区别\"><a href=\"#大小区别\" class=\"headerlink\" title=\"大小区别\"></a>大小区别</h3><p>一般来讲在32位系统下，堆内存可以达到4G的空间,但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。</p>\n<h3 id=\"碎片区别\"><a href=\"#碎片区别\" class=\"headerlink\" title=\"碎片区别\"></a>碎片区别</h3><p>对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>\n<h2 id=\"类的内存占用\"><a href=\"#类的内存占用\" class=\"headerlink\" title=\"类的内存占用\"></a>类的内存占用</h2><h3 id=\"空类\"><a href=\"#空类\" class=\"headerlink\" title=\"空类\"></a>空类</h3><p>1字节,在C++中空类会占1个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。</p>\n<h3 id=\"含普通函数的类\"><a href=\"#含普通函数的类\" class=\"headerlink\" title=\"含普通函数的类\"></a>含普通函数的类</h3><p>1字节,普通函数不占用类大小。</p>\n<h3 id=\"含虚函数的类\"><a href=\"#含虚函数的类\" class=\"headerlink\" title=\"含虚函数的类\"></a>含虚函数的类</h3><p>4字节,因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节。</p>\n<h3 id=\"含静态成员的类\"><a href=\"#含静态成员的类\" class=\"headerlink\" title=\"含静态成员的类\"></a>含静态成员的类</h3><p>1字节,静态成员存放在静态存储区，不占用类的大小。</p>\n<h2 id=\"操作内存关键字\"><a href=\"#操作内存关键字\" class=\"headerlink\" title=\"操作内存关键字\"></a>操作内存关键字</h2><h3 id=\"new的实现\"><a href=\"#new的实现\" class=\"headerlink\" title=\"new的实现\"></a>new的实现</h3><p>首先会调用malloc为对象分配内存空间，然后进行强制类型转换,然后调用对象的构造函数。</p>\n<h3 id=\"delete的实现\"><a href=\"#delete的实现\" class=\"headerlink\" title=\"delete的实现\"></a>delete的实现</h3><p>调用对象的析构函数，然后调用free回收内存。</p>\n<h3 id=\"为什么需要new-delete\"><a href=\"#为什么需要new-delete\" class=\"headerlink\" title=\"为什么需要new&#x2F;delete\"></a>为什么需要new&#x2F;delete</h3><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。</p>\n<h3 id=\"malloc和new的区别\"><a href=\"#malloc和new的区别\" class=\"headerlink\" title=\"malloc和new的区别\"></a>malloc和new的区别</h3><p>malloc需要给定空间大小，而new只需要对象名；malloc类型不安全，new类型安全。</p>\n<h3 id=\"delete和delete-的区别\"><a href=\"#delete和delete-的区别\" class=\"headerlink\" title=\"delete和delete[]的区别\"></a>delete和delete[]的区别</h3><ul>\n<li>delete只会调用一次析构函数，而delete[ ]会调用每个成员的析构函数。</li>\n<li>用new分配的内存用delete释放，用new[ ]分配的内存用delete[ ]释放。</li>\n</ul>\n<h3 id=\"free的实现细节\"><a href=\"#free的实现细节\" class=\"headerlink\" title=\"free的实现细节\"></a>free的实现细节</h3><p>不会被立即返还给操作系统,被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ol>\n<li>类的构造函数和析构函数中new和delete没有配套</li>\n<li>在释放对象数组时没有使用delete[]，使用了delete</li>\n<li>没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</li>\n<li>没有正确的清楚清除的对象指针</li>\n</ol>\n<h3 id=\"检测方法\"><a href=\"#检测方法\" class=\"headerlink\" title=\"检测方法\"></a>检测方法</h3><ol>\n<li>从监视工具收集一段时间内的堆栈内存信息，观测增长趋势，来确定是否有内存泄漏</li>\n<li>静态编译工具Beam</li>\n<li>动态检验工具valgrind</li>\n</ol>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li>malloc&#x2F;free要配套</li>\n<li>使用智能指针</li>\n<li>将基类的析构函数设为虚函数</li>\n</ol>\n<h2 id=\"内存的结构对齐\"><a href=\"#内存的结构对齐\" class=\"headerlink\" title=\"内存的结构对齐\"></a>内存的结构对齐</h2><h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ol>\n<li>第一个成员在与结构体变量偏移量为0的地址 </li>\n<li>对齐数&#x3D;Min（编译器默认的对齐数，该成员大小），linux 中默认为4，vs 中的默认值为8。</li>\n<li>其他成员变量要对齐到对齐数的整数倍的地址处</li>\n</ol>\n<h2 id=\"如何在共享内存中使用容器\"><a href=\"#如何在共享内存中使用容器\" class=\"headerlink\" title=\"如何在共享内存中使用容器\"></a>如何在共享内存中使用容器</h2><p>问题的根源是容器内存储的是绝对地址，而不同的进程、或者相同的进程的不同的启动，都会使得共享内存映射到当前进程内的不同地址。<br>解决方案是三种：<br>一种是定制STL的容器内存分配器，一种是ACE提供的使用地址无关的分配方法，一种是BOOST的interprocess的实现。<br>参考链接：<br><a href=\"https://blog.csdn.net/fullsail/article/details/8540078\">https://blog.csdn.net/fullsail/article/details/8540078</a></p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h3 id=\"Cpp为什么没有垃圾回收\"><a href=\"#Cpp为什么没有垃圾回收\" class=\"headerlink\" title=\"Cpp为什么没有垃圾回收\"></a>Cpp为什么没有垃圾回收</h3><ul>\n<li>实现一个垃圾回收器会带来额外的空间和时间开销,需要开辟一定的空间保存指针的引用计数和对他们进行标记mark,然后需要单独开辟一个线程在空闲的时候进行free操作。</li>\n<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>\n</ul>\n<h3 id=\"如果要为Cpp设计垃圾回收\"><a href=\"#如果要为Cpp设计垃圾回收\" class=\"headerlink\" title=\"如果要为Cpp设计垃圾回收\"></a>如果要为Cpp设计垃圾回收</h3><p>C&#x2F;C++ 中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。<br>首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。<br>其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量(包括函数内的静态变量)都是集中存在于 bss 段或 data段中。垃圾回收的时候，只需要扫描 bss 段, data 段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是关于一些Cpp中内存模型的整理。</p>\n<h2 id=\"内存分类\"><a href=\"#内存分类\" class=\"headerlink\" title=\"内存分类\"></a>内存分类</h2><p><img src=\"/images/Cpp-Basics-3-1.png\" alt=\"image.png\"></p>\n<h3 id=\"text-代码区\"><a href=\"#text-代码区\" class=\"headerlink\" title=\".text 代码区\"></a>.text 代码区</h3><p>存放程序的二进制代码。</p>\n<h3 id=\"data-数据段-静态存储区\"><a href=\"#data-数据段-静态存储区\" class=\"headerlink\" title=\".data 数据段(静态存储区)\"></a>.data 数据段(静态存储区)</h3><p>存放可执行文件中已初始化的静态变量和全局变量</p>\n<h3 id=\"bss\"><a href=\"#bss\" class=\"headerlink\" title=\".bss\"></a>.bss</h3><p>存放程序中未初始化的全局变量，在内存中bss段全部置零</p>\n<h3 id=\"堆区\"><a href=\"#堆区\" class=\"headerlink\" title=\"堆区\"></a>堆区</h3><p>亦称动态内存分配,可能会产生内存碎片。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>\n<h3 id=\"栈区\"><a href=\"#栈区\" class=\"headerlink\" title=\"栈区\"></a>栈区</h3><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>\n<h2 id=\"堆与栈的区别\"><a href=\"#堆与栈的区别\" class=\"headerlink\" title=\"堆与栈的区别\"></a>堆与栈的区别</h2><h3 id=\"速度区别\"><a href=\"#速度区别\" class=\"headerlink\" title=\"速度区别\"></a>速度区别</h3><p>栈快。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>\n<h3 id=\"管理区别\"><a href=\"#管理区别\" class=\"headerlink\" title=\"管理区别\"></a>管理区别</h3><p>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>\n<h3 id=\"大小区别\"><a href=\"#大小区别\" class=\"headerlink\" title=\"大小区别\"></a>大小区别</h3><p>一般来讲在32位系统下，堆内存可以达到4G的空间,但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。</p>\n<h3 id=\"碎片区别\"><a href=\"#碎片区别\" class=\"headerlink\" title=\"碎片区别\"></a>碎片区别</h3><p>对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>\n<h2 id=\"类的内存占用\"><a href=\"#类的内存占用\" class=\"headerlink\" title=\"类的内存占用\"></a>类的内存占用</h2><h3 id=\"空类\"><a href=\"#空类\" class=\"headerlink\" title=\"空类\"></a>空类</h3><p>1字节,在C++中空类会占1个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。</p>\n<h3 id=\"含普通函数的类\"><a href=\"#含普通函数的类\" class=\"headerlink\" title=\"含普通函数的类\"></a>含普通函数的类</h3><p>1字节,普通函数不占用类大小。</p>\n<h3 id=\"含虚函数的类\"><a href=\"#含虚函数的类\" class=\"headerlink\" title=\"含虚函数的类\"></a>含虚函数的类</h3><p>4字节,因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节。</p>\n<h3 id=\"含静态成员的类\"><a href=\"#含静态成员的类\" class=\"headerlink\" title=\"含静态成员的类\"></a>含静态成员的类</h3><p>1字节,静态成员存放在静态存储区，不占用类的大小。</p>\n<h2 id=\"操作内存关键字\"><a href=\"#操作内存关键字\" class=\"headerlink\" title=\"操作内存关键字\"></a>操作内存关键字</h2><h3 id=\"new的实现\"><a href=\"#new的实现\" class=\"headerlink\" title=\"new的实现\"></a>new的实现</h3><p>首先会调用malloc为对象分配内存空间，然后进行强制类型转换,然后调用对象的构造函数。</p>\n<h3 id=\"delete的实现\"><a href=\"#delete的实现\" class=\"headerlink\" title=\"delete的实现\"></a>delete的实现</h3><p>调用对象的析构函数，然后调用free回收内存。</p>\n<h3 id=\"为什么需要new-delete\"><a href=\"#为什么需要new-delete\" class=\"headerlink\" title=\"为什么需要new&#x2F;delete\"></a>为什么需要new&#x2F;delete</h3><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。</p>\n<h3 id=\"malloc和new的区别\"><a href=\"#malloc和new的区别\" class=\"headerlink\" title=\"malloc和new的区别\"></a>malloc和new的区别</h3><p>malloc需要给定空间大小，而new只需要对象名；malloc类型不安全，new类型安全。</p>\n<h3 id=\"delete和delete-的区别\"><a href=\"#delete和delete-的区别\" class=\"headerlink\" title=\"delete和delete[]的区别\"></a>delete和delete[]的区别</h3><ul>\n<li>delete只会调用一次析构函数，而delete[ ]会调用每个成员的析构函数。</li>\n<li>用new分配的内存用delete释放，用new[ ]分配的内存用delete[ ]释放。</li>\n</ul>\n<h3 id=\"free的实现细节\"><a href=\"#free的实现细节\" class=\"headerlink\" title=\"free的实现细节\"></a>free的实现细节</h3><p>不会被立即返还给操作系统,被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ol>\n<li>类的构造函数和析构函数中new和delete没有配套</li>\n<li>在释放对象数组时没有使用delete[]，使用了delete</li>\n<li>没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</li>\n<li>没有正确的清楚清除的对象指针</li>\n</ol>\n<h3 id=\"检测方法\"><a href=\"#检测方法\" class=\"headerlink\" title=\"检测方法\"></a>检测方法</h3><ol>\n<li>从监视工具收集一段时间内的堆栈内存信息，观测增长趋势，来确定是否有内存泄漏</li>\n<li>静态编译工具Beam</li>\n<li>动态检验工具valgrind</li>\n</ol>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li>malloc&#x2F;free要配套</li>\n<li>使用智能指针</li>\n<li>将基类的析构函数设为虚函数</li>\n</ol>\n<h2 id=\"内存的结构对齐\"><a href=\"#内存的结构对齐\" class=\"headerlink\" title=\"内存的结构对齐\"></a>内存的结构对齐</h2><h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ol>\n<li>第一个成员在与结构体变量偏移量为0的地址 </li>\n<li>对齐数&#x3D;Min（编译器默认的对齐数，该成员大小），linux 中默认为4，vs 中的默认值为8。</li>\n<li>其他成员变量要对齐到对齐数的整数倍的地址处</li>\n</ol>\n<h2 id=\"如何在共享内存中使用容器\"><a href=\"#如何在共享内存中使用容器\" class=\"headerlink\" title=\"如何在共享内存中使用容器\"></a>如何在共享内存中使用容器</h2><p>问题的根源是容器内存储的是绝对地址，而不同的进程、或者相同的进程的不同的启动，都会使得共享内存映射到当前进程内的不同地址。<br>解决方案是三种：<br>一种是定制STL的容器内存分配器，一种是ACE提供的使用地址无关的分配方法，一种是BOOST的interprocess的实现。<br>参考链接：<br><a href=\"https://blog.csdn.net/fullsail/article/details/8540078\">https://blog.csdn.net/fullsail/article/details/8540078</a></p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h3 id=\"Cpp为什么没有垃圾回收\"><a href=\"#Cpp为什么没有垃圾回收\" class=\"headerlink\" title=\"Cpp为什么没有垃圾回收\"></a>Cpp为什么没有垃圾回收</h3><ul>\n<li>实现一个垃圾回收器会带来额外的空间和时间开销,需要开辟一定的空间保存指针的引用计数和对他们进行标记mark,然后需要单独开辟一个线程在空闲的时候进行free操作。</li>\n<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>\n</ul>\n<h3 id=\"如果要为Cpp设计垃圾回收\"><a href=\"#如果要为Cpp设计垃圾回收\" class=\"headerlink\" title=\"如果要为Cpp设计垃圾回收\"></a>如果要为Cpp设计垃圾回收</h3><p>C&#x2F;C++ 中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。<br>首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。<br>其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量(包括函数内的静态变量)都是集中存在于 bss 段或 data段中。垃圾回收的时候，只需要扫描 bss 段, data 段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。</p>\n"},{"title":"Cpp基础知识点(四)","date":"2023-12-03T14:13:35.000Z","abstract":"Cpp面向对象的基础知识","_content":"本文是关于一些Cpp中面向对象的基础知识整理。\n## 面向对象特性\n### 封装\n封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public。\n### 继承\n继承使得子类可以复用父类的成员和方法，实现了代码重用。\n### 多态\n多态是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。\n## 基类必须定义\n因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类仅有声明是不够的，必须有定义。\n## 构造函数\n### 默认构造函数\n当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。\n### 重载构造函数\n称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。\n### 拷贝构造函数\n在发生对象复制的时候调用的。\n#### 拷贝构造函数的调用\n\n1. 对象以值传递的方式传入函数参数\n```java\n void func(Dog dog){};\n```\n\n2. 对象以值传递的方式从函数返回\n```java\nDog func(){ Dog d; return d;} \n```\n\n3. 对象需要通过另外一个对象进行初始化\n## 绑定方式\n### 动态绑定\n就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。\n### 静态绑定\n就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。\n## 多态实现\n### 编译时多态\n函数重载和模板\n### 运行时多态\n虚函数\n## 多态的实现：模板\n### 函数模板的实现\n编译器从函数模板通过具体类型产生不同的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。\n### 类模板的优点\n\n1. 它是类型无关的，具有可复用性\n2. 它是平台无关的，具有可移植性\n3. 它在编译时而不是运行时检查数据类型，保证了类型安全\n## 多态的实现：函数重载\n### 重载\n重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。\n### 重写\n重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。\n## 多态的实现：虚函数\n### 虚函数\n在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。\n### 纯虚函数\n是只有声明没有实现的虚函数，是对子类的约束，是接口继承;包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。\n### 纯虚函数的使用场景\n当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。\n### 虚函数指针\n如果类中有virtual关键字,则会有虚函数指针,指向虚函数表。\n### 虚函数表\n虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址,一个类的所有实例都共享同一张虚函数表。\n### 多继承与多重继承\n多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前，多重继承的情况下越是祖先的父类的虚函数更靠前。\n#### 多继承\n\n- 多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承。\n- 在多继承中，任何父类的指针都可以指向子类的对象，在实例化子类时，先根据继承的顺序依次调用父类的构造函数，然后再调用该子类自己的构造函数。\n- 用delete销毁该基类对象时，如果该基类的析构函数不是虚析构函数，且该基类的继承顺序在第一个，delete 父类的时候只会调用父类Worker的析构函数，系统不会出错，但是如果继承的时候顺序不是在第一位，如果父类的析构函数是虚析构函数，那么销毁的时候会先调用子类的析构函数再调用所有父类的析构函数，注意，此时，子类的父类的析构函数都会被调用。\n#### 多重继承\n\n- 多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承。\n- 当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。\n- 无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。\n### 编译器处理虚函数\n如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。\n### 构造为什么不能是虚函数\n\n1. 因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等。\n2. 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。\n### 析构为什么可以是虚函数\n当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。\n### 构造或析构中调用虚函数\n这两个操作都不提倡，因为操作结果不可以预料。\n\n- 在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。\n- 在析构函数中调用虚函数，此时调用的是子类的函数实现方式，但是此时子类的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。\n### 构造函数和析构函数能否抛出异常\n\n- 构造函数异常\n   - 后果:\n      - **(原因):**C++拒绝为**没有完成构造函数的对象**调用**析构函数**，原因是避免开销\n      - 构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏\n      - 例如: 在对象b 的构造函数中发生异常，对象b 的析构函数不会被调用。**因此会造成内存泄漏**。\n   - 解决方案:\n      - 使用**智慧指针**来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.\n      - **一般建议不要在构造函数里做过多的资源分配。**\n- 析构函数异常\n   - 后果:\n      - 在异常传递的**堆栈辗转展开**的过程中, 如果发生析构异常, C++会调用terminate终止程序\n      - 如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。\n   - 解决方法：\n      - 如果异常不可避免，则应在析构函数内捕获，而不应当抛出。\n      - 在析构函数中使用try-catch块屏蔽所有异常。\n   - 附加说明:\n      - **(后果1):** 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)\n### 类函数是否可以同时template和virtual\nC++的编译与链接模型是\"分离\"的，C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知，一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。但是，虚函数利用了虚函数表，虚函数表的内存布局需要在这个类编译完成的时候就被完全确定。\n","source":"_posts/Cpp-basics-4.md","raw":"---\ntitle: Cpp基础知识点(四)\ndate: 2023-12-03 22:13:35\ntags: Cpp\nabstract: Cpp面向对象的基础知识\n---\n本文是关于一些Cpp中面向对象的基础知识整理。\n## 面向对象特性\n### 封装\n封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public。\n### 继承\n继承使得子类可以复用父类的成员和方法，实现了代码重用。\n### 多态\n多态是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。\n## 基类必须定义\n因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类仅有声明是不够的，必须有定义。\n## 构造函数\n### 默认构造函数\n当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。\n### 重载构造函数\n称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。\n### 拷贝构造函数\n在发生对象复制的时候调用的。\n#### 拷贝构造函数的调用\n\n1. 对象以值传递的方式传入函数参数\n```java\n void func(Dog dog){};\n```\n\n2. 对象以值传递的方式从函数返回\n```java\nDog func(){ Dog d; return d;} \n```\n\n3. 对象需要通过另外一个对象进行初始化\n## 绑定方式\n### 动态绑定\n就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。\n### 静态绑定\n就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。\n## 多态实现\n### 编译时多态\n函数重载和模板\n### 运行时多态\n虚函数\n## 多态的实现：模板\n### 函数模板的实现\n编译器从函数模板通过具体类型产生不同的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。\n### 类模板的优点\n\n1. 它是类型无关的，具有可复用性\n2. 它是平台无关的，具有可移植性\n3. 它在编译时而不是运行时检查数据类型，保证了类型安全\n## 多态的实现：函数重载\n### 重载\n重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。\n### 重写\n重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。\n## 多态的实现：虚函数\n### 虚函数\n在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。\n### 纯虚函数\n是只有声明没有实现的虚函数，是对子类的约束，是接口继承;包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。\n### 纯虚函数的使用场景\n当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。\n### 虚函数指针\n如果类中有virtual关键字,则会有虚函数指针,指向虚函数表。\n### 虚函数表\n虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址,一个类的所有实例都共享同一张虚函数表。\n### 多继承与多重继承\n多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前，多重继承的情况下越是祖先的父类的虚函数更靠前。\n#### 多继承\n\n- 多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承。\n- 在多继承中，任何父类的指针都可以指向子类的对象，在实例化子类时，先根据继承的顺序依次调用父类的构造函数，然后再调用该子类自己的构造函数。\n- 用delete销毁该基类对象时，如果该基类的析构函数不是虚析构函数，且该基类的继承顺序在第一个，delete 父类的时候只会调用父类Worker的析构函数，系统不会出错，但是如果继承的时候顺序不是在第一位，如果父类的析构函数是虚析构函数，那么销毁的时候会先调用子类的析构函数再调用所有父类的析构函数，注意，此时，子类的父类的析构函数都会被调用。\n#### 多重继承\n\n- 多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承。\n- 当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。\n- 无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。\n### 编译器处理虚函数\n如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。\n### 构造为什么不能是虚函数\n\n1. 因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等。\n2. 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。\n### 析构为什么可以是虚函数\n当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。\n### 构造或析构中调用虚函数\n这两个操作都不提倡，因为操作结果不可以预料。\n\n- 在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。\n- 在析构函数中调用虚函数，此时调用的是子类的函数实现方式，但是此时子类的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。\n### 构造函数和析构函数能否抛出异常\n\n- 构造函数异常\n   - 后果:\n      - **(原因):**C++拒绝为**没有完成构造函数的对象**调用**析构函数**，原因是避免开销\n      - 构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏\n      - 例如: 在对象b 的构造函数中发生异常，对象b 的析构函数不会被调用。**因此会造成内存泄漏**。\n   - 解决方案:\n      - 使用**智慧指针**来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.\n      - **一般建议不要在构造函数里做过多的资源分配。**\n- 析构函数异常\n   - 后果:\n      - 在异常传递的**堆栈辗转展开**的过程中, 如果发生析构异常, C++会调用terminate终止程序\n      - 如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。\n   - 解决方法：\n      - 如果异常不可避免，则应在析构函数内捕获，而不应当抛出。\n      - 在析构函数中使用try-catch块屏蔽所有异常。\n   - 附加说明:\n      - **(后果1):** 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)\n### 类函数是否可以同时template和virtual\nC++的编译与链接模型是\"分离\"的，C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知，一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。但是，虚函数利用了虚函数表，虚函数表的内存布局需要在这个类编译完成的时候就被完全确定。\n","slug":"Cpp-basics-4","published":1,"updated":"2023-12-11T15:12:51.509Z","_id":"clppkl91x00040ix5bqqpcgw6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是关于一些Cpp中面向对象的基础知识整理。</p>\n<h2 id=\"面向对象特性\"><a href=\"#面向对象特性\" class=\"headerlink\" title=\"面向对象特性\"></a>面向对象特性</h2><h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承使得子类可以复用父类的成员和方法，实现了代码重用。</p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</p>\n<h2 id=\"基类必须定义\"><a href=\"#基类必须定义\" class=\"headerlink\" title=\"基类必须定义\"></a>基类必须定义</h2><p>因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类仅有声明是不够的，必须有定义。</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><h3 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h3><p>当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</p>\n<h3 id=\"重载构造函数\"><a href=\"#重载构造函数\" class=\"headerlink\" title=\"重载构造函数\"></a>重载构造函数</h3><p>称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</p>\n<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>在发生对象复制的时候调用的。</p>\n<h4 id=\"拷贝构造函数的调用\"><a href=\"#拷贝构造函数的调用\" class=\"headerlink\" title=\"拷贝构造函数的调用\"></a>拷贝构造函数的调用</h4><ol>\n<li><p>对象以值传递的方式传入函数参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(Dog dog)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象以值传递的方式从函数返回</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog <span class=\"title function_\">func</span><span class=\"params\">()</span>&#123; Dog d; <span class=\"keyword\">return</span> d;&#125; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象需要通过另外一个对象进行初始化</p>\n</li>\n</ol>\n<h2 id=\"绑定方式\"><a href=\"#绑定方式\" class=\"headerlink\" title=\"绑定方式\"></a>绑定方式</h2><h3 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h3><p>就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>\n<h3 id=\"静态绑定\"><a href=\"#静态绑定\" class=\"headerlink\" title=\"静态绑定\"></a>静态绑定</h3><p>就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>\n<h2 id=\"多态实现\"><a href=\"#多态实现\" class=\"headerlink\" title=\"多态实现\"></a>多态实现</h2><h3 id=\"编译时多态\"><a href=\"#编译时多态\" class=\"headerlink\" title=\"编译时多态\"></a>编译时多态</h3><p>函数重载和模板</p>\n<h3 id=\"运行时多态\"><a href=\"#运行时多态\" class=\"headerlink\" title=\"运行时多态\"></a>运行时多态</h3><p>虚函数</p>\n<h2 id=\"多态的实现：模板\"><a href=\"#多态的实现：模板\" class=\"headerlink\" title=\"多态的实现：模板\"></a>多态的实现：模板</h2><h3 id=\"函数模板的实现\"><a href=\"#函数模板的实现\" class=\"headerlink\" title=\"函数模板的实现\"></a>函数模板的实现</h3><p>编译器从函数模板通过具体类型产生不同的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。</p>\n<h3 id=\"类模板的优点\"><a href=\"#类模板的优点\" class=\"headerlink\" title=\"类模板的优点\"></a>类模板的优点</h3><ol>\n<li>它是类型无关的，具有可复用性</li>\n<li>它是平台无关的，具有可移植性</li>\n<li>它在编译时而不是运行时检查数据类型，保证了类型安全</li>\n</ol>\n<h2 id=\"多态的实现：函数重载\"><a href=\"#多态的实现：函数重载\" class=\"headerlink\" title=\"多态的实现：函数重载\"></a>多态的实现：函数重载</h2><h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3><p>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</p>\n<h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h3><p>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。</p>\n<h2 id=\"多态的实现：虚函数\"><a href=\"#多态的实现：虚函数\" class=\"headerlink\" title=\"多态的实现：虚函数\"></a>多态的实现：虚函数</h2><h3 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h3><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>\n<h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>是只有声明没有实现的虚函数，是对子类的约束，是接口继承;包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。</p>\n<h3 id=\"纯虚函数的使用场景\"><a href=\"#纯虚函数的使用场景\" class=\"headerlink\" title=\"纯虚函数的使用场景\"></a>纯虚函数的使用场景</h3><p>当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>\n<h3 id=\"虚函数指针\"><a href=\"#虚函数指针\" class=\"headerlink\" title=\"虚函数指针\"></a>虚函数指针</h3><p>如果类中有virtual关键字,则会有虚函数指针,指向虚函数表。</p>\n<h3 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h3><p>虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址,一个类的所有实例都共享同一张虚函数表。</p>\n<h3 id=\"多继承与多重继承\"><a href=\"#多继承与多重继承\" class=\"headerlink\" title=\"多继承与多重继承\"></a>多继承与多重继承</h3><p>多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前，多重继承的情况下越是祖先的父类的虚函数更靠前。</p>\n<h4 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h4><ul>\n<li>多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承。</li>\n<li>在多继承中，任何父类的指针都可以指向子类的对象，在实例化子类时，先根据继承的顺序依次调用父类的构造函数，然后再调用该子类自己的构造函数。</li>\n<li>用delete销毁该基类对象时，如果该基类的析构函数不是虚析构函数，且该基类的继承顺序在第一个，delete 父类的时候只会调用父类Worker的析构函数，系统不会出错，但是如果继承的时候顺序不是在第一位，如果父类的析构函数是虚析构函数，那么销毁的时候会先调用子类的析构函数再调用所有父类的析构函数，注意，此时，子类的父类的析构函数都会被调用。</li>\n</ul>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><ul>\n<li>多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承。</li>\n<li>当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。</li>\n<li>无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。</li>\n</ul>\n<h3 id=\"编译器处理虚函数\"><a href=\"#编译器处理虚函数\" class=\"headerlink\" title=\"编译器处理虚函数\"></a>编译器处理虚函数</h3><p>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。</p>\n<h3 id=\"构造为什么不能是虚函数\"><a href=\"#构造为什么不能是虚函数\" class=\"headerlink\" title=\"构造为什么不能是虚函数\"></a>构造为什么不能是虚函数</h3><ol>\n<li>因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等。</li>\n<li>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。</li>\n</ol>\n<h3 id=\"析构为什么可以是虚函数\"><a href=\"#析构为什么可以是虚函数\" class=\"headerlink\" title=\"析构为什么可以是虚函数\"></a>析构为什么可以是虚函数</h3><p>当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>\n<h3 id=\"构造或析构中调用虚函数\"><a href=\"#构造或析构中调用虚函数\" class=\"headerlink\" title=\"构造或析构中调用虚函数\"></a>构造或析构中调用虚函数</h3><p>这两个操作都不提倡，因为操作结果不可以预料。</p>\n<ul>\n<li>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</li>\n<li>在析构函数中调用虚函数，此时调用的是子类的函数实现方式，但是此时子类的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li>\n</ul>\n<h3 id=\"构造函数和析构函数能否抛出异常\"><a href=\"#构造函数和析构函数能否抛出异常\" class=\"headerlink\" title=\"构造函数和析构函数能否抛出异常\"></a>构造函数和析构函数能否抛出异常</h3><ul>\n<li>构造函数异常<ul>\n<li>后果:<ul>\n<li><strong>(原因):<strong>C++拒绝为</strong>没有完成构造函数的对象</strong>调用<strong>析构函数</strong>，原因是避免开销</li>\n<li>构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏</li>\n<li>例如: 在对象b 的构造函数中发生异常，对象b 的析构函数不会被调用。<strong>因此会造成内存泄漏</strong>。</li>\n</ul>\n</li>\n<li>解决方案:<ul>\n<li>使用<strong>智慧指针</strong>来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.</li>\n<li><strong>一般建议不要在构造函数里做过多的资源分配。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>析构函数异常<ul>\n<li>后果:<ul>\n<li>在异常传递的<strong>堆栈辗转展开</strong>的过程中, 如果发生析构异常, C++会调用terminate终止程序</li>\n<li>如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。</li>\n</ul>\n</li>\n<li>解决方法：<ul>\n<li>如果异常不可避免，则应在析构函数内捕获，而不应当抛出。</li>\n<li>在析构函数中使用try-catch块屏蔽所有异常。</li>\n</ul>\n</li>\n<li>附加说明:<ul>\n<li><strong>(后果1):</strong> 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类函数是否可以同时template和virtual\"><a href=\"#类函数是否可以同时template和virtual\" class=\"headerlink\" title=\"类函数是否可以同时template和virtual\"></a>类函数是否可以同时template和virtual</h3><p>C++的编译与链接模型是”分离”的，C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知，一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。但是，虚函数利用了虚函数表，虚函数表的内存布局需要在这个类编译完成的时候就被完全确定。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是关于一些Cpp中面向对象的基础知识整理。</p>\n<h2 id=\"面向对象特性\"><a href=\"#面向对象特性\" class=\"headerlink\" title=\"面向对象特性\"></a>面向对象特性</h2><h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承使得子类可以复用父类的成员和方法，实现了代码重用。</p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</p>\n<h2 id=\"基类必须定义\"><a href=\"#基类必须定义\" class=\"headerlink\" title=\"基类必须定义\"></a>基类必须定义</h2><p>因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类仅有声明是不够的，必须有定义。</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><h3 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h3><p>当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</p>\n<h3 id=\"重载构造函数\"><a href=\"#重载构造函数\" class=\"headerlink\" title=\"重载构造函数\"></a>重载构造函数</h3><p>称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</p>\n<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>在发生对象复制的时候调用的。</p>\n<h4 id=\"拷贝构造函数的调用\"><a href=\"#拷贝构造函数的调用\" class=\"headerlink\" title=\"拷贝构造函数的调用\"></a>拷贝构造函数的调用</h4><ol>\n<li><p>对象以值传递的方式传入函数参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(Dog dog)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象以值传递的方式从函数返回</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog <span class=\"title function_\">func</span><span class=\"params\">()</span>&#123; Dog d; <span class=\"keyword\">return</span> d;&#125; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象需要通过另外一个对象进行初始化</p>\n</li>\n</ol>\n<h2 id=\"绑定方式\"><a href=\"#绑定方式\" class=\"headerlink\" title=\"绑定方式\"></a>绑定方式</h2><h3 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h3><p>就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>\n<h3 id=\"静态绑定\"><a href=\"#静态绑定\" class=\"headerlink\" title=\"静态绑定\"></a>静态绑定</h3><p>就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>\n<h2 id=\"多态实现\"><a href=\"#多态实现\" class=\"headerlink\" title=\"多态实现\"></a>多态实现</h2><h3 id=\"编译时多态\"><a href=\"#编译时多态\" class=\"headerlink\" title=\"编译时多态\"></a>编译时多态</h3><p>函数重载和模板</p>\n<h3 id=\"运行时多态\"><a href=\"#运行时多态\" class=\"headerlink\" title=\"运行时多态\"></a>运行时多态</h3><p>虚函数</p>\n<h2 id=\"多态的实现：模板\"><a href=\"#多态的实现：模板\" class=\"headerlink\" title=\"多态的实现：模板\"></a>多态的实现：模板</h2><h3 id=\"函数模板的实现\"><a href=\"#函数模板的实现\" class=\"headerlink\" title=\"函数模板的实现\"></a>函数模板的实现</h3><p>编译器从函数模板通过具体类型产生不同的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。</p>\n<h3 id=\"类模板的优点\"><a href=\"#类模板的优点\" class=\"headerlink\" title=\"类模板的优点\"></a>类模板的优点</h3><ol>\n<li>它是类型无关的，具有可复用性</li>\n<li>它是平台无关的，具有可移植性</li>\n<li>它在编译时而不是运行时检查数据类型，保证了类型安全</li>\n</ol>\n<h2 id=\"多态的实现：函数重载\"><a href=\"#多态的实现：函数重载\" class=\"headerlink\" title=\"多态的实现：函数重载\"></a>多态的实现：函数重载</h2><h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3><p>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</p>\n<h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h3><p>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。</p>\n<h2 id=\"多态的实现：虚函数\"><a href=\"#多态的实现：虚函数\" class=\"headerlink\" title=\"多态的实现：虚函数\"></a>多态的实现：虚函数</h2><h3 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h3><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>\n<h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>是只有声明没有实现的虚函数，是对子类的约束，是接口继承;包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。</p>\n<h3 id=\"纯虚函数的使用场景\"><a href=\"#纯虚函数的使用场景\" class=\"headerlink\" title=\"纯虚函数的使用场景\"></a>纯虚函数的使用场景</h3><p>当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>\n<h3 id=\"虚函数指针\"><a href=\"#虚函数指针\" class=\"headerlink\" title=\"虚函数指针\"></a>虚函数指针</h3><p>如果类中有virtual关键字,则会有虚函数指针,指向虚函数表。</p>\n<h3 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h3><p>虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址,一个类的所有实例都共享同一张虚函数表。</p>\n<h3 id=\"多继承与多重继承\"><a href=\"#多继承与多重继承\" class=\"headerlink\" title=\"多继承与多重继承\"></a>多继承与多重继承</h3><p>多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前，多重继承的情况下越是祖先的父类的虚函数更靠前。</p>\n<h4 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h4><ul>\n<li>多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承。</li>\n<li>在多继承中，任何父类的指针都可以指向子类的对象，在实例化子类时，先根据继承的顺序依次调用父类的构造函数，然后再调用该子类自己的构造函数。</li>\n<li>用delete销毁该基类对象时，如果该基类的析构函数不是虚析构函数，且该基类的继承顺序在第一个，delete 父类的时候只会调用父类Worker的析构函数，系统不会出错，但是如果继承的时候顺序不是在第一位，如果父类的析构函数是虚析构函数，那么销毁的时候会先调用子类的析构函数再调用所有父类的析构函数，注意，此时，子类的父类的析构函数都会被调用。</li>\n</ul>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><ul>\n<li>多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承。</li>\n<li>当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。</li>\n<li>无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。</li>\n</ul>\n<h3 id=\"编译器处理虚函数\"><a href=\"#编译器处理虚函数\" class=\"headerlink\" title=\"编译器处理虚函数\"></a>编译器处理虚函数</h3><p>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。</p>\n<h3 id=\"构造为什么不能是虚函数\"><a href=\"#构造为什么不能是虚函数\" class=\"headerlink\" title=\"构造为什么不能是虚函数\"></a>构造为什么不能是虚函数</h3><ol>\n<li>因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等。</li>\n<li>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。</li>\n</ol>\n<h3 id=\"析构为什么可以是虚函数\"><a href=\"#析构为什么可以是虚函数\" class=\"headerlink\" title=\"析构为什么可以是虚函数\"></a>析构为什么可以是虚函数</h3><p>当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>\n<h3 id=\"构造或析构中调用虚函数\"><a href=\"#构造或析构中调用虚函数\" class=\"headerlink\" title=\"构造或析构中调用虚函数\"></a>构造或析构中调用虚函数</h3><p>这两个操作都不提倡，因为操作结果不可以预料。</p>\n<ul>\n<li>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</li>\n<li>在析构函数中调用虚函数，此时调用的是子类的函数实现方式，但是此时子类的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li>\n</ul>\n<h3 id=\"构造函数和析构函数能否抛出异常\"><a href=\"#构造函数和析构函数能否抛出异常\" class=\"headerlink\" title=\"构造函数和析构函数能否抛出异常\"></a>构造函数和析构函数能否抛出异常</h3><ul>\n<li>构造函数异常<ul>\n<li>后果:<ul>\n<li><strong>(原因):<strong>C++拒绝为</strong>没有完成构造函数的对象</strong>调用<strong>析构函数</strong>，原因是避免开销</li>\n<li>构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏</li>\n<li>例如: 在对象b 的构造函数中发生异常，对象b 的析构函数不会被调用。<strong>因此会造成内存泄漏</strong>。</li>\n</ul>\n</li>\n<li>解决方案:<ul>\n<li>使用<strong>智慧指针</strong>来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.</li>\n<li><strong>一般建议不要在构造函数里做过多的资源分配。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>析构函数异常<ul>\n<li>后果:<ul>\n<li>在异常传递的<strong>堆栈辗转展开</strong>的过程中, 如果发生析构异常, C++会调用terminate终止程序</li>\n<li>如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。</li>\n</ul>\n</li>\n<li>解决方法：<ul>\n<li>如果异常不可避免，则应在析构函数内捕获，而不应当抛出。</li>\n<li>在析构函数中使用try-catch块屏蔽所有异常。</li>\n</ul>\n</li>\n<li>附加说明:<ul>\n<li><strong>(后果1):</strong> 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类函数是否可以同时template和virtual\"><a href=\"#类函数是否可以同时template和virtual\" class=\"headerlink\" title=\"类函数是否可以同时template和virtual\"></a>类函数是否可以同时template和virtual</h3><p>C++的编译与链接模型是”分离”的，C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知，一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。但是，虚函数利用了虚函数表，虚函数表的内存布局需要在这个类编译完成的时候就被完全确定。</p>\n"},{"title":"Cpp基础知识点(五)","date":"2023-12-03T15:08:46.000Z","abstract":"Cpp中的STL的基础知识","_content":"本文是关于一些Cpp中STL的基础知识整理。\n## STL组件\n### 容器\n各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。\n### 算法\n各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)。\n### 迭代器\n容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。\n### 仿函数\n行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。\n### 配接器\n一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。\n### 配置器\n负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。\n## STL中的哈希\n它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，默认的桶大小是10。\n### 哈希冲突解决\n线性探查；二次平方探查；二次哈希法；开链法；建立公共溢出区。\n## STL中的map\n### map\n底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(<)。\n### unordered_map\n使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。\n## STL中的vector\n### 概念\nSTL中的vector是封装了动态数组的顺序容器。\n### 扩充规则\n每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。\n### 缺陷\nvector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。\n### 与list的对比 \nlist是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。\n### vector的迭代器失效\n\n- 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效。\n- 当vector在插入的时候，end迭代器肯定会失效。\n- 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。\n## STL中的string\n### 概念\nstring继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。\n### 扩充规则\nstring可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。\n## STL中的sort实现\nSTL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。\n## set/map/vector插入复杂度\n\n- set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。\n- unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)。\n- vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝。\n","source":"_posts/Cpp-basics-5.md","raw":"---\ntitle: Cpp基础知识点(五)\ndate: 2023-12-03 23:08:46\ntags: Cpp\nabstract: Cpp中的STL的基础知识\n---\n本文是关于一些Cpp中STL的基础知识整理。\n## STL组件\n### 容器\n各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。\n### 算法\n各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)。\n### 迭代器\n容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。\n### 仿函数\n行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。\n### 配接器\n一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。\n### 配置器\n负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。\n## STL中的哈希\n它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，默认的桶大小是10。\n### 哈希冲突解决\n线性探查；二次平方探查；二次哈希法；开链法；建立公共溢出区。\n## STL中的map\n### map\n底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(<)。\n### unordered_map\n使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。\n## STL中的vector\n### 概念\nSTL中的vector是封装了动态数组的顺序容器。\n### 扩充规则\n每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。\n### 缺陷\nvector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。\n### 与list的对比 \nlist是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。\n### vector的迭代器失效\n\n- 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效。\n- 当vector在插入的时候，end迭代器肯定会失效。\n- 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。\n## STL中的string\n### 概念\nstring继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。\n### 扩充规则\nstring可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。\n## STL中的sort实现\nSTL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。\n## set/map/vector插入复杂度\n\n- set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。\n- unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)。\n- vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝。\n","slug":"Cpp-basics-5","published":1,"updated":"2023-12-11T15:13:00.477Z","_id":"clppmemsp000050x5h6ix033c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是关于一些Cpp中STL的基础知识整理。</p>\n<h2 id=\"STL组件\"><a href=\"#STL组件\" class=\"headerlink\" title=\"STL组件\"></a>STL组件</h2><h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。</p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator-&gt;、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p>\n<h3 id=\"仿函数\"><a href=\"#仿函数\" class=\"headerlink\" title=\"仿函数\"></a>仿函数</h3><p>行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。</p>\n<h3 id=\"配接器\"><a href=\"#配接器\" class=\"headerlink\" title=\"配接器\"></a>配接器</h3><p>一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。</p>\n<h3 id=\"配置器\"><a href=\"#配置器\" class=\"headerlink\" title=\"配置器\"></a>配置器</h3><p>负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</p>\n<h2 id=\"STL中的哈希\"><a href=\"#STL中的哈希\" class=\"headerlink\" title=\"STL中的哈希\"></a>STL中的哈希</h2><p>它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，默认的桶大小是10。</p>\n<h3 id=\"哈希冲突解决\"><a href=\"#哈希冲突解决\" class=\"headerlink\" title=\"哈希冲突解决\"></a>哈希冲突解决</h3><p>线性探查；二次平方探查；二次哈希法；开链法；建立公共溢出区。</p>\n<h2 id=\"STL中的map\"><a href=\"#STL中的map\" class=\"headerlink\" title=\"STL中的map\"></a>STL中的map</h2><h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</p>\n<h3 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h3><p>使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。</p>\n<h2 id=\"STL中的vector\"><a href=\"#STL中的vector\" class=\"headerlink\" title=\"STL中的vector\"></a>STL中的vector</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>STL中的vector是封装了动态数组的顺序容器。</p>\n<h3 id=\"扩充规则\"><a href=\"#扩充规则\" class=\"headerlink\" title=\"扩充规则\"></a>扩充规则</h3><p>每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p>\n<h3 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h3><p>vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。</p>\n<h3 id=\"与list的对比\"><a href=\"#与list的对比\" class=\"headerlink\" title=\"与list的对比\"></a>与list的对比</h3><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>\n<h3 id=\"vector的迭代器失效\"><a href=\"#vector的迭代器失效\" class=\"headerlink\" title=\"vector的迭代器失效\"></a>vector的迭代器失效</h3><ul>\n<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效。</li>\n<li>当vector在插入的时候，end迭代器肯定会失效。</li>\n<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>\n</ul>\n<h2 id=\"STL中的string\"><a href=\"#STL中的string\" class=\"headerlink\" title=\"STL中的string\"></a>STL中的string</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>string继承自basic_string,其实是对char<em>进行了封装，封装的string包含了char</em>数组，容量，长度等等属性。</p>\n<h3 id=\"扩充规则-1\"><a href=\"#扩充规则-1\" class=\"headerlink\" title=\"扩充规则\"></a>扩充规则</h3><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</p>\n<h2 id=\"STL中的sort实现\"><a href=\"#STL中的sort实现\" class=\"headerlink\" title=\"STL中的sort实现\"></a>STL中的sort实现</h2><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>\n<h2 id=\"set-map-vector插入复杂度\"><a href=\"#set-map-vector插入复杂度\" class=\"headerlink\" title=\"set&#x2F;map&#x2F;vector插入复杂度\"></a>set&#x2F;map&#x2F;vector插入复杂度</h2><ul>\n<li>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</li>\n<li>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)。</li>\n<li>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是关于一些Cpp中STL的基础知识整理。</p>\n<h2 id=\"STL组件\"><a href=\"#STL组件\" class=\"headerlink\" title=\"STL组件\"></a>STL组件</h2><h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。</p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator-&gt;、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p>\n<h3 id=\"仿函数\"><a href=\"#仿函数\" class=\"headerlink\" title=\"仿函数\"></a>仿函数</h3><p>行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。</p>\n<h3 id=\"配接器\"><a href=\"#配接器\" class=\"headerlink\" title=\"配接器\"></a>配接器</h3><p>一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。</p>\n<h3 id=\"配置器\"><a href=\"#配置器\" class=\"headerlink\" title=\"配置器\"></a>配置器</h3><p>负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</p>\n<h2 id=\"STL中的哈希\"><a href=\"#STL中的哈希\" class=\"headerlink\" title=\"STL中的哈希\"></a>STL中的哈希</h2><p>它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，默认的桶大小是10。</p>\n<h3 id=\"哈希冲突解决\"><a href=\"#哈希冲突解决\" class=\"headerlink\" title=\"哈希冲突解决\"></a>哈希冲突解决</h3><p>线性探查；二次平方探查；二次哈希法；开链法；建立公共溢出区。</p>\n<h2 id=\"STL中的map\"><a href=\"#STL中的map\" class=\"headerlink\" title=\"STL中的map\"></a>STL中的map</h2><h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</p>\n<h3 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h3><p>使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。</p>\n<h2 id=\"STL中的vector\"><a href=\"#STL中的vector\" class=\"headerlink\" title=\"STL中的vector\"></a>STL中的vector</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>STL中的vector是封装了动态数组的顺序容器。</p>\n<h3 id=\"扩充规则\"><a href=\"#扩充规则\" class=\"headerlink\" title=\"扩充规则\"></a>扩充规则</h3><p>每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p>\n<h3 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h3><p>vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。</p>\n<h3 id=\"与list的对比\"><a href=\"#与list的对比\" class=\"headerlink\" title=\"与list的对比\"></a>与list的对比</h3><p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>\n<h3 id=\"vector的迭代器失效\"><a href=\"#vector的迭代器失效\" class=\"headerlink\" title=\"vector的迭代器失效\"></a>vector的迭代器失效</h3><ul>\n<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效。</li>\n<li>当vector在插入的时候，end迭代器肯定会失效。</li>\n<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>\n</ul>\n<h2 id=\"STL中的string\"><a href=\"#STL中的string\" class=\"headerlink\" title=\"STL中的string\"></a>STL中的string</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>string继承自basic_string,其实是对char<em>进行了封装，封装的string包含了char</em>数组，容量，长度等等属性。</p>\n<h3 id=\"扩充规则-1\"><a href=\"#扩充规则-1\" class=\"headerlink\" title=\"扩充规则\"></a>扩充规则</h3><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</p>\n<h2 id=\"STL中的sort实现\"><a href=\"#STL中的sort实现\" class=\"headerlink\" title=\"STL中的sort实现\"></a>STL中的sort实现</h2><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>\n<h2 id=\"set-map-vector插入复杂度\"><a href=\"#set-map-vector插入复杂度\" class=\"headerlink\" title=\"set&#x2F;map&#x2F;vector插入复杂度\"></a>set&#x2F;map&#x2F;vector插入复杂度</h2><ul>\n<li>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</li>\n<li>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)。</li>\n<li>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝。</li>\n</ul>\n"},{"title":"模版编程技巧(一)--CRTP","date":"2023-12-08T10:24:34.000Z","_content":"CRTP（Curiously Recurring Template Pattern）是一种模板的编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。\n# 1 基于虚函数实现的动态多态\n如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。\n```\n// 基类\nclass Shape {\npublic:\n    // 虚函数，实现多态\n    virtual void printArea() const {\n        std::cout << \"Shape Area\" << std::endl;\n    }\n\n    // 基类可能包含其他的成员函数或数据成员\n};\n\n// 派生类1\nclass Circle : public Shape {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape {\npublic:\n    Square(double side) : side(side) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\nprivate:\n    double side;\n};\n```\n但是问题是在每次执行 shape->printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。\n因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。\n# 2 基于模板实现的静态多态\n为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。\n```\n#include <iostream>\n\n// 基类模板\ntemplate <typename T>\nclass Shape {\npublic:\n    // 模板函数，实现静态多态\n    void printArea() const {\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n\n    // 重载++运算符，用于对派生类中的参数进行自增\n    T& operator++() {\n        static_cast<T*>(this)->increment();\n        return *static_cast<T*>(this);\n    }\n};\n\n// 派生类1\nclass Circle : public Shape<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\n    // 自增半径\n    void increment() {\n        ++radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\n    // 自增边长\n    void increment() {\n        ++side;\n    }\n\nprivate:\n    double side;\n};\n\nint main() {\n    Circle circle(5.0);\n    Square square(4.0);\n\n    // 调用基类模板函数，实现静态多态\n    circle.printArea();\n    square.printArea();\n\n    // 使用++运算符对派生类中的参数进行自增\n    ++circle;\n    ++square;\n\n    // 再次调用基类模板函数，查看自增后的结果\n    circle.printArea();\n    square.printArea();\n\n    return 0;\n}\n\n```\n\n在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。\n# 3 基于虚函数和模板混合的多态实现\n虽然上文基于模版也实现了可用的静态多态，但是还存在问题。\n如果是基于虚函数实现的多态，由于不同的子类指针，Circle*，Square*等指针可以很轻易地传给基类Shape*，这样可以在容器中vector<Shape*>很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。\n事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。\n在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。\n```\n#include <iostream>\n#include <vector>\n\nusing std::cout; \nusing std::endl;\nusing std::vector;\n\nclass Shape {\n public:\n    virtual void printArea () const = 0;\n    virtual ~Shape() {}\n};\n\ntemplate <typename T>\nclass Shape_CRTP: public Shape {\n public:\n    void printArea() const override{\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n    \n};\n\nclass Circle: public Shape_CRTP<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape_CRTP<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\nprivate:\n    double side;\n};\n\nint main () {\n    vector<Shape*> list;\n    list.push_back(new Circle(1));\n    list.push_back(new Square(1));\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        (*iter)->printArea();\n    }\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        delete (*iter);\n    }\n    return 0;\n}\n```\n","source":"_posts/Template-programming-1.md","raw":"---\ntitle: 模版编程技巧(一)--CRTP\ndate: 2023-12-08 18:24:34\ntags: Cpp\n---\nCRTP（Curiously Recurring Template Pattern）是一种模板的编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。\n# 1 基于虚函数实现的动态多态\n如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。\n```\n// 基类\nclass Shape {\npublic:\n    // 虚函数，实现多态\n    virtual void printArea() const {\n        std::cout << \"Shape Area\" << std::endl;\n    }\n\n    // 基类可能包含其他的成员函数或数据成员\n};\n\n// 派生类1\nclass Circle : public Shape {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape {\npublic:\n    Square(double side) : side(side) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\nprivate:\n    double side;\n};\n```\n但是问题是在每次执行 shape->printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。\n因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。\n# 2 基于模板实现的静态多态\n为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。\n```\n#include <iostream>\n\n// 基类模板\ntemplate <typename T>\nclass Shape {\npublic:\n    // 模板函数，实现静态多态\n    void printArea() const {\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n\n    // 重载++运算符，用于对派生类中的参数进行自增\n    T& operator++() {\n        static_cast<T*>(this)->increment();\n        return *static_cast<T*>(this);\n    }\n};\n\n// 派生类1\nclass Circle : public Shape<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\n    // 自增半径\n    void increment() {\n        ++radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\n    // 自增边长\n    void increment() {\n        ++side;\n    }\n\nprivate:\n    double side;\n};\n\nint main() {\n    Circle circle(5.0);\n    Square square(4.0);\n\n    // 调用基类模板函数，实现静态多态\n    circle.printArea();\n    square.printArea();\n\n    // 使用++运算符对派生类中的参数进行自增\n    ++circle;\n    ++square;\n\n    // 再次调用基类模板函数，查看自增后的结果\n    circle.printArea();\n    square.printArea();\n\n    return 0;\n}\n\n```\n\n在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。\n# 3 基于虚函数和模板混合的多态实现\n虽然上文基于模版也实现了可用的静态多态，但是还存在问题。\n如果是基于虚函数实现的多态，由于不同的子类指针，Circle*，Square*等指针可以很轻易地传给基类Shape*，这样可以在容器中vector<Shape*>很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。\n事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。\n在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。\n```\n#include <iostream>\n#include <vector>\n\nusing std::cout; \nusing std::endl;\nusing std::vector;\n\nclass Shape {\n public:\n    virtual void printArea () const = 0;\n    virtual ~Shape() {}\n};\n\ntemplate <typename T>\nclass Shape_CRTP: public Shape {\n public:\n    void printArea() const override{\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n    \n};\n\nclass Circle: public Shape_CRTP<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape_CRTP<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\nprivate:\n    double side;\n};\n\nint main () {\n    vector<Shape*> list;\n    list.push_back(new Circle(1));\n    list.push_back(new Square(1));\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        (*iter)->printArea();\n    }\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        delete (*iter);\n    }\n    return 0;\n}\n```\n","slug":"Template-programming-1","published":1,"updated":"2023-12-11T15:13:09.473Z","_id":"clpwhfu0i0000dfx5hbi5ghws","comments":1,"layout":"post","photos":[],"link":"","content":"<p>CRTP（Curiously Recurring Template Pattern）是一种模板的编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。</p>\n<h1 id=\"1-基于虚函数实现的动态多态\"><a href=\"#1-基于虚函数实现的动态多态\" class=\"headerlink\" title=\"1 基于虚函数实现的动态多态\"></a>1 基于虚函数实现的动态多态</h1><p>如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基类</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 虚函数，实现多态</span><br><span class=\"line\">    virtual void printArea() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Shape Area&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 基类可能包含其他的成员函数或数据成员</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是问题是在每次执行 shape-&gt;printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。<br>因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。</p>\n<h1 id=\"2-基于模板实现的静态多态\"><a href=\"#2-基于模板实现的静态多态\" class=\"headerlink\" title=\"2 基于模板实现的静态多态\"></a>2 基于模板实现的静态多态</h1><p>为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 基类模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 模板函数，实现静态多态</span><br><span class=\"line\">    void printArea() const &#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重载++运算符，用于对派生类中的参数进行自增</span><br><span class=\"line\">    T&amp; operator++() &#123;</span><br><span class=\"line\">        static_cast&lt;T*&gt;(this)-&gt;increment();</span><br><span class=\"line\">        return *static_cast&lt;T*&gt;(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增半径</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增边长</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++side;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Circle circle(5.0);</span><br><span class=\"line\">    Square square(4.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用基类模板函数，实现静态多态</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用++运算符对派生类中的参数进行自增</span><br><span class=\"line\">    ++circle;</span><br><span class=\"line\">    ++square;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 再次调用基类模板函数，查看自增后的结果</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。</p>\n<h1 id=\"3-基于虚函数和模板混合的多态实现\"><a href=\"#3-基于虚函数和模板混合的多态实现\" class=\"headerlink\" title=\"3 基于虚函数和模板混合的多态实现\"></a>3 基于虚函数和模板混合的多态实现</h1><p>虽然上文基于模版也实现了可用的静态多态，但是还存在问题。<br>如果是基于虚函数实现的多态，由于不同的子类指针，Circle<em>，Square</em>等指针可以很轻易地传给基类Shape*，这样可以在容器中vector&lt;Shape*&gt;很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。<br>事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。<br>在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using std::cout; </span><br><span class=\"line\">using std::endl;</span><br><span class=\"line\">using std::vector;</span><br><span class=\"line\"></span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    virtual void printArea () const = 0;</span><br><span class=\"line\">    virtual ~Shape() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape_CRTP: public Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    void printArea() const override&#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Circle: public Shape_CRTP&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape_CRTP&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\">    vector&lt;Shape*&gt; list;</span><br><span class=\"line\">    list.push_back(new Circle(1));</span><br><span class=\"line\">    list.push_back(new Square(1));</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        (*iter)-&gt;printArea();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        delete (*iter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>CRTP（Curiously Recurring Template Pattern）是一种模板的编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。</p>\n<h1 id=\"1-基于虚函数实现的动态多态\"><a href=\"#1-基于虚函数实现的动态多态\" class=\"headerlink\" title=\"1 基于虚函数实现的动态多态\"></a>1 基于虚函数实现的动态多态</h1><p>如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基类</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 虚函数，实现多态</span><br><span class=\"line\">    virtual void printArea() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Shape Area&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 基类可能包含其他的成员函数或数据成员</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是问题是在每次执行 shape-&gt;printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。<br>因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。</p>\n<h1 id=\"2-基于模板实现的静态多态\"><a href=\"#2-基于模板实现的静态多态\" class=\"headerlink\" title=\"2 基于模板实现的静态多态\"></a>2 基于模板实现的静态多态</h1><p>为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 基类模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 模板函数，实现静态多态</span><br><span class=\"line\">    void printArea() const &#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重载++运算符，用于对派生类中的参数进行自增</span><br><span class=\"line\">    T&amp; operator++() &#123;</span><br><span class=\"line\">        static_cast&lt;T*&gt;(this)-&gt;increment();</span><br><span class=\"line\">        return *static_cast&lt;T*&gt;(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增半径</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增边长</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++side;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Circle circle(5.0);</span><br><span class=\"line\">    Square square(4.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用基类模板函数，实现静态多态</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用++运算符对派生类中的参数进行自增</span><br><span class=\"line\">    ++circle;</span><br><span class=\"line\">    ++square;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 再次调用基类模板函数，查看自增后的结果</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。</p>\n<h1 id=\"3-基于虚函数和模板混合的多态实现\"><a href=\"#3-基于虚函数和模板混合的多态实现\" class=\"headerlink\" title=\"3 基于虚函数和模板混合的多态实现\"></a>3 基于虚函数和模板混合的多态实现</h1><p>虽然上文基于模版也实现了可用的静态多态，但是还存在问题。<br>如果是基于虚函数实现的多态，由于不同的子类指针，Circle<em>，Square</em>等指针可以很轻易地传给基类Shape*，这样可以在容器中vector&lt;Shape*&gt;很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。<br>事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。<br>在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using std::cout; </span><br><span class=\"line\">using std::endl;</span><br><span class=\"line\">using std::vector;</span><br><span class=\"line\"></span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    virtual void printArea () const = 0;</span><br><span class=\"line\">    virtual ~Shape() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape_CRTP: public Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    void printArea() const override&#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Circle: public Shape_CRTP&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape_CRTP&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\">    vector&lt;Shape*&gt; list;</span><br><span class=\"line\">    list.push_back(new Circle(1));</span><br><span class=\"line\">    list.push_back(new Square(1));</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        (*iter)-&gt;printArea();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        delete (*iter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"C++无锁编程(一)","date":"2023-12-11T15:09:07.000Z","_content":"所谓的无锁编程，真的存在吗？\n# 1 无锁编程的背景\n## 1.1 需要互斥锁的原因\n在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。\n在本质上，可以归结为两种原因：\n\n1. 需要安全地并发访问共享资源。\n2. 需要在共享资源上控制访问顺序。\n\n它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。\n## 1.2 互斥锁存在的问题\n### 1.2.1 互斥锁的本质\n互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。\n```cpp\nstruct mutex_lock{\n\tatomic_t state;\n\tobject owner;\n\tqueue waiting_threads;\n}\n```\n在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：\n\n1. 如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；\n2. 如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。\n\n在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“**线程切换**”。\n### 1.2.2 互斥锁带来的开销\n#### 1.2.2.1 互斥锁本身的开销\n使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。\n#### 1.2.2.2 线程切换的开销\n一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）\n**直接开销：**\n\n1. 切换页表全局目录\n2. 切换内核态堆栈\n3. 切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）\n4. 刷新TLB（在切换后进行页表查询时将全部击穿TLB）\n\n**间接开销：**\n间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 \n\n感兴趣的同学可以参考这篇文章：\n[https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf](https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf)\n# 2 无锁编程原理\n继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。\n所以，身为程序开发者，只能从另外的角度来消除锁的影响。\n## 2.1 从自旋锁说起\n直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。\n那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：\n```cpp\natomic<bool> isLock = false;\nvoid ThreadFunc(){\n\tbool expect = flase;\n\twhile(!isLock.compare_exchange_weak(expect,true)){\n    \texpect = false;\n    }\n\t//do something\n    isLock.store(false);\n}\n\n```\n这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。\n## 2.2 atomic凭什么保证原子性?\n上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？\n事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。\n在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock = xx 这个操作不被打断或者穿插。\n## 2.3 如果多核条件下原子性还存在吗？\n但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？\n### 2.3.1 单核心CPU的写策略\n先简单回顾一下单核心CPU的两种写策略：\n\n- **写直达**：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持**强一致性**，这种做法影响写操作的性能。\n- **写回**：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：\n   - 如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。\n   - 如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：\n      - **若该缓存行被标记为已修改**，读写操作都会将缓存行中现存的数据**写回**内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；\n      - **若该缓存行未被标记为已修改**，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。\n### 2.3.2 多核心CPU的写策略\n早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。\n\n- **写传播：**CPU进行缓存数据更新时需要告知其他CPU\n\n如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务**串行化**，否则会出现问题。\n举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。\nCPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。\nMESI首先规定了缓存的四种状态：\n\n- _Modified_，已修改\n- _Exclusive_，独占\n- _Shared_，共享\n- _Invalidated_，已失效\n\n| **当前状态** | **事件** | **状态流转规则** |\n| --- | --- | --- |\n| 已失效 | Local Read | 由于当前缓存行失效，需要重新从内存中读取数据。\n- 其他CPU中没有该数据，直接从内存中读取数据，并将缓存行状置为E\n- 其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中后再读取内存数据，并将缓存行状态置为S\n- 其他CPU中存在该数据，且对应缓存行状态为S或E，从内存中读取数据并将缓存行状态置为S\n |\n|  | Local Write | 由于当前缓存行失效，需要重新从内存中读取数据。\n- 其他CPU中没有该数据，直接从内存中读取数据，修改数据后将缓存行状置为M\n- 其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中，并将缓存行状态置为1，然后本地再读取内存数据，修改数据后将缓存行状置为M\n- 其他CPU中存在该数据，且对应缓存行状态为S或E，本地CPU从内存中读取数据并将缓存行状态置为M，同时其他CPU将缓存行状态置为1\n |\n|  | Remote Read | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |\n|  | Remote Write | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |\n| 独占\n | Local Read | 状态不变 |\n|  | Local Write | 状态变为M |\n|  | Remote Read | 其他CPU访问数据，不再独占，状态变为S |\n|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为l |\n| 共享 | Local Read | 状态不变 |\n|  | Local Write | 本地状态变为M，其他CPU中缓存该数据的缓存行状态变为1 |\n|  | Remote Read | 状态不变 |\n|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为1 |\n| 已修改\n | Local Read | 状态不变 |\n|  | Local Write | 状态不变 |\n|  | Remote Read | 其他CPU需要访问最新数据，需要将数据写入内存中，状态变为S |\n|  | Remote Write | 其他CPU需要访问最新数据，需要将数据写入内存中，由于其他CPU获取数据后又修改了数据，因此状态变为I |\n\n### 2.3.3 一些其他的引申\n缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，但是这边不进行展开了。\n## 2.4 是否可能存在指令乱序的问题？\n### 2.4.1 跨线程的无依赖指令可能存在乱序\n到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1;  //1\n    b = a;  //2\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    assert(b == 1); //5\n}\n```\n由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。\n### 2.4.2 通过内存屏障解决指令乱序问题\n#### 2.4.2.1 内存屏障概念\n内存屏障就是将内存/缓存的读写操作过程进行分隔。\n缓存和内存之间的操作分为 Store 和 Load 两种。\n\n- Store：将处理器缓存的数据刷新到内存中。\n- Load：将内存存储的数据拷贝到处理器的缓存中。\n| **屏障类型** | **指令示例** | **说明** |\n| --- | --- | --- |\n| LoadLoad 屏障 | Load指令1;\nLoadLoad屏障;\nLoad指令2; | 确保[Load 指令 1]加载数据到缓存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。 |\n| StoreStore 屏障 | Store指令1;\nStoreStore屏障;\nStore指令2; | 确保[Store 指令 1]写入数据到内存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存。 |\n| LoadStore 屏障 | Load指令1;\nLoadStore屏障;\nStore指令2; | 确保[Load 指令 1]加载数据到缓存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存 |\n| StoreLoad 屏障 | Store指令1;\nStoreLoad屏障;\nLoad指令2; | 确保[Store 指令 1]写入数据到内存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。 |\n\n从上表中可以看出来，内存屏障的主要作用就是通过**强制读写内存来间接避免指令重排**。\n所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1;  //1\n    b = a;  //2\n    StoreStoreBarriers();\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    LoadLoadBarriers();\n    assert(b == 1); //5\n}\n```\n#### 2.4.2.2 C++对内存屏障提供的接口\n假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。\n因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。\nC++提供了六种严格度不同的内存序：\n```cpp\ntypedef enum memory_order\n{\n    memory_order_relaxed,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_consume,\n    memory_order_acq_rel,\n    memory_order_seq_cst,\n} memory_oder;\n```\n**memory_order_relaxed**是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。\n在以下代码的示例中，使用了**memory_order_relaxed**内存序，执行顺序有可能是0或者42\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;//1\n    guard.store(1, std::memory_order_relaxed);//2\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_relaxed) != 0)//3\n    {\n        p = payload;//4\n    }\n}\n```\n**memory_order_seq_cst**在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_seq_cst);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_seq_cst) != 0)\n    {\n        p = payload;\n    }\n}\n```\n**memory_order_release** 和 **memory_order_acquire**是释放和获取序列。\nrelease 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。\nacquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。\n使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。\n这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。\n在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_release);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_acquire) != 0)\n    {\n        p = payload;\n    }\n}\n\n```\n**memory_order_release** 和 **memory_order_consume **是数据依赖序列。\nmemory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。\n在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。\n\n","source":"_posts/lock-free-programming.md","raw":"---\ntitle: C++无锁编程(一)\ndate: 2023-12-11 23:09:07\ntags: Cpp\n---\n所谓的无锁编程，真的存在吗？\n# 1 无锁编程的背景\n## 1.1 需要互斥锁的原因\n在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。\n在本质上，可以归结为两种原因：\n\n1. 需要安全地并发访问共享资源。\n2. 需要在共享资源上控制访问顺序。\n\n它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。\n## 1.2 互斥锁存在的问题\n### 1.2.1 互斥锁的本质\n互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。\n```cpp\nstruct mutex_lock{\n\tatomic_t state;\n\tobject owner;\n\tqueue waiting_threads;\n}\n```\n在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：\n\n1. 如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；\n2. 如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。\n\n在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“**线程切换**”。\n### 1.2.2 互斥锁带来的开销\n#### 1.2.2.1 互斥锁本身的开销\n使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。\n#### 1.2.2.2 线程切换的开销\n一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）\n**直接开销：**\n\n1. 切换页表全局目录\n2. 切换内核态堆栈\n3. 切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）\n4. 刷新TLB（在切换后进行页表查询时将全部击穿TLB）\n\n**间接开销：**\n间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 \n\n感兴趣的同学可以参考这篇文章：\n[https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf](https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf)\n# 2 无锁编程原理\n继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。\n所以，身为程序开发者，只能从另外的角度来消除锁的影响。\n## 2.1 从自旋锁说起\n直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。\n那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：\n```cpp\natomic<bool> isLock = false;\nvoid ThreadFunc(){\n\tbool expect = flase;\n\twhile(!isLock.compare_exchange_weak(expect,true)){\n    \texpect = false;\n    }\n\t//do something\n    isLock.store(false);\n}\n\n```\n这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。\n## 2.2 atomic凭什么保证原子性?\n上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？\n事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。\n在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock = xx 这个操作不被打断或者穿插。\n## 2.3 如果多核条件下原子性还存在吗？\n但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？\n### 2.3.1 单核心CPU的写策略\n先简单回顾一下单核心CPU的两种写策略：\n\n- **写直达**：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持**强一致性**，这种做法影响写操作的性能。\n- **写回**：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：\n   - 如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。\n   - 如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：\n      - **若该缓存行被标记为已修改**，读写操作都会将缓存行中现存的数据**写回**内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；\n      - **若该缓存行未被标记为已修改**，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。\n### 2.3.2 多核心CPU的写策略\n早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。\n\n- **写传播：**CPU进行缓存数据更新时需要告知其他CPU\n\n如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务**串行化**，否则会出现问题。\n举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。\nCPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。\nMESI首先规定了缓存的四种状态：\n\n- _Modified_，已修改\n- _Exclusive_，独占\n- _Shared_，共享\n- _Invalidated_，已失效\n\n| **当前状态** | **事件** | **状态流转规则** |\n| --- | --- | --- |\n| 已失效 | Local Read | 由于当前缓存行失效，需要重新从内存中读取数据。\n- 其他CPU中没有该数据，直接从内存中读取数据，并将缓存行状置为E\n- 其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中后再读取内存数据，并将缓存行状态置为S\n- 其他CPU中存在该数据，且对应缓存行状态为S或E，从内存中读取数据并将缓存行状态置为S\n |\n|  | Local Write | 由于当前缓存行失效，需要重新从内存中读取数据。\n- 其他CPU中没有该数据，直接从内存中读取数据，修改数据后将缓存行状置为M\n- 其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中，并将缓存行状态置为1，然后本地再读取内存数据，修改数据后将缓存行状置为M\n- 其他CPU中存在该数据，且对应缓存行状态为S或E，本地CPU从内存中读取数据并将缓存行状态置为M，同时其他CPU将缓存行状态置为1\n |\n|  | Remote Read | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |\n|  | Remote Write | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |\n| 独占\n | Local Read | 状态不变 |\n|  | Local Write | 状态变为M |\n|  | Remote Read | 其他CPU访问数据，不再独占，状态变为S |\n|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为l |\n| 共享 | Local Read | 状态不变 |\n|  | Local Write | 本地状态变为M，其他CPU中缓存该数据的缓存行状态变为1 |\n|  | Remote Read | 状态不变 |\n|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为1 |\n| 已修改\n | Local Read | 状态不变 |\n|  | Local Write | 状态不变 |\n|  | Remote Read | 其他CPU需要访问最新数据，需要将数据写入内存中，状态变为S |\n|  | Remote Write | 其他CPU需要访问最新数据，需要将数据写入内存中，由于其他CPU获取数据后又修改了数据，因此状态变为I |\n\n### 2.3.3 一些其他的引申\n缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，但是这边不进行展开了。\n## 2.4 是否可能存在指令乱序的问题？\n### 2.4.1 跨线程的无依赖指令可能存在乱序\n到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1;  //1\n    b = a;  //2\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    assert(b == 1); //5\n}\n```\n由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。\n### 2.4.2 通过内存屏障解决指令乱序问题\n#### 2.4.2.1 内存屏障概念\n内存屏障就是将内存/缓存的读写操作过程进行分隔。\n缓存和内存之间的操作分为 Store 和 Load 两种。\n\n- Store：将处理器缓存的数据刷新到内存中。\n- Load：将内存存储的数据拷贝到处理器的缓存中。\n| **屏障类型** | **指令示例** | **说明** |\n| --- | --- | --- |\n| LoadLoad 屏障 | Load指令1;\nLoadLoad屏障;\nLoad指令2; | 确保[Load 指令 1]加载数据到缓存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。 |\n| StoreStore 屏障 | Store指令1;\nStoreStore屏障;\nStore指令2; | 确保[Store 指令 1]写入数据到内存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存。 |\n| LoadStore 屏障 | Load指令1;\nLoadStore屏障;\nStore指令2; | 确保[Load 指令 1]加载数据到缓存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存 |\n| StoreLoad 屏障 | Store指令1;\nStoreLoad屏障;\nLoad指令2; | 确保[Store 指令 1]写入数据到内存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。 |\n\n从上表中可以看出来，内存屏障的主要作用就是通过**强制读写内存来间接避免指令重排**。\n所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1;  //1\n    b = a;  //2\n    StoreStoreBarriers();\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    LoadLoadBarriers();\n    assert(b == 1); //5\n}\n```\n#### 2.4.2.2 C++对内存屏障提供的接口\n假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。\n因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。\nC++提供了六种严格度不同的内存序：\n```cpp\ntypedef enum memory_order\n{\n    memory_order_relaxed,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_consume,\n    memory_order_acq_rel,\n    memory_order_seq_cst,\n} memory_oder;\n```\n**memory_order_relaxed**是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。\n在以下代码的示例中，使用了**memory_order_relaxed**内存序，执行顺序有可能是0或者42\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;//1\n    guard.store(1, std::memory_order_relaxed);//2\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_relaxed) != 0)//3\n    {\n        p = payload;//4\n    }\n}\n```\n**memory_order_seq_cst**在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_seq_cst);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_seq_cst) != 0)\n    {\n        p = payload;\n    }\n}\n```\n**memory_order_release** 和 **memory_order_acquire**是释放和获取序列。\nrelease 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。\nacquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。\n使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。\n这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。\n在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_release);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_acquire) != 0)\n    {\n        p = payload;\n    }\n}\n\n```\n**memory_order_release** 和 **memory_order_consume **是数据依赖序列。\nmemory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。\n在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。\n\n","slug":"lock-free-programming","published":1,"updated":"2023-12-11T15:12:10.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq11zwy60000dzx502l8bk9d","content":"<p>所谓的无锁编程，真的存在吗？</p>\n<h1 id=\"1-无锁编程的背景\"><a href=\"#1-无锁编程的背景\" class=\"headerlink\" title=\"1 无锁编程的背景\"></a>1 无锁编程的背景</h1><h2 id=\"1-1-需要互斥锁的原因\"><a href=\"#1-1-需要互斥锁的原因\" class=\"headerlink\" title=\"1.1 需要互斥锁的原因\"></a>1.1 需要互斥锁的原因</h2><p>在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。<br>在本质上，可以归结为两种原因：</p>\n<ol>\n<li>需要安全地并发访问共享资源。</li>\n<li>需要在共享资源上控制访问顺序。</li>\n</ol>\n<p>它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。</p>\n<h2 id=\"1-2-互斥锁存在的问题\"><a href=\"#1-2-互斥锁存在的问题\" class=\"headerlink\" title=\"1.2 互斥锁存在的问题\"></a>1.2 互斥锁存在的问题</h2><h3 id=\"1-2-1-互斥锁的本质\"><a href=\"#1-2-1-互斥锁的本质\" class=\"headerlink\" title=\"1.2.1 互斥锁的本质\"></a>1.2.1 互斥锁的本质</h3><p>互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mutex_lock</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">atomic_t</span> state;</span><br><span class=\"line\">\tobject owner;</span><br><span class=\"line\">\tqueue waiting_threads;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：</p>\n<ol>\n<li>如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；</li>\n<li>如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。</li>\n</ol>\n<p>在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“<strong>线程切换</strong>”。</p>\n<h3 id=\"1-2-2-互斥锁带来的开销\"><a href=\"#1-2-2-互斥锁带来的开销\" class=\"headerlink\" title=\"1.2.2 互斥锁带来的开销\"></a>1.2.2 互斥锁带来的开销</h3><h4 id=\"1-2-2-1-互斥锁本身的开销\"><a href=\"#1-2-2-1-互斥锁本身的开销\" class=\"headerlink\" title=\"1.2.2.1 互斥锁本身的开销\"></a>1.2.2.1 互斥锁本身的开销</h4><p>使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。</p>\n<h4 id=\"1-2-2-2-线程切换的开销\"><a href=\"#1-2-2-2-线程切换的开销\" class=\"headerlink\" title=\"1.2.2.2 线程切换的开销\"></a>1.2.2.2 线程切换的开销</h4><p>一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）<br><strong>直接开销：</strong></p>\n<ol>\n<li>切换页表全局目录</li>\n<li>切换内核态堆栈</li>\n<li>切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）</li>\n<li>刷新TLB（在切换后进行页表查询时将全部击穿TLB）</li>\n</ol>\n<p><strong>间接开销：</strong><br>间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 </p>\n<p>感兴趣的同学可以参考这篇文章：<br><a href=\"https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf\">https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf</a></p>\n<h1 id=\"2-无锁编程原理\"><a href=\"#2-无锁编程原理\" class=\"headerlink\" title=\"2 无锁编程原理\"></a>2 无锁编程原理</h1><p>继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。<br>所以，身为程序开发者，只能从另外的角度来消除锁的影响。</p>\n<h2 id=\"2-1-从自旋锁说起\"><a href=\"#2-1-从自旋锁说起\" class=\"headerlink\" title=\"2.1 从自旋锁说起\"></a>2.1 从自旋锁说起</h2><p>直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。<br>那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">atomic&lt;<span class=\"type\">bool</span>&gt; isLock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> expect = flase;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!isLock.<span class=\"built_in\">compare_exchange_weak</span>(expect,<span class=\"literal\">true</span>))&#123;</span><br><span class=\"line\">    \texpect = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//do something</span></span><br><span class=\"line\">    isLock.<span class=\"built_in\">store</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。</p>\n<h2 id=\"2-2-atomic凭什么保证原子性\"><a href=\"#2-2-atomic凭什么保证原子性\" class=\"headerlink\" title=\"2.2 atomic凭什么保证原子性?\"></a>2.2 atomic凭什么保证原子性?</h2><p>上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？<br>事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。<br>在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock &#x3D; xx 这个操作不被打断或者穿插。</p>\n<h2 id=\"2-3-如果多核条件下原子性还存在吗？\"><a href=\"#2-3-如果多核条件下原子性还存在吗？\" class=\"headerlink\" title=\"2.3 如果多核条件下原子性还存在吗？\"></a>2.3 如果多核条件下原子性还存在吗？</h2><p>但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？</p>\n<h3 id=\"2-3-1-单核心CPU的写策略\"><a href=\"#2-3-1-单核心CPU的写策略\" class=\"headerlink\" title=\"2.3.1 单核心CPU的写策略\"></a>2.3.1 单核心CPU的写策略</h3><p>先简单回顾一下单核心CPU的两种写策略：</p>\n<ul>\n<li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li>\n<li><strong>写回</strong>：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：<ul>\n<li>如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。</li>\n<li>如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：<ul>\n<li><strong>若该缓存行被标记为已修改</strong>，读写操作都会将缓存行中现存的数据<strong>写回</strong>内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；</li>\n<li><strong>若该缓存行未被标记为已修改</strong>，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-2-多核心CPU的写策略\"><a href=\"#2-3-2-多核心CPU的写策略\" class=\"headerlink\" title=\"2.3.2 多核心CPU的写策略\"></a>2.3.2 多核心CPU的写策略</h3><p>早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。</p>\n<ul>\n<li><strong>写传播：</strong>CPU进行缓存数据更新时需要告知其他CPU</li>\n</ul>\n<p>如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务<strong>串行化</strong>，否则会出现问题。<br>举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。<br>CPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。<br>MESI首先规定了缓存的四种状态：</p>\n<ul>\n<li>_Modified_，已修改</li>\n<li>_Exclusive_，独占</li>\n<li>_Shared_，共享</li>\n<li>_Invalidated_，已失效</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>当前状态</strong></th>\n<th><strong>事件</strong></th>\n<th><strong>状态流转规则</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>已失效</td>\n<td>Local Read</td>\n<td>由于当前缓存行失效，需要重新从内存中读取数据。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>其他CPU中没有该数据，直接从内存中读取数据，并将缓存行状置为E</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中后再读取内存数据，并将缓存行状态置为S</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为S或E，从内存中读取数据并将缓存行状态置为S<br> |<br>|  | Local Write | 由于当前缓存行失效，需要重新从内存中读取数据。</li>\n<li>其他CPU中没有该数据，直接从内存中读取数据，修改数据后将缓存行状置为M</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中，并将缓存行状态置为1，然后本地再读取内存数据，修改数据后将缓存行状置为M</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为S或E，本地CPU从内存中读取数据并将缓存行状态置为M，同时其他CPU将缓存行状态置为1<br> |<br>|  | Remote Read | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |<br>|  | Remote Write | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |<br>| 独占<br> | Local Read | 状态不变 |<br>|  | Local Write | 状态变为M |<br>|  | Remote Read | 其他CPU访问数据，不再独占，状态变为S |<br>|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为l |<br>| 共享 | Local Read | 状态不变 |<br>|  | Local Write | 本地状态变为M，其他CPU中缓存该数据的缓存行状态变为1 |<br>|  | Remote Read | 状态不变 |<br>|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为1 |<br>| 已修改<br> | Local Read | 状态不变 |<br>|  | Local Write | 状态不变 |<br>|  | Remote Read | 其他CPU需要访问最新数据，需要将数据写入内存中，状态变为S |<br>|  | Remote Write | 其他CPU需要访问最新数据，需要将数据写入内存中，由于其他CPU获取数据后又修改了数据，因此状态变为I |</li>\n</ul>\n<h3 id=\"2-3-3-一些其他的引申\"><a href=\"#2-3-3-一些其他的引申\" class=\"headerlink\" title=\"2.3.3 一些其他的引申\"></a>2.3.3 一些其他的引申</h3><p>缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，但是这边不进行展开了。</p>\n<h2 id=\"2-4-是否可能存在指令乱序的问题？\"><a href=\"#2-4-是否可能存在指令乱序的问题？\" class=\"headerlink\" title=\"2.4 是否可能存在指令乱序的问题？\"></a>2.4 是否可能存在指令乱序的问题？</h2><h3 id=\"2-4-1-跨线程的无依赖指令可能存在乱序\"><a href=\"#2-4-1-跨线程的无依赖指令可能存在乱序\" class=\"headerlink\" title=\"2.4.1 跨线程的无依赖指令可能存在乱序\"></a>2.4.1 跨线程的无依赖指令可能存在乱序</h3><p>到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;  <span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。</p>\n<h3 id=\"2-4-2-通过内存屏障解决指令乱序问题\"><a href=\"#2-4-2-通过内存屏障解决指令乱序问题\" class=\"headerlink\" title=\"2.4.2 通过内存屏障解决指令乱序问题\"></a>2.4.2 通过内存屏障解决指令乱序问题</h3><h4 id=\"2-4-2-1-内存屏障概念\"><a href=\"#2-4-2-1-内存屏障概念\" class=\"headerlink\" title=\"2.4.2.1 内存屏障概念\"></a>2.4.2.1 内存屏障概念</h4><p>内存屏障就是将内存&#x2F;缓存的读写操作过程进行分隔。<br>缓存和内存之间的操作分为 Store 和 Load 两种。</p>\n<ul>\n<li>Store：将处理器缓存的数据刷新到内存中。</li>\n<li>Load：将内存存储的数据拷贝到处理器的缓存中。<table>\n<thead>\n<tr>\n<th><strong>屏障类型</strong></th>\n<th><strong>指令示例</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LoadLoad 屏障</td>\n<td>Load指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>LoadLoad屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Load指令2;</td>\n<td>确保[Load 指令 1]加载数据到缓存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreStore 屏障</td>\n<td>Store指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreStore屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Store指令2;</td>\n<td>确保[Store 指令 1]写入数据到内存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存。</td>\n<td></td>\n</tr>\n<tr>\n<td>LoadStore 屏障</td>\n<td>Load指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>LoadStore屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Store指令2;</td>\n<td>确保[Load 指令 1]加载数据到缓存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreLoad 屏障</td>\n<td>Store指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreLoad屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Load指令2;</td>\n<td>确保[Store 指令 1]写入数据到内存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>从上表中可以看出来，内存屏障的主要作用就是通过<strong>强制读写内存来间接避免指令重排</strong>。<br>所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;  <span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    <span class=\"built_in\">StoreStoreBarriers</span>();</span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">LoadLoadBarriers</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-2-2-C-对内存屏障提供的接口\"><a href=\"#2-4-2-2-C-对内存屏障提供的接口\" class=\"headerlink\" title=\"2.4.2.2 C++对内存屏障提供的接口\"></a>2.4.2.2 C++对内存屏障提供的接口</h4><p>假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。<br>因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。<br>C++提供了六种严格度不同的内存序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">memory_order</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    memory_order_relaxed,</span><br><span class=\"line\">    memory_order_acquire,</span><br><span class=\"line\">    memory_order_release,</span><br><span class=\"line\">    memory_order_consume,</span><br><span class=\"line\">    memory_order_acq_rel,</span><br><span class=\"line\">    memory_order_seq_cst,</span><br><span class=\"line\">&#125; memory_oder;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_relaxed</strong>是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。<br>在以下代码的示例中，使用了<strong>memory_order_relaxed</strong>内存序，执行顺序有可能是0或者42</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;<span class=\"comment\">//1</span></span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);<span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_relaxed) != <span class=\"number\">0</span>)<span class=\"comment\">//3</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;<span class=\"comment\">//4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_seq_cst</strong>在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_seq_cst);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_seq_cst) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 <strong>memory_order_acquire</strong>是释放和获取序列。<br>release 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。<br>acquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。<br>使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。<br>这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。<br>在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_acquire) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 **memory_order_consume **是数据依赖序列。<br>memory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。<br>在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>所谓的无锁编程，真的存在吗？</p>\n<h1 id=\"1-无锁编程的背景\"><a href=\"#1-无锁编程的背景\" class=\"headerlink\" title=\"1 无锁编程的背景\"></a>1 无锁编程的背景</h1><h2 id=\"1-1-需要互斥锁的原因\"><a href=\"#1-1-需要互斥锁的原因\" class=\"headerlink\" title=\"1.1 需要互斥锁的原因\"></a>1.1 需要互斥锁的原因</h2><p>在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。<br>在本质上，可以归结为两种原因：</p>\n<ol>\n<li>需要安全地并发访问共享资源。</li>\n<li>需要在共享资源上控制访问顺序。</li>\n</ol>\n<p>它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。</p>\n<h2 id=\"1-2-互斥锁存在的问题\"><a href=\"#1-2-互斥锁存在的问题\" class=\"headerlink\" title=\"1.2 互斥锁存在的问题\"></a>1.2 互斥锁存在的问题</h2><h3 id=\"1-2-1-互斥锁的本质\"><a href=\"#1-2-1-互斥锁的本质\" class=\"headerlink\" title=\"1.2.1 互斥锁的本质\"></a>1.2.1 互斥锁的本质</h3><p>互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mutex_lock</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">atomic_t</span> state;</span><br><span class=\"line\">\tobject owner;</span><br><span class=\"line\">\tqueue waiting_threads;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：</p>\n<ol>\n<li>如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；</li>\n<li>如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。</li>\n</ol>\n<p>在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“<strong>线程切换</strong>”。</p>\n<h3 id=\"1-2-2-互斥锁带来的开销\"><a href=\"#1-2-2-互斥锁带来的开销\" class=\"headerlink\" title=\"1.2.2 互斥锁带来的开销\"></a>1.2.2 互斥锁带来的开销</h3><h4 id=\"1-2-2-1-互斥锁本身的开销\"><a href=\"#1-2-2-1-互斥锁本身的开销\" class=\"headerlink\" title=\"1.2.2.1 互斥锁本身的开销\"></a>1.2.2.1 互斥锁本身的开销</h4><p>使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。</p>\n<h4 id=\"1-2-2-2-线程切换的开销\"><a href=\"#1-2-2-2-线程切换的开销\" class=\"headerlink\" title=\"1.2.2.2 线程切换的开销\"></a>1.2.2.2 线程切换的开销</h4><p>一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）<br><strong>直接开销：</strong></p>\n<ol>\n<li>切换页表全局目录</li>\n<li>切换内核态堆栈</li>\n<li>切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）</li>\n<li>刷新TLB（在切换后进行页表查询时将全部击穿TLB）</li>\n</ol>\n<p><strong>间接开销：</strong><br>间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 </p>\n<p>感兴趣的同学可以参考这篇文章：<br><a href=\"https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf\">https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf</a></p>\n<h1 id=\"2-无锁编程原理\"><a href=\"#2-无锁编程原理\" class=\"headerlink\" title=\"2 无锁编程原理\"></a>2 无锁编程原理</h1><p>继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。<br>所以，身为程序开发者，只能从另外的角度来消除锁的影响。</p>\n<h2 id=\"2-1-从自旋锁说起\"><a href=\"#2-1-从自旋锁说起\" class=\"headerlink\" title=\"2.1 从自旋锁说起\"></a>2.1 从自旋锁说起</h2><p>直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。<br>那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">atomic&lt;<span class=\"type\">bool</span>&gt; isLock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> expect = flase;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!isLock.<span class=\"built_in\">compare_exchange_weak</span>(expect,<span class=\"literal\">true</span>))&#123;</span><br><span class=\"line\">    \texpect = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//do something</span></span><br><span class=\"line\">    isLock.<span class=\"built_in\">store</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。</p>\n<h2 id=\"2-2-atomic凭什么保证原子性\"><a href=\"#2-2-atomic凭什么保证原子性\" class=\"headerlink\" title=\"2.2 atomic凭什么保证原子性?\"></a>2.2 atomic凭什么保证原子性?</h2><p>上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？<br>事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。<br>在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock &#x3D; xx 这个操作不被打断或者穿插。</p>\n<h2 id=\"2-3-如果多核条件下原子性还存在吗？\"><a href=\"#2-3-如果多核条件下原子性还存在吗？\" class=\"headerlink\" title=\"2.3 如果多核条件下原子性还存在吗？\"></a>2.3 如果多核条件下原子性还存在吗？</h2><p>但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？</p>\n<h3 id=\"2-3-1-单核心CPU的写策略\"><a href=\"#2-3-1-单核心CPU的写策略\" class=\"headerlink\" title=\"2.3.1 单核心CPU的写策略\"></a>2.3.1 单核心CPU的写策略</h3><p>先简单回顾一下单核心CPU的两种写策略：</p>\n<ul>\n<li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li>\n<li><strong>写回</strong>：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：<ul>\n<li>如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。</li>\n<li>如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：<ul>\n<li><strong>若该缓存行被标记为已修改</strong>，读写操作都会将缓存行中现存的数据<strong>写回</strong>内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；</li>\n<li><strong>若该缓存行未被标记为已修改</strong>，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-2-多核心CPU的写策略\"><a href=\"#2-3-2-多核心CPU的写策略\" class=\"headerlink\" title=\"2.3.2 多核心CPU的写策略\"></a>2.3.2 多核心CPU的写策略</h3><p>早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。</p>\n<ul>\n<li><strong>写传播：</strong>CPU进行缓存数据更新时需要告知其他CPU</li>\n</ul>\n<p>如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务<strong>串行化</strong>，否则会出现问题。<br>举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。<br>CPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。<br>MESI首先规定了缓存的四种状态：</p>\n<ul>\n<li>_Modified_，已修改</li>\n<li>_Exclusive_，独占</li>\n<li>_Shared_，共享</li>\n<li>_Invalidated_，已失效</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>当前状态</strong></th>\n<th><strong>事件</strong></th>\n<th><strong>状态流转规则</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>已失效</td>\n<td>Local Read</td>\n<td>由于当前缓存行失效，需要重新从内存中读取数据。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>其他CPU中没有该数据，直接从内存中读取数据，并将缓存行状置为E</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中后再读取内存数据，并将缓存行状态置为S</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为S或E，从内存中读取数据并将缓存行状态置为S<br> |<br>|  | Local Write | 由于当前缓存行失效，需要重新从内存中读取数据。</li>\n<li>其他CPU中没有该数据，直接从内存中读取数据，修改数据后将缓存行状置为M</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为M，要先将其他CPU中数据写回到内存中，并将缓存行状态置为1，然后本地再读取内存数据，修改数据后将缓存行状置为M</li>\n<li>其他CPU中存在该数据，且对应缓存行状态为S或E，本地CPU从内存中读取数据并将缓存行状态置为M，同时其他CPU将缓存行状态置为1<br> |<br>|  | Remote Read | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |<br>|  | Remote Write | 本地数据已失效，其他CPU读写操作不会再引起状态变化 |<br>| 独占<br> | Local Read | 状态不变 |<br>|  | Local Write | 状态变为M |<br>|  | Remote Read | 其他CPU访问数据，不再独占，状态变为S |<br>|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为l |<br>| 共享 | Local Read | 状态不变 |<br>|  | Local Write | 本地状态变为M，其他CPU中缓存该数据的缓存行状态变为1 |<br>|  | Remote Read | 状态不变 |<br>|  | Remote Write | 数据被其他CPU修改，本地缓存数据失效，状态变为1 |<br>| 已修改<br> | Local Read | 状态不变 |<br>|  | Local Write | 状态不变 |<br>|  | Remote Read | 其他CPU需要访问最新数据，需要将数据写入内存中，状态变为S |<br>|  | Remote Write | 其他CPU需要访问最新数据，需要将数据写入内存中，由于其他CPU获取数据后又修改了数据，因此状态变为I |</li>\n</ul>\n<h3 id=\"2-3-3-一些其他的引申\"><a href=\"#2-3-3-一些其他的引申\" class=\"headerlink\" title=\"2.3.3 一些其他的引申\"></a>2.3.3 一些其他的引申</h3><p>缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，但是这边不进行展开了。</p>\n<h2 id=\"2-4-是否可能存在指令乱序的问题？\"><a href=\"#2-4-是否可能存在指令乱序的问题？\" class=\"headerlink\" title=\"2.4 是否可能存在指令乱序的问题？\"></a>2.4 是否可能存在指令乱序的问题？</h2><h3 id=\"2-4-1-跨线程的无依赖指令可能存在乱序\"><a href=\"#2-4-1-跨线程的无依赖指令可能存在乱序\" class=\"headerlink\" title=\"2.4.1 跨线程的无依赖指令可能存在乱序\"></a>2.4.1 跨线程的无依赖指令可能存在乱序</h3><p>到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;  <span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。</p>\n<h3 id=\"2-4-2-通过内存屏障解决指令乱序问题\"><a href=\"#2-4-2-通过内存屏障解决指令乱序问题\" class=\"headerlink\" title=\"2.4.2 通过内存屏障解决指令乱序问题\"></a>2.4.2 通过内存屏障解决指令乱序问题</h3><h4 id=\"2-4-2-1-内存屏障概念\"><a href=\"#2-4-2-1-内存屏障概念\" class=\"headerlink\" title=\"2.4.2.1 内存屏障概念\"></a>2.4.2.1 内存屏障概念</h4><p>内存屏障就是将内存&#x2F;缓存的读写操作过程进行分隔。<br>缓存和内存之间的操作分为 Store 和 Load 两种。</p>\n<ul>\n<li>Store：将处理器缓存的数据刷新到内存中。</li>\n<li>Load：将内存存储的数据拷贝到处理器的缓存中。<table>\n<thead>\n<tr>\n<th><strong>屏障类型</strong></th>\n<th><strong>指令示例</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LoadLoad 屏障</td>\n<td>Load指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>LoadLoad屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Load指令2;</td>\n<td>确保[Load 指令 1]加载数据到缓存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreStore 屏障</td>\n<td>Store指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreStore屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Store指令2;</td>\n<td>确保[Store 指令 1]写入数据到内存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存。</td>\n<td></td>\n</tr>\n<tr>\n<td>LoadStore 屏障</td>\n<td>Load指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>LoadStore屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Store指令2;</td>\n<td>确保[Load 指令 1]加载数据到缓存之后，[Store 指令 2]以及[其之后所有 Store 指令]才能写入数据到内存</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreLoad 屏障</td>\n<td>Store指令1;</td>\n<td></td>\n</tr>\n<tr>\n<td>StoreLoad屏障;</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Load指令2;</td>\n<td>确保[Store 指令 1]写入数据到内存之后，[Load 指令 2]以及[其之后所有 Load 指令]才能加载数据到缓存。</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>从上表中可以看出来，内存屏障的主要作用就是通过<strong>强制读写内存来间接避免指令重排</strong>。<br>所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;  <span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    <span class=\"built_in\">StoreStoreBarriers</span>();</span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">LoadLoadBarriers</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-2-2-C-对内存屏障提供的接口\"><a href=\"#2-4-2-2-C-对内存屏障提供的接口\" class=\"headerlink\" title=\"2.4.2.2 C++对内存屏障提供的接口\"></a>2.4.2.2 C++对内存屏障提供的接口</h4><p>假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。<br>因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。<br>C++提供了六种严格度不同的内存序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">memory_order</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    memory_order_relaxed,</span><br><span class=\"line\">    memory_order_acquire,</span><br><span class=\"line\">    memory_order_release,</span><br><span class=\"line\">    memory_order_consume,</span><br><span class=\"line\">    memory_order_acq_rel,</span><br><span class=\"line\">    memory_order_seq_cst,</span><br><span class=\"line\">&#125; memory_oder;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_relaxed</strong>是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。<br>在以下代码的示例中，使用了<strong>memory_order_relaxed</strong>内存序，执行顺序有可能是0或者42</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;<span class=\"comment\">//1</span></span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);<span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_relaxed) != <span class=\"number\">0</span>)<span class=\"comment\">//3</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;<span class=\"comment\">//4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_seq_cst</strong>在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_seq_cst);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_seq_cst) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 <strong>memory_order_acquire</strong>是释放和获取序列。<br>release 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。<br>acquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。<br>使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。<br>这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。<br>在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_acquire) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 **memory_order_consume **是数据依赖序列。<br>memory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。<br>在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clpn0tde6000004x529vjdu07","tag_id":"clpn0tdea000104x58cqx284n","_id":"clpn0tded000204x5452bawwz"},{"post_id":"clppkl91m00000ix53f2wctgr","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clppkl91y00050ix5g7dwh16q"},{"post_id":"clppkl91r00010ix58yax4m3a","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clppm1ujz0000tpx57ftmdh94"},{"post_id":"clppkl91v00030ix5gsag2hlu","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clppm1ujz0001tpx52h8ger55"},{"post_id":"clppkl91x00040ix5bqqpcgw6","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clppmemsr000150x5431g1aad"},{"post_id":"clppmemsp000050x5h6ix033c","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clppmemsr000250x5467df085"},{"post_id":"clpwhfu0i0000dfx5hbi5ghws","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clpwhfu0n0001dfx515s22iyx"},{"post_id":"clq11zwy60000dzx502l8bk9d","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clq11zwy70001dzx53ujyc8cm"}],"Tag":[{"name":"Plan","_id":"clpn0tdea000104x58cqx284n"},{"name":"Cpp","_id":"clppkl91t00020ix53r29cxo3"}]}}