{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/Cpp-Basics-3-1.png","path":"images/Cpp-Basics-3-1.png","modified":0,"renderable":0},{"_id":"source/images/cache-friendly-1.png","path":"images/cache-friendly-1.png","modified":0,"renderable":0},{"_id":"source/images/cache-friendly-2.png","path":"images/cache-friendly-2.png","modified":0,"renderable":0},{"_id":"source/images/lock-free-programming-1.png","path":"images/lock-free-programming-1.png","modified":0,"renderable":0},{"_id":"source/images/lock-free-programming-2.png","path":"images/lock-free-programming-2.png","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"source/images/git-note/1.png","path":"images/git-note/1.png","modified":0,"renderable":0},{"_id":"source/images/git-note/2.png","path":"images/git-note/2.png","modified":0,"renderable":0},{"_id":"source/images/git-note/3.png","path":"images/git-note/3.png","modified":0,"renderable":0},{"_id":"source/images/git-note/4.png","path":"images/git-note/4.png","modified":0,"renderable":0},{"_id":"source/images/git-note/5.png","path":"images/git-note/5.png","modified":0,"renderable":0},{"_id":"source/images/git-note/6.png","path":"images/git-note/6.png","modified":0,"renderable":0},{"_id":"source/images/git-note/7.png","path":"images/git-note/7.png","modified":0,"renderable":0},{"_id":"source/images/git-note/8.png","path":"images/git-note/8.png","modified":0,"renderable":0},{"_id":"source/images/git-note/9.png","path":"images/git-note/9.png","modified":0,"renderable":0},{"_id":"source/images/design-pattern/1.png","path":"images/design-pattern/1.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/1.png","path":"images/refactor-project/1.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/2.png","path":"images/refactor-project/2.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/3.png","path":"images/refactor-project/3.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/4.png","path":"images/refactor-project/4.png","modified":0,"renderable":0},{"_id":"source/images/preformance-optimize-overview/1.png","path":"images/preformance-optimize-overview/1.png","modified":0,"renderable":0},{"_id":"source/images/shared-mem/1.png","path":"images/shared-mem/1.png","modified":0,"renderable":0},{"_id":"source/images/shared-mem/2.png","path":"images/shared-mem/2.png","modified":0,"renderable":0},{"_id":"source/images/shared-mem/3.png","path":"images/shared-mem/3.png","modified":0,"renderable":0},{"_id":"source/images/async-framework/1.png","path":"images/async-framework/1.png","modified":0,"renderable":0},{"_id":"source/images/async-framework/2.png","path":"images/async-framework/2.png","modified":0,"renderable":0},{"_id":"source/images/async-framework/3.png","path":"images/async-framework/3.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/Chain-of-responsibility.md","hash":"b5ffdd8c5117e1df6cdaab2efbca94ab8b6c48f5","modified":1706856454090},{"_id":"source/_posts/Cpp-basics-1.md","hash":"50555c469708548399fe8c4b1ae6a2f9f4cf48cc","modified":1702307543053},{"_id":"source/_posts/Cpp-basics-2.md","hash":"bcf386e8add4df4629dfcc29725fb44483ea4b91","modified":1702307552817},{"_id":"source/_posts/Cpp-basics-3.md","hash":"9bcc295c9921ff50ef4a2f7ba3b79a653abb4400","modified":1702307562049},{"_id":"source/_posts/Cpp-basics-4.md","hash":"0a882acecbc8ac648cde2b5679c28e3c829be067","modified":1702307571509},{"_id":"source/_posts/Cpp-basics-5.md","hash":"23eae02768c2a1c419124ad6af54862ed11598bf","modified":1702307580477},{"_id":"source/_posts/Template-programming-1.md","hash":"6468a228b5e0df210112afa5fa7f192a8a29b62a","modified":1702307589473},{"_id":"source/_posts/Thread-safe-circular-queue.md","hash":"8770fa533cc7dda2fb9bbbb12c517a77f0380c00","modified":1705627362463},{"_id":"source/_posts/cache-friendly-programming.md","hash":"9310255a4c3479137567e3664f96020e6231922a","modified":1705545911477},{"_id":"source/_posts/lock-free-programming.md","hash":"263578ab2569346f0659518a7fe5bb0f59a1a9de","modified":1702567127854},{"_id":"source/_posts/some-plans.md","hash":"c16282b0a564daefaa6c09f1dc2144370287d664","modified":1701459323498},{"_id":"source/about/index.md","hash":"d1c4144be14d041ccdb52c7707dcb2c514fe2b80","modified":1705395951786},{"_id":"source/images/Cpp-Basics-3-1.png","hash":"d37ee7ca1525dccd14fb09b71a8d84dc9f528bff","modified":1701615551509},{"_id":"source/images/cache-friendly-2.png","hash":"2bc8adca12bdfb357ca23c3bac491f3d3a171512","modified":1705505625607},{"_id":"source/images/cache-friendly-1.png","hash":"bc7f3894c0e354738369495b5635c5ad4fba712d","modified":1705505625607},{"_id":"source/images/lock-free-programming-2.png","hash":"f2999eceb49bb569f4b7a5f3eb8732c8a61931a6","modified":1702567025426},{"_id":"source/images/lock-free-programming-1.png","hash":"bba06b112ba07b2d6ceb0cbc2b1a29ad3272ebfa","modified":1702567024942},{"_id":"source/images/pattern-1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1702731607969},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701423241264},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1701423241260},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1701423241260},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1701423241260},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1701423241260},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1701423241260},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1701423241260},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1701423241264},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1701423241264},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1701423241264},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1701423241264},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1701423241264},{"_id":"themes/archer/_config.yml","hash":"43a6c1438dedab173844f91ed331a68581f52aeb","modified":1706786599946},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1701423241264},{"_id":"themes/archer/package.json","hash":"81af75826e854ac80f6337dc4f1ce4b51f066b0b","modified":1701423241272},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1701423241304},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1701423241304},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1701423241304},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1701423241264},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1701423241264},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1701423241264},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1701423241264},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1701423241264},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1701423241264},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1701423241264},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1701423241264},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1701423241264},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1701423241264},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1701423241264},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1701423241264},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1701423241260},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1701423241260},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1701423241260},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1701423241260},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"d8f4236166d058421c2e4ff00660be75a3494704","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"687c08823e7ce43e6ebb44f2fb4b75549abfed29","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1701423241264},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1701423241264},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1701423241264},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1701423241272},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1701423241272},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1701423241272},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1701423241272},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1701423241272},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1701423241272},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1701423241272},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1701423241272},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1701423241272},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1701423241272},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1701423241272},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1701423241272},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1701423241280},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1701423241280},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1701423241280},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1701423241280},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1701423241280},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1701423241288},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1701423241300},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1701423241304},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1701423241304},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1701423241304},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1701423241304},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1701423241304},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1701423241304},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1701423241304},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1701423241304},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1701423241304},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1701423241304},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1701423241304},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1701423241304},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1701423241304},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1701423241304},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1701423241304},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1701423241304},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1701423241304},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1701423241304},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1701423241304},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1701423241304},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1701423241304},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1701423241304},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1701423241304},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1701423241304},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1701423241264},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1701423241264},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1701423241264},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1701423241264},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1701423241304},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1701423241304},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1701423241304},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1701423241304},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1701423288848},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1701423241272},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1701423241272},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1701423241276},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1701423241276},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1701423241276},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1701423241280},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1701423241276},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1701423241280},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1701423241296},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1701423241304},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1701423241264},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1701423241280},{"_id":"themes/archer/package-lock.json","hash":"400ab1cc2a2f1380a5e9ab69abe3a5b93f923d8d","modified":1701423241272},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1701423241304},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1701423241288},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1701423241296},{"_id":"public/content.json","hash":"75267fcab230b3fd887335c05e7a861a09977f3f","modified":1707113744925},{"_id":"public/about/index.html","hash":"1d8d2f66a3536e79caa0999e5ffdf7f126dcce08","modified":1707113744925},{"_id":"public/2024/01/17/cache-friendly-programming/index.html","hash":"7a9b5d77c7703054d5a09ab733fd7f7d8d333c2c","modified":1706599807639},{"_id":"public/2023/12/28/Thread-safe-circular-queue/index.html","hash":"acbae853185800a93d8fe602e3f0e410d4ad0c82","modified":1706852767249},{"_id":"public/2023/12/16/Chain-of-responsibility/index.html","hash":"727f682978f3f77a46c0fba322de89022ce5d81d","modified":1707113744925},{"_id":"public/2023/12/11/lock-free-programming/index.html","hash":"b09b90d2b71357a94fd5717edfcb54d144aea563","modified":1706599807639},{"_id":"public/2023/12/08/Template-programming-1/index.html","hash":"be0ef18001eb2f1d387edf81abd34cdc619d894f","modified":1706853478666},{"_id":"public/2023/12/03/Cpp-basics-5/index.html","hash":"29a39238b176f7a6f2f27363fa9f68e7168a1c43","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-4/index.html","hash":"8fe4553db4ff623725f30887d55d8b6568499484","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-3/index.html","hash":"823876c40a00e4560deea996a1da4a62ba950ded","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-2/index.html","hash":"56388cda5a4f597737b1e76ef6e059204cd18fb1","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-1/index.html","hash":"5abad7369acc176dcd2a669d647c08b7f43a4360","modified":1705627368853},{"_id":"public/2023/12/02/some-plans/index.html","hash":"275d4d6f1ad3cc8fea091c81146cc883baea16a1","modified":1706517605102},{"_id":"public/archives/index.html","hash":"d2f25531d1c78b63ca676fe26c4b04c822a22be8","modified":1707113744925},{"_id":"public/archives/page/2/index.html","hash":"4798b6d1ac6040805e69b847b9546a797e5b9ed4","modified":1707113744925},{"_id":"public/archives/2023/index.html","hash":"3ebab1d253ce56d4d8671d8fb0df7031aee61b1c","modified":1707113744925},{"_id":"public/archives/2023/12/index.html","hash":"f7330f0d5c5a31c586bd6cf927e69170f690fd3f","modified":1707113744925},{"_id":"public/archives/2024/index.html","hash":"7ba39003475bdde45b01dc920135bec63f89ee3a","modified":1707113744925},{"_id":"public/archives/2024/01/index.html","hash":"d92d8a9429e2e76bdd5e0344a9c1c15b58ed6ae6","modified":1706853478666},{"_id":"public/index.html","hash":"7405584b4342a55b9d3e95de5d1c342ff76b9c0d","modified":1707113744925},{"_id":"public/page/2/index.html","hash":"0ab3c97ac9a8c0fd7b8e5eb8908848b56659669b","modified":1707113744925},{"_id":"public/tags/design-pattern/index.html","hash":"7c0e7c4a648fae1ba67b1e3d2d56ddcd7a03d84d","modified":1706856280249},{"_id":"public/tags/Cpp/index.html","hash":"7f73d6978e9ba689a8c7623c7bc14d3a02af6929","modified":1706853478666},{"_id":"public/tags/Gpt/index.html","hash":"a07fe870cf762ca582006510ca8b63ed841557c0","modified":1706852767249},{"_id":"public/tags/Plan/index.html","hash":"a4d65225ec80342d9fd9d73c0441adf202aa9a78","modified":1707113744925},{"_id":"public/images/Cpp-Basics-3-1.png","hash":"d37ee7ca1525dccd14fb09b71a8d84dc9f528bff","modified":1705507596386},{"_id":"public/images/cache-friendly-2.png","hash":"2bc8adca12bdfb357ca23c3bac491f3d3a171512","modified":1705507596386},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1705507596386},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1705507596386},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1705507596386},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1705507596386},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1705507596386},{"_id":"public/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1705507596386},{"_id":"public/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1705507596386},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1705507596386},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1705507596386},{"_id":"public/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1705507596386},{"_id":"public/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1705507596386},{"_id":"public/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1705507596386},{"_id":"public/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1705507596386},{"_id":"public/images/cache-friendly-1.png","hash":"bc7f3894c0e354738369495b5635c5ad4fba712d","modified":1705507596386},{"_id":"public/images/lock-free-programming-2.png","hash":"f2999eceb49bb569f4b7a5f3eb8732c8a61931a6","modified":1705507596386},{"_id":"public/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1705507596386},{"_id":"public/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1705507596386},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1705507596386},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1705507596386},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1705507596386},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1705507596386},{"_id":"public/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1705507596386},{"_id":"public/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1705507596386},{"_id":"public/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1705507596386},{"_id":"public/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1705507596386},{"_id":"public/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1705507596386},{"_id":"public/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1705507596386},{"_id":"public/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1705507596386},{"_id":"public/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1705507596386},{"_id":"public/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1705507596386},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1705507596386},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1705507596386},{"_id":"public/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1705507596386},{"_id":"public/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1705507596386},{"_id":"public/images/lock-free-programming-1.png","hash":"bba06b112ba07b2d6ceb0cbc2b1a29ad3272ebfa","modified":1705507596386},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1705507596386},{"_id":"public/images/pattern-1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1705507596386},{"_id":"public/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1705507596386},{"_id":"public/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1705507596386},{"_id":"source/_posts/.invisible/Cpp-basics-1.md","hash":"50555c469708548399fe8c4b1ae6a2f9f4cf48cc","modified":1702307543053},{"_id":"source/_posts/.invisible/Cpp-basics-2.md","hash":"bcf386e8add4df4629dfcc29725fb44483ea4b91","modified":1702307552817},{"_id":"source/_posts/.invisible/Cpp-basics-3.md","hash":"9bcc295c9921ff50ef4a2f7ba3b79a653abb4400","modified":1702307562049},{"_id":"source/_posts/.invisible/Cpp-basics-4.md","hash":"0a882acecbc8ac648cde2b5679c28e3c829be067","modified":1702307571509},{"_id":"source/_posts/.invisible/Cpp-basics-5.md","hash":"23eae02768c2a1c419124ad6af54862ed11598bf","modified":1702307580477},{"_id":"source/_posts/Todo-plans.md","hash":"1f68f07a7d5d13d1f1afc1eadf1ae08a2dfc4b6f","modified":1706629168458},{"_id":"public/2023/12/02/Todo-plans/index.html","hash":"ee763f301d7ac5dc200f15139c7ae0610d88d641","modified":1707113744925},{"_id":"source/_posts/Cache-friendly-programming.md","hash":"9310255a4c3479137567e3664f96020e6231922a","modified":1705545911477},{"_id":"source/_posts/Lock-free-programming.md","hash":"263578ab2569346f0659518a7fe5bb0f59a1a9de","modified":1702567127854},{"_id":"public/2024/01/17/Cache-friendly-programming/index.html","hash":"fe1541cac3264e0355e59045e3dbbdfd04727767","modified":1706853478666},{"_id":"public/2023/12/11/Lock-free-programming/index.html","hash":"7c96c38f28896cb50c1b21f5b37e1c8c87f081ef","modified":1706853478666},{"_id":"source/_posts/Git-note.md","hash":"34c8e0ced53d0a191652ce20983696a8c04cd7c5","modified":1706802262156},{"_id":"source/images/git-note/5.png","hash":"aa995b49e93ba6614209c3f6810907cf73b398ba","modified":1706785656526},{"_id":"source/images/git-note/4.png","hash":"92a23cfa36203e81b673c5ab7516b524767a0e58","modified":1706785657090},{"_id":"source/images/git-note/6.png","hash":"cf4190b9514a688bb1911d6a1fda643fe7cf4acc","modified":1706785646386},{"_id":"source/images/git-note/7.png","hash":"1133e055bd5c28ff77a6d2eb3319455fbe292748","modified":1706785646626},{"_id":"source/images/git-note/8.png","hash":"ffd56da0fd93052fe3a33a44913f22b72ae0dc0b","modified":1706785646678},{"_id":"source/images/git-note/9.png","hash":"cfa45589cbf8d072db5c2fbc7f27042d0018ad4f","modified":1706785646554},{"_id":"source/images/git-note/2.png","hash":"c3e332416640e8c3dd2c8c2bf9212b56c27fb442","modified":1706785646666},{"_id":"source/images/git-note/3.png","hash":"5888cca8fd2b2652c33f0f9987ba347459c269d6","modified":1706785656526},{"_id":"source/images/git-note/1.png","hash":"dbcb103a253421f3e1d515c7f4275b4efadef824","modified":1706785657158},{"_id":"public/2024/02/01/Git-note/index.html","hash":"b263ed72ea2772999c57efc2bf8db8e2a4d842a5","modified":1707113744925},{"_id":"public/archives/2024/02/index.html","hash":"e8bf473a522fee99083fd4b99f1f53d743d86788","modified":1707113744925},{"_id":"public/tags/学习杂记/index.html","hash":"de8c29f17426e9f942b7e635010ded62504294d5","modified":1707113744925},{"_id":"public/images/git-note/5.png","hash":"aa995b49e93ba6614209c3f6810907cf73b398ba","modified":1706785889352},{"_id":"public/images/git-note/4.png","hash":"92a23cfa36203e81b673c5ab7516b524767a0e58","modified":1706785889352},{"_id":"public/images/git-note/6.png","hash":"cf4190b9514a688bb1911d6a1fda643fe7cf4acc","modified":1706785889352},{"_id":"public/images/git-note/7.png","hash":"1133e055bd5c28ff77a6d2eb3319455fbe292748","modified":1706785889352},{"_id":"public/images/git-note/8.png","hash":"ffd56da0fd93052fe3a33a44913f22b72ae0dc0b","modified":1706785889352},{"_id":"public/images/git-note/9.png","hash":"cfa45589cbf8d072db5c2fbc7f27042d0018ad4f","modified":1706785889352},{"_id":"public/images/git-note/2.png","hash":"c3e332416640e8c3dd2c8c2bf9212b56c27fb442","modified":1706785889352},{"_id":"public/images/git-note/3.png","hash":"5888cca8fd2b2652c33f0f9987ba347459c269d6","modified":1706785889352},{"_id":"public/images/git-note/1.png","hash":"dbcb103a253421f3e1d515c7f4275b4efadef824","modified":1706785889352},{"_id":"source/images/design-pattern/1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1702731607969},{"_id":"public/images/design-pattern/1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1706803100691},{"_id":"source/_posts/Refactor-project.md","hash":"9c3c2e13b57a4cb7918b316ad181e82f6caaec9d","modified":1706804209784},{"_id":"source/images/refactor-project/1.png","hash":"6ac2914f05e62aa7ac36d1f54729e28959690318","modified":1706803818664},{"_id":"source/images/refactor-project/4.png","hash":"3af8036a7a8768cafcfe00afb300c94a8da5044a","modified":1706803819892},{"_id":"source/images/refactor-project/3.png","hash":"5fe8ee0104869a15d8eb49c23103dbd6cc3b77e0","modified":1706803819696},{"_id":"source/images/refactor-project/2.png","hash":"c02d0819bf2ee5d8ddea0961f9659cf468341b40","modified":1706803819696},{"_id":"public/2024/02/02/Refactor-project/index.html","hash":"3cae4ed4b19624753c2893171a05726a512c5c80","modified":1707113744925},{"_id":"public/images/refactor-project/1.png","hash":"6ac2914f05e62aa7ac36d1f54729e28959690318","modified":1706804220987},{"_id":"public/images/refactor-project/4.png","hash":"3af8036a7a8768cafcfe00afb300c94a8da5044a","modified":1706804220987},{"_id":"public/images/refactor-project/3.png","hash":"5fe8ee0104869a15d8eb49c23103dbd6cc3b77e0","modified":1706804220987},{"_id":"public/images/refactor-project/2.png","hash":"c02d0819bf2ee5d8ddea0961f9659cf468341b40","modified":1706804220987},{"_id":"source/_posts/Look-free-log.md","hash":"3cee6cc4af9e97723341420d08d417598c2fdad6","modified":1706852910498},{"_id":"public/2024/02/02/Look-free-log/index.html","hash":"514ab2692b0b280b2c9ca364ec12a505d8766e29","modified":1707113744925},{"_id":"public/tags/工具集合/index.html","hash":"a35245ca83a1fbe0e7fa9a81801dd0ce274b32fe","modified":1707113744925},{"_id":"source/_posts/Look-free-circular-queue.md","hash":"d3a3d473bdc48f654d88a05d9942621334aabc66","modified":1706853470494},{"_id":"public/2023/12/28/Look-free-circular-queue/index.html","hash":"de268cd4b60ae4845c563391a2348359afadb65a","modified":1707113744925},{"_id":"source/_posts/.invisible/Cache-friendly-programming.md","hash":"9310255a4c3479137567e3664f96020e6231922a","modified":1705545911477},{"_id":"source/_posts/.invisible/Lock-free-programming.md","hash":"263578ab2569346f0659518a7fe5bb0f59a1a9de","modified":1702567127854},{"_id":"source/_posts/.invisible/Template-programming-1.md","hash":"6468a228b5e0df210112afa5fa7f192a8a29b62a","modified":1702307589473},{"_id":"source/_posts/Preformance-optimize-overview.md","hash":"2315b54250d81034146160b812e0b567dc580fdc","modified":1706856504442},{"_id":"source/images/preformance-optimize-overview/1.png","hash":"97e3e375181395323437ba0edc8d2e726633c4e5","modified":1706854829734},{"_id":"public/2024/02/02/Preformance-optimize-overview/index.html","hash":"249b106e9f8c43f6e5a03bdaf20d7aba00ff1c19","modified":1707112695513},{"_id":"public/tags/随感杂记/index.html","hash":"8d711f2fa2872ff0717e927b48c5d220ecf71ca8","modified":1707113744925},{"_id":"public/images/preformance-optimize-overview/1.png","hash":"97e3e375181395323437ba0edc8d2e726633c4e5","modified":1706854946576},{"_id":"source/_posts/Poxis-api.md","hash":"f36ffca2c5d9264bdb02bdb3286df85f33f89b65","modified":1706856273170},{"_id":"source/_posts/Systemv-api.md","hash":"0ec4bdb9d9ef91f59e5e1ac9d6b50932bb258a57","modified":1706856176294},{"_id":"source/images/shared-mem/2.png","hash":"6d3e96dae2d40b9d5000360e8adccfdfb6c9d4df","modified":1706856037718},{"_id":"source/images/shared-mem/3.png","hash":"87dd8da0055b2eede6dc839537b94d9927533e61","modified":1706856037686},{"_id":"source/images/shared-mem/1.png","hash":"04f97909e7e2d8d0fe0677d930babf15c8c75a26","modified":1706856037786},{"_id":"public/2024/02/02/Poxis-api/index.html","hash":"861a0199575f2df3a2e81d9aee55c5eb38bd4b54","modified":1707113744925},{"_id":"public/2024/02/02/Systemv-api/index.html","hash":"777b16e30deac013523e5abaa0df83058b8dd98d","modified":1707113744925},{"_id":"public/tags/共享内存/index.html","hash":"f27a1c925c5af0197d9fc476fdf944143de52a0f","modified":1707113744925},{"_id":"public/images/shared-mem/2.png","hash":"6d3e96dae2d40b9d5000360e8adccfdfb6c9d4df","modified":1706856280249},{"_id":"public/images/shared-mem/3.png","hash":"87dd8da0055b2eede6dc839537b94d9927533e61","modified":1706856280249},{"_id":"public/images/shared-mem/1.png","hash":"04f97909e7e2d8d0fe0677d930babf15c8c75a26","modified":1706856280249},{"_id":"public/tags/设计模式/index.html","hash":"646ff0cebf7bc3f896870e650b24b476ebc6c8fc","modified":1707113744925},{"_id":"source/_posts/Sync-and-block.md","hash":"879d12a4c4643c76de6298abbe62f7b74a912b51","modified":1707111197138},{"_id":"public/2024/02/05/Sync-and-block/index.html","hash":"9947e040cbb10c0e962d5a83df6238da48c104f0","modified":1707113744925},{"_id":"source/_posts/Async-framework.md","hash":"777d505659a6c83ff618c2ecfa77e8eee6e7e831","modified":1707112362390},{"_id":"source/images/async-framework/2.png","hash":"2014342c37c683de7ed335c88ca10f346da92075","modified":1707112074846},{"_id":"source/images/async-framework/3.png","hash":"df099badc0d30fafad99fb60d1a470455d1f9988","modified":1707112074854},{"_id":"source/images/async-framework/1.png","hash":"ca861025f66c735e9f3217d8414834f7a8d0f1f3","modified":1707112074894},{"_id":"public/2024/02/05/Async-framework/index.html","hash":"f509a2564d014e310fa8cb632436f0d7833095d5","modified":1707113744925},{"_id":"public/tags/学习笔记/index.html","hash":"035fc8112d9ea8bac8ad6008c33e5362a97acc7c","modified":1707113744925},{"_id":"public/images/async-framework/2.png","hash":"2014342c37c683de7ed335c88ca10f346da92075","modified":1707112146744},{"_id":"public/images/async-framework/3.png","hash":"df099badc0d30fafad99fb60d1a470455d1f9988","modified":1707112146744},{"_id":"public/images/async-framework/1.png","hash":"ca861025f66c735e9f3217d8414834f7a8d0f1f3","modified":1707112146744},{"_id":"source/_posts/Byte-order-conversion.md","hash":"bddc8f61b8daf4fed49f72728213024d1070e742","modified":1707112686198},{"_id":"public/2024/02/05/Byte-order-conversion/index.html","hash":"00af319f9d8939de54ab35ca036973af22e75770","modified":1707113744925},{"_id":"source/_posts/Preformance-optimize-1.md","hash":"96b44b80fd5d11acebaac05e890f7ae8eac40bfd","modified":1707113437894},{"_id":"source/_posts/Preformance-optimize-2.md","hash":"1b7276ac428f6ac11a1545fd5a47a57a4a954439","modified":1707113676566},{"_id":"public/2024/02/05/Preformance-optimize-2/index.html","hash":"39650de81f445bf9f825bc7c3301b73e81461334","modified":1707113744925},{"_id":"public/2024/02/02/Preformance-optimize-1/index.html","hash":"5a710d77ba195079ea05c85024d1e85b2250dbf2","modified":1707113744925},{"_id":"public/tags/性能优化/index.html","hash":"8d8a3263b5497881d683880c6b6e71dfc3989ae0","modified":1707113744925}],"Category":[],"Data":[],"Page":[{"title":"About Me","layout":"about","date":"2023-12-01T08:44:29.000Z","_content":"\n## 教育背景\n**西安交通大学** Bachelor\n　　　　\n## 工作经历\n\n### 阿里巴巴网络技术有限公司 \n**服务端开发工程师**  2021年2月 -- 2022年7月\n在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。\n\n1. 进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。\n\n2. 解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。\n3. 在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。\n\n### 某量化投资有限公司\n**量化开发工程师**  2022年7月 -- 至今\n从0到1参与高频量化交易系统的开发，负责交易链路中高性能的通信中间件开发和系统整体的微秒级性能优化。\n\n1. 负责量化交易系统内的IPC中间件的开发，优化了原先依赖 Domain Socket 的通信方式，借助 Memory Fence 并且合理利用CPU的 Load/Store Buffer，实现了完全基于共享内存的无锁编程来实现关键交易路径上的通信。\n2. 负责量化交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法/数据分离以实现模板化改造、对算术运算部分进行CPU缓存友好优化，将业务逻辑内整体穿越时间从80微秒降低至10微秒内。\n\n\n## 专业技能\n\n- 熟悉C++ 20的新特性，了解模板编程\n- 了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率\n- 了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验\n- 其他语言的开发能力，包括Rust、Java、Python等\n","source":"about/index.md","raw":"---\ntitle: About Me\nlayout: about\ndate: 2023-12-01 16:44:29\n---\n\n## 教育背景\n**西安交通大学** Bachelor\n　　　　\n## 工作经历\n\n### 阿里巴巴网络技术有限公司 \n**服务端开发工程师**  2021年2月 -- 2022年7月\n在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。\n\n1. 进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。\n\n2. 解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。\n3. 在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。\n\n### 某量化投资有限公司\n**量化开发工程师**  2022年7月 -- 至今\n从0到1参与高频量化交易系统的开发，负责交易链路中高性能的通信中间件开发和系统整体的微秒级性能优化。\n\n1. 负责量化交易系统内的IPC中间件的开发，优化了原先依赖 Domain Socket 的通信方式，借助 Memory Fence 并且合理利用CPU的 Load/Store Buffer，实现了完全基于共享内存的无锁编程来实现关键交易路径上的通信。\n2. 负责量化交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法/数据分离以实现模板化改造、对算术运算部分进行CPU缓存友好优化，将业务逻辑内整体穿越时间从80微秒降低至10微秒内。\n\n\n## 专业技能\n\n- 熟悉C++ 20的新特性，了解模板编程\n- 了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率\n- 了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验\n- 其他语言的开发能力，包括Rust、Java、Python等\n","updated":"2024-01-16T09:05:51.786Z","path":"about/index.html","comments":1,"_id":"clrhz6rwc00000ox547gvgicj","content":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p><strong>西安交通大学</strong> Bachelor\n　　　　</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"阿里巴巴网络技术有限公司\"><a href=\"#阿里巴巴网络技术有限公司\" class=\"headerlink\" title=\"阿里巴巴网络技术有限公司\"></a>阿里巴巴网络技术有限公司</h3><p><strong>服务端开发工程师</strong>  2021年2月 – 2022年7月<br>在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。</p>\n<ol>\n<li><p>进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。</p>\n</li>\n<li><p>解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。</p>\n</li>\n<li><p>在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。</p>\n</li>\n</ol>\n<h3 id=\"某量化投资有限公司\"><a href=\"#某量化投资有限公司\" class=\"headerlink\" title=\"某量化投资有限公司\"></a>某量化投资有限公司</h3><p><strong>量化开发工程师</strong>  2022年7月 – 至今<br>从0到1参与高频量化交易系统的开发，负责交易链路中高性能的通信中间件开发和系统整体的微秒级性能优化。</p>\n<ol>\n<li>负责量化交易系统内的IPC中间件的开发，优化了原先依赖 Domain Socket 的通信方式，借助 Memory Fence 并且合理利用CPU的 Load&#x2F;Store Buffer，实现了完全基于共享内存的无锁编程来实现关键交易路径上的通信。</li>\n<li>负责量化交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法&#x2F;数据分离以实现模板化改造、对算术运算部分进行CPU缓存友好优化，将业务逻辑内整体穿越时间从80微秒降低至10微秒内。</li>\n</ol>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>熟悉C++ 20的新特性，了解模板编程</li>\n<li>了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率</li>\n<li>了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验</li>\n<li>其他语言的开发能力，包括Rust、Java、Python等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p><strong>西安交通大学</strong> Bachelor\n　　　　</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"阿里巴巴网络技术有限公司\"><a href=\"#阿里巴巴网络技术有限公司\" class=\"headerlink\" title=\"阿里巴巴网络技术有限公司\"></a>阿里巴巴网络技术有限公司</h3><p><strong>服务端开发工程师</strong>  2021年2月 – 2022年7月<br>在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。</p>\n<ol>\n<li><p>进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。</p>\n</li>\n<li><p>解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。</p>\n</li>\n<li><p>在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。</p>\n</li>\n</ol>\n<h3 id=\"某量化投资有限公司\"><a href=\"#某量化投资有限公司\" class=\"headerlink\" title=\"某量化投资有限公司\"></a>某量化投资有限公司</h3><p><strong>量化开发工程师</strong>  2022年7月 – 至今<br>从0到1参与高频量化交易系统的开发，负责交易链路中高性能的通信中间件开发和系统整体的微秒级性能优化。</p>\n<ol>\n<li>负责量化交易系统内的IPC中间件的开发，优化了原先依赖 Domain Socket 的通信方式，借助 Memory Fence 并且合理利用CPU的 Load&#x2F;Store Buffer，实现了完全基于共享内存的无锁编程来实现关键交易路径上的通信。</li>\n<li>负责量化交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法&#x2F;数据分离以实现模板化改造、对算术运算部分进行CPU缓存友好优化，将业务逻辑内整体穿越时间从80微秒降低至10微秒内。</li>\n</ol>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>熟悉C++ 20的新特性，了解模板编程</li>\n<li>了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率</li>\n<li>了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验</li>\n<li>其他语言的开发能力，包括Rust、Java、Python等</li>\n</ul>\n"}],"Post":[{"title":"设计模式（一）：责任链","date":"2023-12-16T12:55:02.000Z","_content":"责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。\n\n\n# 背景\n在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。\n在设计之初有着足够简单的业务流程：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1\n3. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1\n3. 供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1\n4. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：\n\n1. 在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。\n2. 对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。\n3. 当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。\n# 解决方案\n与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。\n\n- 在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。\n- 请求及其数据则会被作为参数传递给该方法。\n\n责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。\n\n- 除了处理请求外，处理者还负责沿着链传递请求。\n- 请求会在链上移动，直至所有处理者都有机会对请求进行处理。\n\n最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。\n还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。\n\n- 如果自己能够处理，处理者就不再继续传递请求。\n- 在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理\n\n连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。\n\n- 对于第二种方式，感觉有些像观察者模式。\n- 两者具体实现、目的都差不多。主要区别在于：\n   - 观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可\n   - 责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理\n\n![image.png](/images/design-pattern/1.png)\n责任链模式的核心在于将处理对象整理成链路。\n# 适用场景\n\n- 程序需要使用不同方式处理请求\n   - 将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。\n- 当必须按顺序执行多个处理者时，可以使用该模式。\n   - 无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。\n- 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。\n   - 如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。\n# 实现步骤\n\n1. 声明处理者接口并提供请求处理方法的签名。\n   - 确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。\n2. 为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。\n   - 该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。\n   - 还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。\n3. 依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：\n   - 是否自行处理这个请求\n   - 是否将该请求沿着链进行传递\n4. 客户端可以自行组装链，或者从其他对象处获得预先组装好的链。\n   - 在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链\n5. 客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。\n6. 由于链的动态性，客户端需要处理以下情况：\n   - 部分请求可能无法到达链尾\n   - 其他请求可能直到链尾都未被处理\n# 优缺点\n优点：\n\n- 可以控制请求处理的顺序。\n- 单一职责原则。解耦了发起操作和执行操作的类。\n- 开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。\n\n缺点：\n\n- 部分请求最终可能都未被处理。\n# 与其它模式的关系\n\n- 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   - 责任链模式按照顺序将请求动态传递给一系列的潜在接收者。\n   - 命令模式在发送者和请求者之间建立单向连接。\n   - 中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。\n   - 观察者模式允许接收者动态地订阅或取消接收请求。\n- 责任链可以和组合模式结合使用\n   - 叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。\n- 责任链上的处理器可使用命令模式实现\n   - 可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   - 或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。\n- 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同\n   - 责任链上的处理器可以相互独立地执行，还可以随时停止传递请求\n   - 各种装饰可以在遵循基本接口的情况下扩展对象的行为\n   - 装饰无法中断请求的传递\n# 示例\n```cpp\n#include <iostream>\n#include <string>\n\n// 定义处理者接口\nclass Approver {\npublic:\nvirtual void processRequest(const std::string& request) = 0;\nvirtual ~Approver() {}\n};\n\n// 创建抽象处理者基类\nclass BaseApprover : public Approver {\nprivate:\nApprover* nextApprover;\n\npublic:\nBaseApprover() : nextApprover(nullptr) {}\n\n// 设置下一个处理者\nvoid setNextApprover(Approver* next) {\n    nextApprover = next;\n}\n\n// 处理请求的默认行为\nvoid processRequest(const std::string& request) override {\n    if (nextApprover != nullptr) {\n        nextApprover->processRequest(request);\n    } else {\n        std::cout << \"Request not handled by any approver.\" << std::endl;\n    }\n}\n};\n\n// 具体处理者子类：商品品控人员\nclass QualityControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"QualityCheck\") {\n        std::cout << \"QualityControlApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：供应商资质管理员\nclass SupplierQualificationApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"SupplierQualificationCheck\") {\n        std::cout << \"SupplierQualificationApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：上架风控人员\nclass RiskControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"MarketingRuleCheck\") {\n        std::cout << \"RiskControlApprover handles the request and approves the product for shelf.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\nint main() {\n    // 创建责任链\n    QualityControlApprover qualityControlApprover;\n    SupplierQualificationApprover supplierQualificationApprover;\n    RiskControlApprover riskControlApprover;\n\n    // 设置责任链顺序\n    qualityControlApprover.setNextApprover(&supplierQualificationApprover);\n    supplierQualificationApprover.setNextApprover(&riskControlApprover);\n\n    // 模拟商品上架流程\n    std::cout << \"Scenario 1:\" << std::endl;\n    qualityControlApprover.processRequest(\"QualityCheck\");\n\n    std::cout << \"\\nScenario 2:\" << std::endl;\n    qualityControlApprover.processRequest(\"SupplierQualificationCheck\");\n\n    std::cout << \"\\nScenario 3:\" << std::endl;\n    qualityControlApprover.processRequest(\"MarketingRuleCheck\");\n\n    std::cout << \"\\nScenario 4:\" << std::endl;\n    qualityControlApprover.processRequest(\"SomeOtherCheck\");\n\n    return 0;\n}\n\n```\n\n\n","source":"_posts/Chain-of-responsibility.md","raw":"---\ntitle: 设计模式（一）：责任链\ndate: 2023-12-16 20:55:02\ntags: 设计模式\n---\n责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。\n\n\n# 背景\n在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。\n在设计之初有着足够简单的业务流程：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1\n3. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1\n3. 供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1\n4. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：\n\n1. 在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。\n2. 对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。\n3. 当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。\n# 解决方案\n与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。\n\n- 在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。\n- 请求及其数据则会被作为参数传递给该方法。\n\n责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。\n\n- 除了处理请求外，处理者还负责沿着链传递请求。\n- 请求会在链上移动，直至所有处理者都有机会对请求进行处理。\n\n最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。\n还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。\n\n- 如果自己能够处理，处理者就不再继续传递请求。\n- 在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理\n\n连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。\n\n- 对于第二种方式，感觉有些像观察者模式。\n- 两者具体实现、目的都差不多。主要区别在于：\n   - 观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可\n   - 责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理\n\n![image.png](/images/design-pattern/1.png)\n责任链模式的核心在于将处理对象整理成链路。\n# 适用场景\n\n- 程序需要使用不同方式处理请求\n   - 将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。\n- 当必须按顺序执行多个处理者时，可以使用该模式。\n   - 无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。\n- 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。\n   - 如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。\n# 实现步骤\n\n1. 声明处理者接口并提供请求处理方法的签名。\n   - 确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。\n2. 为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。\n   - 该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。\n   - 还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。\n3. 依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：\n   - 是否自行处理这个请求\n   - 是否将该请求沿着链进行传递\n4. 客户端可以自行组装链，或者从其他对象处获得预先组装好的链。\n   - 在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链\n5. 客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。\n6. 由于链的动态性，客户端需要处理以下情况：\n   - 部分请求可能无法到达链尾\n   - 其他请求可能直到链尾都未被处理\n# 优缺点\n优点：\n\n- 可以控制请求处理的顺序。\n- 单一职责原则。解耦了发起操作和执行操作的类。\n- 开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。\n\n缺点：\n\n- 部分请求最终可能都未被处理。\n# 与其它模式的关系\n\n- 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   - 责任链模式按照顺序将请求动态传递给一系列的潜在接收者。\n   - 命令模式在发送者和请求者之间建立单向连接。\n   - 中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。\n   - 观察者模式允许接收者动态地订阅或取消接收请求。\n- 责任链可以和组合模式结合使用\n   - 叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。\n- 责任链上的处理器可使用命令模式实现\n   - 可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   - 或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。\n- 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同\n   - 责任链上的处理器可以相互独立地执行，还可以随时停止传递请求\n   - 各种装饰可以在遵循基本接口的情况下扩展对象的行为\n   - 装饰无法中断请求的传递\n# 示例\n```cpp\n#include <iostream>\n#include <string>\n\n// 定义处理者接口\nclass Approver {\npublic:\nvirtual void processRequest(const std::string& request) = 0;\nvirtual ~Approver() {}\n};\n\n// 创建抽象处理者基类\nclass BaseApprover : public Approver {\nprivate:\nApprover* nextApprover;\n\npublic:\nBaseApprover() : nextApprover(nullptr) {}\n\n// 设置下一个处理者\nvoid setNextApprover(Approver* next) {\n    nextApprover = next;\n}\n\n// 处理请求的默认行为\nvoid processRequest(const std::string& request) override {\n    if (nextApprover != nullptr) {\n        nextApprover->processRequest(request);\n    } else {\n        std::cout << \"Request not handled by any approver.\" << std::endl;\n    }\n}\n};\n\n// 具体处理者子类：商品品控人员\nclass QualityControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"QualityCheck\") {\n        std::cout << \"QualityControlApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：供应商资质管理员\nclass SupplierQualificationApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"SupplierQualificationCheck\") {\n        std::cout << \"SupplierQualificationApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：上架风控人员\nclass RiskControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"MarketingRuleCheck\") {\n        std::cout << \"RiskControlApprover handles the request and approves the product for shelf.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\nint main() {\n    // 创建责任链\n    QualityControlApprover qualityControlApprover;\n    SupplierQualificationApprover supplierQualificationApprover;\n    RiskControlApprover riskControlApprover;\n\n    // 设置责任链顺序\n    qualityControlApprover.setNextApprover(&supplierQualificationApprover);\n    supplierQualificationApprover.setNextApprover(&riskControlApprover);\n\n    // 模拟商品上架流程\n    std::cout << \"Scenario 1:\" << std::endl;\n    qualityControlApprover.processRequest(\"QualityCheck\");\n\n    std::cout << \"\\nScenario 2:\" << std::endl;\n    qualityControlApprover.processRequest(\"SupplierQualificationCheck\");\n\n    std::cout << \"\\nScenario 3:\" << std::endl;\n    qualityControlApprover.processRequest(\"MarketingRuleCheck\");\n\n    std::cout << \"\\nScenario 4:\" << std::endl;\n    qualityControlApprover.processRequest(\"SomeOtherCheck\");\n\n    return 0;\n}\n\n```\n\n\n","slug":"Chain-of-responsibility","published":1,"updated":"2024-02-02T06:47:34.090Z","_id":"clrhz6rwf00010ox533q1ciw5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。<br>在设计之初有着足够简单的业务流程：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1</li>\n<li>供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：</p>\n<ol>\n<li>在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。</li>\n<li>对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。</li>\n<li>当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。</li>\n</ol>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。</p>\n<ul>\n<li>在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。</li>\n<li>请求及其数据则会被作为参数传递给该方法。</li>\n</ul>\n<p>责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。</p>\n<ul>\n<li>除了处理请求外，处理者还负责沿着链传递请求。</li>\n<li>请求会在链上移动，直至所有处理者都有机会对请求进行处理。</li>\n</ul>\n<p>最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。<br>还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。</p>\n<ul>\n<li>如果自己能够处理，处理者就不再继续传递请求。</li>\n<li>在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理</li>\n</ul>\n<p>连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。</p>\n<ul>\n<li>对于第二种方式，感觉有些像观察者模式。</li>\n<li>两者具体实现、目的都差不多。主要区别在于：<ul>\n<li>观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可</li>\n<li>责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/design-pattern/1.png\" alt=\"image.png\"><br>责任链模式的核心在于将处理对象整理成链路。</p>\n<h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><ul>\n<li>程序需要使用不同方式处理请求<ul>\n<li>将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。</li>\n</ul>\n</li>\n<li>当必须按顺序执行多个处理者时，可以使用该模式。<ul>\n<li>无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。</li>\n</ul>\n</li>\n<li>如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。<ul>\n<li>如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h1><ol>\n<li>声明处理者接口并提供请求处理方法的签名。<ul>\n<li>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</li>\n</ul>\n</li>\n<li>为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。<ul>\n<li>该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。</li>\n<li>还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。</li>\n</ul>\n</li>\n<li>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：<ul>\n<li>是否自行处理这个请求</li>\n<li>是否将该请求沿着链进行传递</li>\n</ul>\n</li>\n<li>客户端可以自行组装链，或者从其他对象处获得预先组装好的链。<ul>\n<li>在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链</li>\n</ul>\n</li>\n<li>客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。</li>\n<li>由于链的动态性，客户端需要处理以下情况：<ul>\n<li>部分请求可能无法到达链尾</li>\n<li>其他请求可能直到链尾都未被处理</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h1><p>优点：</p>\n<ul>\n<li>可以控制请求处理的顺序。</li>\n<li>单一职责原则。解耦了发起操作和执行操作的类。</li>\n<li>开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>部分请求最终可能都未被处理。</li>\n</ul>\n<h1 id=\"与其它模式的关系\"><a href=\"#与其它模式的关系\" class=\"headerlink\" title=\"与其它模式的关系\"></a>与其它模式的关系</h1><ul>\n<li>责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：<ul>\n<li>责任链模式按照顺序将请求动态传递给一系列的潜在接收者。</li>\n<li>命令模式在发送者和请求者之间建立单向连接。</li>\n<li>中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>\n<li>观察者模式允许接收者动态地订阅或取消接收请求。</li>\n</ul>\n</li>\n<li>责任链可以和组合模式结合使用<ul>\n<li>叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。</li>\n</ul>\n</li>\n<li>责任链上的处理器可使用命令模式实现<ul>\n<li>可以对由请求代表的同一个上下文对象执行许多不同的操作。</li>\n<li>或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。</li>\n</ul>\n</li>\n<li>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同<ul>\n<li>责任链上的处理器可以相互独立地执行，还可以随时停止传递请求</li>\n<li>各种装饰可以在遵循基本接口的情况下扩展对象的行为</li>\n<li>装饰无法中断请求的传递</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义处理者接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Approver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Approver</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建抽象处理者基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseApprover</span> : <span class=\"keyword\">public</span> Approver &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">Approver* nextApprover;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"built_in\">BaseApprover</span>() : <span class=\"built_in\">nextApprover</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置下一个处理者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNextApprover</span><span class=\"params\">(Approver* next)</span> </span>&#123;</span><br><span class=\"line\">    nextApprover = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理请求的默认行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextApprover != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        nextApprover-&gt;<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Request not handled by any approver.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：商品品控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QualityControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;QualityCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;QualityControlApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：供应商资质管理员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SupplierQualificationApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;SupplierQualificationApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：上架风控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RiskControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;MarketingRuleCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;RiskControlApprover handles the request and approves the product for shelf.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建责任链</span></span><br><span class=\"line\">    QualityControlApprover qualityControlApprover;</span><br><span class=\"line\">    SupplierQualificationApprover supplierQualificationApprover;</span><br><span class=\"line\">    RiskControlApprover riskControlApprover;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置责任链顺序</span></span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">setNextApprover</span>(&amp;supplierQualificationApprover);</span><br><span class=\"line\">    supplierQualificationApprover.<span class=\"built_in\">setNextApprover</span>(&amp;riskControlApprover);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟商品上架流程</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Scenario 1:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;QualityCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 2:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 3:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;MarketingRuleCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 4:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SomeOtherCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。<br>在设计之初有着足够简单的业务流程：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1</li>\n<li>供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：</p>\n<ol>\n<li>在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。</li>\n<li>对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。</li>\n<li>当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。</li>\n</ol>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。</p>\n<ul>\n<li>在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。</li>\n<li>请求及其数据则会被作为参数传递给该方法。</li>\n</ul>\n<p>责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。</p>\n<ul>\n<li>除了处理请求外，处理者还负责沿着链传递请求。</li>\n<li>请求会在链上移动，直至所有处理者都有机会对请求进行处理。</li>\n</ul>\n<p>最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。<br>还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。</p>\n<ul>\n<li>如果自己能够处理，处理者就不再继续传递请求。</li>\n<li>在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理</li>\n</ul>\n<p>连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。</p>\n<ul>\n<li>对于第二种方式，感觉有些像观察者模式。</li>\n<li>两者具体实现、目的都差不多。主要区别在于：<ul>\n<li>观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可</li>\n<li>责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/design-pattern/1.png\" alt=\"image.png\"><br>责任链模式的核心在于将处理对象整理成链路。</p>\n<h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><ul>\n<li>程序需要使用不同方式处理请求<ul>\n<li>将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。</li>\n</ul>\n</li>\n<li>当必须按顺序执行多个处理者时，可以使用该模式。<ul>\n<li>无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。</li>\n</ul>\n</li>\n<li>如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。<ul>\n<li>如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h1><ol>\n<li>声明处理者接口并提供请求处理方法的签名。<ul>\n<li>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</li>\n</ul>\n</li>\n<li>为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。<ul>\n<li>该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。</li>\n<li>还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。</li>\n</ul>\n</li>\n<li>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：<ul>\n<li>是否自行处理这个请求</li>\n<li>是否将该请求沿着链进行传递</li>\n</ul>\n</li>\n<li>客户端可以自行组装链，或者从其他对象处获得预先组装好的链。<ul>\n<li>在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链</li>\n</ul>\n</li>\n<li>客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。</li>\n<li>由于链的动态性，客户端需要处理以下情况：<ul>\n<li>部分请求可能无法到达链尾</li>\n<li>其他请求可能直到链尾都未被处理</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h1><p>优点：</p>\n<ul>\n<li>可以控制请求处理的顺序。</li>\n<li>单一职责原则。解耦了发起操作和执行操作的类。</li>\n<li>开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>部分请求最终可能都未被处理。</li>\n</ul>\n<h1 id=\"与其它模式的关系\"><a href=\"#与其它模式的关系\" class=\"headerlink\" title=\"与其它模式的关系\"></a>与其它模式的关系</h1><ul>\n<li>责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：<ul>\n<li>责任链模式按照顺序将请求动态传递给一系列的潜在接收者。</li>\n<li>命令模式在发送者和请求者之间建立单向连接。</li>\n<li>中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>\n<li>观察者模式允许接收者动态地订阅或取消接收请求。</li>\n</ul>\n</li>\n<li>责任链可以和组合模式结合使用<ul>\n<li>叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。</li>\n</ul>\n</li>\n<li>责任链上的处理器可使用命令模式实现<ul>\n<li>可以对由请求代表的同一个上下文对象执行许多不同的操作。</li>\n<li>或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。</li>\n</ul>\n</li>\n<li>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同<ul>\n<li>责任链上的处理器可以相互独立地执行，还可以随时停止传递请求</li>\n<li>各种装饰可以在遵循基本接口的情况下扩展对象的行为</li>\n<li>装饰无法中断请求的传递</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义处理者接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Approver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Approver</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建抽象处理者基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseApprover</span> : <span class=\"keyword\">public</span> Approver &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">Approver* nextApprover;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"built_in\">BaseApprover</span>() : <span class=\"built_in\">nextApprover</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置下一个处理者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNextApprover</span><span class=\"params\">(Approver* next)</span> </span>&#123;</span><br><span class=\"line\">    nextApprover = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理请求的默认行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextApprover != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        nextApprover-&gt;<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Request not handled by any approver.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：商品品控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QualityControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;QualityCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;QualityControlApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：供应商资质管理员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SupplierQualificationApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;SupplierQualificationApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：上架风控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RiskControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;MarketingRuleCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;RiskControlApprover handles the request and approves the product for shelf.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建责任链</span></span><br><span class=\"line\">    QualityControlApprover qualityControlApprover;</span><br><span class=\"line\">    SupplierQualificationApprover supplierQualificationApprover;</span><br><span class=\"line\">    RiskControlApprover riskControlApprover;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置责任链顺序</span></span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">setNextApprover</span>(&amp;supplierQualificationApprover);</span><br><span class=\"line\">    supplierQualificationApprover.<span class=\"built_in\">setNextApprover</span>(&amp;riskControlApprover);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟商品上架流程</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Scenario 1:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;QualityCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 2:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 3:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;MarketingRuleCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 4:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SomeOtherCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"迁移计划","date":"2023-12-01T18:45:20.000Z","_content":"\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n\n#### C++语法方面的一些个人笔记\n- ✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）\n- C++ 20以上的新特性\n\n#### 计算机体系结构下的读书笔记\n- 共享内存整理\n- 异步事件框架\n- ~~分布式一致性协议（挪到工作中的问题部分）~~\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n\n#### 探索过的编程模式\n\n- ✔无锁编程（存在一个版本的草稿，但是还需要优化）\n- 并发编程\n- ✔模版编程（存在一个版本的草稿，但是还需要优化）\n- 无分支编程\n- ✔缓存友好编程（存在一个版本的草稿，但是还需要优化）\n- 向量化编程\n\n#### 工作中遇到过的问题\n- linux下的高精度测时问题\n- 超线程导致的效率降低问题\n- grafana大量close_wait拖垮数据库\n- 分布式系统的一致性等级造成的异常\n\n#### 工作中部分项目的总结\n- ~~项目的稳定性治理~~\n- ~~重构项目的技巧与总结~~\n- ✔基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n\n#### 一些常用工具的学习和了解\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","source":"_posts/Todo-plans.md","raw":"---\ntitle: 迁移计划\ndate: 2023-12-02 02:45:20\ntags: Plan\n---\n\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n\n#### C++语法方面的一些个人笔记\n- ✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）\n- C++ 20以上的新特性\n\n#### 计算机体系结构下的读书笔记\n- 共享内存整理\n- 异步事件框架\n- ~~分布式一致性协议（挪到工作中的问题部分）~~\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n\n#### 探索过的编程模式\n\n- ✔无锁编程（存在一个版本的草稿，但是还需要优化）\n- 并发编程\n- ✔模版编程（存在一个版本的草稿，但是还需要优化）\n- 无分支编程\n- ✔缓存友好编程（存在一个版本的草稿，但是还需要优化）\n- 向量化编程\n\n#### 工作中遇到过的问题\n- linux下的高精度测时问题\n- 超线程导致的效率降低问题\n- grafana大量close_wait拖垮数据库\n- 分布式系统的一致性等级造成的异常\n\n#### 工作中部分项目的总结\n- ~~项目的稳定性治理~~\n- ~~重构项目的技巧与总结~~\n- ✔基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n\n#### 一些常用工具的学习和了解\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","slug":"Todo-plans","published":1,"updated":"2024-01-30T15:39:28.458Z","_id":"cls01gnk000001ax57sxn64hc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li><del>分布式一致性协议（挪到工作中的问题部分）</del></li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>✔无锁编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>并发编程</li>\n<li>✔模版编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>无分支编程</li>\n<li>✔缓存友好编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>向量化编程</li>\n</ul>\n<h4 id=\"工作中遇到过的问题\"><a href=\"#工作中遇到过的问题\" class=\"headerlink\" title=\"工作中遇到过的问题\"></a>工作中遇到过的问题</h4><ul>\n<li>linux下的高精度测时问题</li>\n<li>超线程导致的效率降低问题</li>\n<li>grafana大量close_wait拖垮数据库</li>\n<li>分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li><del>项目的稳定性治理</del></li>\n<li><del>重构项目的技巧与总结</del></li>\n<li>✔基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li><del>分布式一致性协议（挪到工作中的问题部分）</del></li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>✔无锁编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>并发编程</li>\n<li>✔模版编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>无分支编程</li>\n<li>✔缓存友好编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>向量化编程</li>\n</ul>\n<h4 id=\"工作中遇到过的问题\"><a href=\"#工作中遇到过的问题\" class=\"headerlink\" title=\"工作中遇到过的问题\"></a>工作中遇到过的问题</h4><ul>\n<li>linux下的高精度测时问题</li>\n<li>超线程导致的效率降低问题</li>\n<li>grafana大量close_wait拖垮数据库</li>\n<li>分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li><del>项目的稳定性治理</del></li>\n<li><del>重构项目的技巧与总结</del></li>\n<li>✔基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n"},{"title":"Git多路Merge原理","date":"2024-02-01T11:02:57.000Z","_content":"这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。\n# Git的组成\n## 工作区(workspace)\n就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。\n## 暂存区(index)\n老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。\n## 本地仓库(local repository)\ngit 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。\n## 远程仓库(remote repository)\n中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。\n# 状态模型\n## 状态流转![image.png](/images/git-note/1.png)\n## 文件变化\n![image.png](/images/git-note/2.png)\n# 存储模型\ngit 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。\nSvn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。\nGit 对文件版本的管理理念却是以每次提交为一次快照，提交时对**所有文件**做一次**全量快照**，然后**存储快照引用**。\nGit 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。\n如下图所示：\n![image.png](/images/git-note/3.png)\n# Merge算法\n## Q&A\n\n- Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?\n- A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。\n\n- git merge 只要两行不相同就一定会报冲突，叫人工解决?\n- 答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。\n\n## 合并算法\n### 二路合并\n二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n\n假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。\n### 三路合并\n三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。\n\n- Base 代表上一个版本，即公共祖先\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n- Merge 代表git进行merge后的结果\n#### 自动merge场景\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\nconsole.log(\"World Hello\");\n```\n这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA\n#### 手动merge场景\n需要手动merge的场景就是Mine和Theis都对相同的\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"World Flynn\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\n<<<<<<<Mine\nconsole.log(\"World Flynn\");\n=======\nconsole.log(\"World Hello\");\n>>>>>>>Theirs\n```\n在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。\n#### 三路合并示例\n![image.png](/images/git-note/4.png)\n\n1. 上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。\n2. ①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，**分支本质是一个快照。**\n3. 同样dev分支也是由一个个commit组成\n\n现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用**DAG(有向无环图)**相关算法找到我们**公共的祖先** ②（Base）然后进行**三方合并**，最后合并生成 ⑨\n```java\n//找出公共祖先的commitId(Base)\ngit merge-base --all commit_id1(Yours/Theirs) commit_id2(Yours/Theirs) \n```\n在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。\n![image.png](/images/git-note/5.png)\n### 递归三路合并\n#### 公共祖先不唯一问题\n**抽象化**\n```java\n       ---1---o---A\n           \\ /\n            X\n           / \\\n       ---2---o---o---B\n```\n**具体化**\n![image.png](/images/git-note/6.png)\n> （这部分图有点问题，阅读理解困难，可跳过直接看问题）\n> 简短描述下 如何会出现上面的图：\n> 1. 在master分支上新建文件foo.c ,写入数据\"A\"到文件里面\n> 2. 新建分支task2 **git checkout -b task2 0**,0 代表commit Id\n> 3. 新建并提交commit ① 和 ③\n> 4. 切换分支到master，新建并提交commit ②\n> 5. 新建并修改foo.c文件中数据为\"B\",并提交commit ④\n> 6. merge commit ③ **git merge task2**,生成commit ⑥\n> 7. 新建分支task1 **git chekcout -b ④**\n> 8. 在task1 merge ③ **git merge task2** 生成commit ⑤\n> 9. 新建commit ⑦，并修改foo.c文件内容为\"C\"\n> 10. 切换分支到master上，并准备merge task1 分支(merge ⑦-> ⑥)\n\n\n我们如果要合并 ⑦(source) -> ⑥(destination)\n会发现有⑥和⑦有两个最佳公共祖先③和④\n以③为公共祖先时需要手动解决冲突 /foo.c = BC???\n![image.png](/images/git-note/7.png)\n以④作为公共祖先将得到 /foo.c=C\n![image.png](/images/git-note/8.png)\n#### git解法\ngit 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X /foo.c = B。因为③ 和 ④ 公共祖先是 0/foo.c = A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X /foo.c = B。\n![image.png](/images/git-note/9.png)\n","source":"_posts/Git-note.md","raw":"---\ntitle: Git多路Merge原理\ndate: 2024-02-01 19:02:57\ntags: 学习杂记\n---\n这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。\n# Git的组成\n## 工作区(workspace)\n就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。\n## 暂存区(index)\n老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。\n## 本地仓库(local repository)\ngit 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。\n## 远程仓库(remote repository)\n中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。\n# 状态模型\n## 状态流转![image.png](/images/git-note/1.png)\n## 文件变化\n![image.png](/images/git-note/2.png)\n# 存储模型\ngit 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。\nSvn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。\nGit 对文件版本的管理理念却是以每次提交为一次快照，提交时对**所有文件**做一次**全量快照**，然后**存储快照引用**。\nGit 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。\n如下图所示：\n![image.png](/images/git-note/3.png)\n# Merge算法\n## Q&A\n\n- Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?\n- A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。\n\n- git merge 只要两行不相同就一定会报冲突，叫人工解决?\n- 答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。\n\n## 合并算法\n### 二路合并\n二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n\n假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。\n### 三路合并\n三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。\n\n- Base 代表上一个版本，即公共祖先\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n- Merge 代表git进行merge后的结果\n#### 自动merge场景\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\nconsole.log(\"World Hello\");\n```\n这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA\n#### 手动merge场景\n需要手动merge的场景就是Mine和Theis都对相同的\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"World Flynn\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\n<<<<<<<Mine\nconsole.log(\"World Flynn\");\n=======\nconsole.log(\"World Hello\");\n>>>>>>>Theirs\n```\n在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。\n#### 三路合并示例\n![image.png](/images/git-note/4.png)\n\n1. 上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。\n2. ①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，**分支本质是一个快照。**\n3. 同样dev分支也是由一个个commit组成\n\n现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用**DAG(有向无环图)**相关算法找到我们**公共的祖先** ②（Base）然后进行**三方合并**，最后合并生成 ⑨\n```java\n//找出公共祖先的commitId(Base)\ngit merge-base --all commit_id1(Yours/Theirs) commit_id2(Yours/Theirs) \n```\n在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。\n![image.png](/images/git-note/5.png)\n### 递归三路合并\n#### 公共祖先不唯一问题\n**抽象化**\n```java\n       ---1---o---A\n           \\ /\n            X\n           / \\\n       ---2---o---o---B\n```\n**具体化**\n![image.png](/images/git-note/6.png)\n> （这部分图有点问题，阅读理解困难，可跳过直接看问题）\n> 简短描述下 如何会出现上面的图：\n> 1. 在master分支上新建文件foo.c ,写入数据\"A\"到文件里面\n> 2. 新建分支task2 **git checkout -b task2 0**,0 代表commit Id\n> 3. 新建并提交commit ① 和 ③\n> 4. 切换分支到master，新建并提交commit ②\n> 5. 新建并修改foo.c文件中数据为\"B\",并提交commit ④\n> 6. merge commit ③ **git merge task2**,生成commit ⑥\n> 7. 新建分支task1 **git chekcout -b ④**\n> 8. 在task1 merge ③ **git merge task2** 生成commit ⑤\n> 9. 新建commit ⑦，并修改foo.c文件内容为\"C\"\n> 10. 切换分支到master上，并准备merge task1 分支(merge ⑦-> ⑥)\n\n\n我们如果要合并 ⑦(source) -> ⑥(destination)\n会发现有⑥和⑦有两个最佳公共祖先③和④\n以③为公共祖先时需要手动解决冲突 /foo.c = BC???\n![image.png](/images/git-note/7.png)\n以④作为公共祖先将得到 /foo.c=C\n![image.png](/images/git-note/8.png)\n#### git解法\ngit 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X /foo.c = B。因为③ 和 ④ 公共祖先是 0/foo.c = A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X /foo.c = B。\n![image.png](/images/git-note/9.png)\n","slug":"Git-note","published":1,"updated":"2024-02-01T15:44:22.156Z","_id":"cls34916b0000ynx57dh67tl8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。</p>\n<h1 id=\"Git的组成\"><a href=\"#Git的组成\" class=\"headerlink\" title=\"Git的组成\"></a>Git的组成</h1><h2 id=\"工作区-workspace\"><a href=\"#工作区-workspace\" class=\"headerlink\" title=\"工作区(workspace)\"></a>工作区(workspace)</h2><p>就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。</p>\n<h2 id=\"暂存区-index\"><a href=\"#暂存区-index\" class=\"headerlink\" title=\"暂存区(index)\"></a>暂存区(index)</h2><p>老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。</p>\n<h2 id=\"本地仓库-local-repository\"><a href=\"#本地仓库-local-repository\" class=\"headerlink\" title=\"本地仓库(local repository)\"></a>本地仓库(local repository)</h2><p>git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p>\n<h2 id=\"远程仓库-remote-repository\"><a href=\"#远程仓库-remote-repository\" class=\"headerlink\" title=\"远程仓库(remote repository)\"></a>远程仓库(remote repository)</h2><p>中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p>\n<h1 id=\"状态模型\"><a href=\"#状态模型\" class=\"headerlink\" title=\"状态模型\"></a>状态模型</h1><h2 id=\"状态流转\"><a href=\"#状态流转\" class=\"headerlink\" title=\"状态流转\"></a>状态流转<img src=\"/images/git-note/1.png\" alt=\"image.png\"></h2><h2 id=\"文件变化\"><a href=\"#文件变化\" class=\"headerlink\" title=\"文件变化\"></a>文件变化</h2><p><img src=\"/images/git-note/2.png\" alt=\"image.png\"></p>\n<h1 id=\"存储模型\"><a href=\"#存储模型\" class=\"headerlink\" title=\"存储模型\"></a>存储模型</h1><p>git 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。<br>Svn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。<br>Git 对文件版本的管理理念却是以每次提交为一次快照，提交时对<strong>所有文件</strong>做一次<strong>全量快照</strong>，然后<strong>存储快照引用</strong>。<br>Git 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。<br>如下图所示：<br><img src=\"/images/git-note/3.png\" alt=\"image.png\"></p>\n<h1 id=\"Merge算法\"><a href=\"#Merge算法\" class=\"headerlink\" title=\"Merge算法\"></a>Merge算法</h1><h2 id=\"Q-A\"><a href=\"#Q-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li><p>Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?</p>\n</li>\n<li><p>A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。</p>\n</li>\n<li><p>git merge 只要两行不相同就一定会报冲突，叫人工解决?</p>\n</li>\n<li><p>答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。</p>\n</li>\n</ul>\n<h2 id=\"合并算法\"><a href=\"#合并算法\" class=\"headerlink\" title=\"合并算法\"></a>合并算法</h2><h3 id=\"二路合并\"><a href=\"#二路合并\" class=\"headerlink\" title=\"二路合并\"></a>二路合并</h3><p>二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n</ul>\n<p>假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。</p>\n<h3 id=\"三路合并\"><a href=\"#三路合并\" class=\"headerlink\" title=\"三路合并\"></a>三路合并</h3><p>三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。</p>\n<ul>\n<li>Base 代表上一个版本，即公共祖先</li>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n<li>Merge 代表git进行merge后的结果</li>\n</ul>\n<h4 id=\"自动merge场景\"><a href=\"#自动merge场景\" class=\"headerlink\" title=\"自动merge场景\"></a>自动merge场景</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA</p>\n<h4 id=\"手动merge场景\"><a href=\"#手动merge场景\" class=\"headerlink\" title=\"手动merge场景\"></a>手动merge场景</h4><p>需要手动merge的场景就是Mine和Theis都对相同的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;Mine</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br><span class=\"line\">=======</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;Theirs</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。</p>\n<h4 id=\"三路合并示例\"><a href=\"#三路合并示例\" class=\"headerlink\" title=\"三路合并示例\"></a>三路合并示例</h4><p><img src=\"/images/git-note/4.png\" alt=\"image.png\"></p>\n<ol>\n<li>上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。</li>\n<li>①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，<strong>分支本质是一个快照。</strong></li>\n<li>同样dev分支也是由一个个commit组成</li>\n</ol>\n<p>现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用<strong>DAG(有向无环图)<strong>相关算法找到我们</strong>公共的祖先</strong> ②（Base）然后进行<strong>三方合并</strong>，最后合并生成 ⑨</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找出公共祖先的commitId(Base)</span></span><br><span class=\"line\">git merge-base --all <span class=\"title function_\">commit_id1</span><span class=\"params\">(Yours/Theirs)</span> commit_id2(Yours/Theirs) </span><br></pre></td></tr></table></figure>\n<p>在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。<br><img src=\"/images/git-note/5.png\" alt=\"image.png\"></p>\n<h3 id=\"递归三路合并\"><a href=\"#递归三路合并\" class=\"headerlink\" title=\"递归三路合并\"></a>递归三路合并</h3><h4 id=\"公共祖先不唯一问题\"><a href=\"#公共祖先不唯一问题\" class=\"headerlink\" title=\"公共祖先不唯一问题\"></a>公共祖先不唯一问题</h4><p><strong>抽象化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---<span class=\"number\">1</span>---o---A</span><br><span class=\"line\">    \\ /</span><br><span class=\"line\">     X</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">---<span class=\"number\">2</span>---o---o---B</span><br></pre></td></tr></table></figure>\n<p><strong>具体化</strong><br><img src=\"/images/git-note/6.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>（这部分图有点问题，阅读理解困难，可跳过直接看问题）<br>简短描述下 如何会出现上面的图：</p>\n<ol>\n<li>在master分支上新建文件foo.c ,写入数据”A”到文件里面</li>\n<li>新建分支task2 <strong>git checkout -b task2 0</strong>,0 代表commit Id</li>\n<li>新建并提交commit ① 和 ③</li>\n<li>切换分支到master，新建并提交commit ②</li>\n<li>新建并修改foo.c文件中数据为”B”,并提交commit ④</li>\n<li>merge commit ③ <strong>git merge task2</strong>,生成commit ⑥</li>\n<li>新建分支task1 <strong>git chekcout -b ④</strong></li>\n<li>在task1 merge ③ <strong>git merge task2</strong> 生成commit ⑤</li>\n<li>新建commit ⑦，并修改foo.c文件内容为”C”</li>\n<li>切换分支到master上，并准备merge task1 分支(merge ⑦-&gt; ⑥)</li>\n</ol>\n</blockquote>\n<p>我们如果要合并 ⑦(source) -&gt; ⑥(destination)<br>会发现有⑥和⑦有两个最佳公共祖先③和④<br>以③为公共祖先时需要手动解决冲突 &#x2F;foo.c &#x3D; BC???<br><img src=\"/images/git-note/7.png\" alt=\"image.png\"><br>以④作为公共祖先将得到 &#x2F;foo.c&#x3D;C<br><img src=\"/images/git-note/8.png\" alt=\"image.png\"></p>\n<h4 id=\"git解法\"><a href=\"#git解法\" class=\"headerlink\" title=\"git解法\"></a>git解法</h4><p>git 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X &#x2F;foo.c &#x3D; B。因为③ 和 ④ 公共祖先是 0&#x2F;foo.c &#x3D; A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X &#x2F;foo.c &#x3D; B。<br><img src=\"/images/git-note/9.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。</p>\n<h1 id=\"Git的组成\"><a href=\"#Git的组成\" class=\"headerlink\" title=\"Git的组成\"></a>Git的组成</h1><h2 id=\"工作区-workspace\"><a href=\"#工作区-workspace\" class=\"headerlink\" title=\"工作区(workspace)\"></a>工作区(workspace)</h2><p>就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。</p>\n<h2 id=\"暂存区-index\"><a href=\"#暂存区-index\" class=\"headerlink\" title=\"暂存区(index)\"></a>暂存区(index)</h2><p>老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。</p>\n<h2 id=\"本地仓库-local-repository\"><a href=\"#本地仓库-local-repository\" class=\"headerlink\" title=\"本地仓库(local repository)\"></a>本地仓库(local repository)</h2><p>git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p>\n<h2 id=\"远程仓库-remote-repository\"><a href=\"#远程仓库-remote-repository\" class=\"headerlink\" title=\"远程仓库(remote repository)\"></a>远程仓库(remote repository)</h2><p>中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p>\n<h1 id=\"状态模型\"><a href=\"#状态模型\" class=\"headerlink\" title=\"状态模型\"></a>状态模型</h1><h2 id=\"状态流转\"><a href=\"#状态流转\" class=\"headerlink\" title=\"状态流转\"></a>状态流转<img src=\"/images/git-note/1.png\" alt=\"image.png\"></h2><h2 id=\"文件变化\"><a href=\"#文件变化\" class=\"headerlink\" title=\"文件变化\"></a>文件变化</h2><p><img src=\"/images/git-note/2.png\" alt=\"image.png\"></p>\n<h1 id=\"存储模型\"><a href=\"#存储模型\" class=\"headerlink\" title=\"存储模型\"></a>存储模型</h1><p>git 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。<br>Svn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。<br>Git 对文件版本的管理理念却是以每次提交为一次快照，提交时对<strong>所有文件</strong>做一次<strong>全量快照</strong>，然后<strong>存储快照引用</strong>。<br>Git 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。<br>如下图所示：<br><img src=\"/images/git-note/3.png\" alt=\"image.png\"></p>\n<h1 id=\"Merge算法\"><a href=\"#Merge算法\" class=\"headerlink\" title=\"Merge算法\"></a>Merge算法</h1><h2 id=\"Q-A\"><a href=\"#Q-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li><p>Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?</p>\n</li>\n<li><p>A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。</p>\n</li>\n<li><p>git merge 只要两行不相同就一定会报冲突，叫人工解决?</p>\n</li>\n<li><p>答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。</p>\n</li>\n</ul>\n<h2 id=\"合并算法\"><a href=\"#合并算法\" class=\"headerlink\" title=\"合并算法\"></a>合并算法</h2><h3 id=\"二路合并\"><a href=\"#二路合并\" class=\"headerlink\" title=\"二路合并\"></a>二路合并</h3><p>二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n</ul>\n<p>假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。</p>\n<h3 id=\"三路合并\"><a href=\"#三路合并\" class=\"headerlink\" title=\"三路合并\"></a>三路合并</h3><p>三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。</p>\n<ul>\n<li>Base 代表上一个版本，即公共祖先</li>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n<li>Merge 代表git进行merge后的结果</li>\n</ul>\n<h4 id=\"自动merge场景\"><a href=\"#自动merge场景\" class=\"headerlink\" title=\"自动merge场景\"></a>自动merge场景</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA</p>\n<h4 id=\"手动merge场景\"><a href=\"#手动merge场景\" class=\"headerlink\" title=\"手动merge场景\"></a>手动merge场景</h4><p>需要手动merge的场景就是Mine和Theis都对相同的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;Mine</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br><span class=\"line\">=======</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;Theirs</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。</p>\n<h4 id=\"三路合并示例\"><a href=\"#三路合并示例\" class=\"headerlink\" title=\"三路合并示例\"></a>三路合并示例</h4><p><img src=\"/images/git-note/4.png\" alt=\"image.png\"></p>\n<ol>\n<li>上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。</li>\n<li>①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，<strong>分支本质是一个快照。</strong></li>\n<li>同样dev分支也是由一个个commit组成</li>\n</ol>\n<p>现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用<strong>DAG(有向无环图)<strong>相关算法找到我们</strong>公共的祖先</strong> ②（Base）然后进行<strong>三方合并</strong>，最后合并生成 ⑨</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找出公共祖先的commitId(Base)</span></span><br><span class=\"line\">git merge-base --all <span class=\"title function_\">commit_id1</span><span class=\"params\">(Yours/Theirs)</span> commit_id2(Yours/Theirs) </span><br></pre></td></tr></table></figure>\n<p>在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。<br><img src=\"/images/git-note/5.png\" alt=\"image.png\"></p>\n<h3 id=\"递归三路合并\"><a href=\"#递归三路合并\" class=\"headerlink\" title=\"递归三路合并\"></a>递归三路合并</h3><h4 id=\"公共祖先不唯一问题\"><a href=\"#公共祖先不唯一问题\" class=\"headerlink\" title=\"公共祖先不唯一问题\"></a>公共祖先不唯一问题</h4><p><strong>抽象化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---<span class=\"number\">1</span>---o---A</span><br><span class=\"line\">    \\ /</span><br><span class=\"line\">     X</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">---<span class=\"number\">2</span>---o---o---B</span><br></pre></td></tr></table></figure>\n<p><strong>具体化</strong><br><img src=\"/images/git-note/6.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>（这部分图有点问题，阅读理解困难，可跳过直接看问题）<br>简短描述下 如何会出现上面的图：</p>\n<ol>\n<li>在master分支上新建文件foo.c ,写入数据”A”到文件里面</li>\n<li>新建分支task2 <strong>git checkout -b task2 0</strong>,0 代表commit Id</li>\n<li>新建并提交commit ① 和 ③</li>\n<li>切换分支到master，新建并提交commit ②</li>\n<li>新建并修改foo.c文件中数据为”B”,并提交commit ④</li>\n<li>merge commit ③ <strong>git merge task2</strong>,生成commit ⑥</li>\n<li>新建分支task1 <strong>git chekcout -b ④</strong></li>\n<li>在task1 merge ③ <strong>git merge task2</strong> 生成commit ⑤</li>\n<li>新建commit ⑦，并修改foo.c文件内容为”C”</li>\n<li>切换分支到master上，并准备merge task1 分支(merge ⑦-&gt; ⑥)</li>\n</ol>\n</blockquote>\n<p>我们如果要合并 ⑦(source) -&gt; ⑥(destination)<br>会发现有⑥和⑦有两个最佳公共祖先③和④<br>以③为公共祖先时需要手动解决冲突 &#x2F;foo.c &#x3D; BC???<br><img src=\"/images/git-note/7.png\" alt=\"image.png\"><br>以④作为公共祖先将得到 &#x2F;foo.c&#x3D;C<br><img src=\"/images/git-note/8.png\" alt=\"image.png\"></p>\n<h4 id=\"git解法\"><a href=\"#git解法\" class=\"headerlink\" title=\"git解法\"></a>git解法</h4><p>git 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X &#x2F;foo.c &#x3D; B。因为③ 和 ④ 公共祖先是 0&#x2F;foo.c &#x3D; A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X &#x2F;foo.c &#x3D; B。<br><img src=\"/images/git-note/9.png\" alt=\"image.png\"></p>\n"},{"title":"如何重构一个项目","date":"2024-02-01T16:14:01.000Z","_content":"任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。\n# 什么是重构\n> 重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。\n\n\n根据重构的规模程度、时间长短，我们可以将代码重构分为**小型重构**和**大型重构**。\n\n**小型重构**：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。\n\n**大型重构**：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行**服务分层、业务模块化、组件化、代码抽象复用**等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。\n\n其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：\n\n- 不知道怎么重构、缺乏重构的经验和方法论。\n- 很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。\n- 重构可能会破坏现有程序，带来意想不到的bug。\n- 重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。\n\n# 为什么要重构\n程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： \n\n- **让软件架构始终保持良好的设计。**改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。\n- **增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。**无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。\n- **提高研发速度、缩短人力成本。**大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。\n\n![image.png](/images/refactor-project/1.png)\n# 怎么进行重构\n## 小型重构\n小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。\n### 业务语义显性化\n优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。\n如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。\n**原代码**\n```java\nif(!PvgContext.getCrmUserId().equals(NIL_VALUE) && icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)\n {\n     //业务逻辑        \n }\n```\n**重构后**\n```java\nif(canPickUpToPrivateSea())\n {\n     //业务逻辑        \n }\n\n //判断客户能否捡私入海\n private boolean canPickUpToPrivateSea(){\n     if(StringUtil.isBlank(PvgContext.getCrmUserId())){\n         return false;\n     }\n     if(this.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP){\n         return false;\n     }\n     return true;\n }\n```\n### 泛型问题\n```java\n//为了大家理解方便，增加了一些注释\n\n//msg是从MQ消费到消息\nMap ps = JSON.parseObject(msg); //\nString mobile = \"xxx\"；\nps.put(\"driverNumber\", mobile);\n……\n// 对ps进行操作\nSet<String> keySet = (Set<String>)ps.keySet();\nif (keySet.contains(\"driverPrice\") && ps.get(\"driverPrice\") != null) {\n\tObject factPrice = ps.get(\"driverPrice\");\n  if (factPrice instanceof BigDecimal) { 【1】\n  \tps.put(\"driverPrice\", String.format(\"%.2f\",((BigDecimal)factPrice).doubleValue()));\n  } else if (factPrice instanceof String) { 【2】\n  \tBigDecimal refund = new BigDecimal((String)factPrice);\n    ps.put(\"refundPrice\", refund.stripTrailingZeros().toPlainString());\n  }\n}\nif (keySet.contains(ORDER_TIP_PRICE) && ps.get(ORDER_TIP_PRICE) != null) {\n\tif (ps.get(ORDER_TIP_PRICE) instanceof BigDecimal) { 【3】\n  \tBigDecimal tipPrice = (BigDecimal)ps.get(ORDER_TIP_PRICE);\n    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));\n  }\n}\n……\n// 将ps作为传输传递给服务内部底层接口\nmsgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);\n\n//看一下底层接口定义\nvoid innerOrderTempMessage(String msg, Map<String, String> ps, PushOrderTotalVO vo);\n```\n这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map<String, String>限定的接口中就是有很大的问题的，未来底层接口使用String value = ps.get(XXX)获取一个非String类型时就会出现类型转换异常。\n### 无病呻吟\n```java\nConfig config = new Config();\n// 设置name和md5\nconfig.setName(item.getName());\nconfig.setMd5(item.getMd5());\n// 设置值\nconfig.setTypeMap(map);\n// 打印日志\nLOGGER.info(\"update done ({},{}), start replace\", getName(), getMd5());\n\n\n......\n\nExpiredConfig expireConfig = ConfigManager.getExpiredConfig();\n// 为空初始化\nif (Objects.isNull(expireConfig)) {\n  expireConfig = new ExpiredConfig();\n}\n\n......\nMap<String, List<TypeItem>> typeMap = ……;   \nMap<String, Map<String, Map<String, List<Map<String, Object>>>>> jsonMap = new HashMap<>();\n\n// 循环一级map\njsonMap.forEach((k1, v1) -> {\n    // 循环里面的二级map\n    v1.forEach((k2, v2) -> {\n        // 循环里面的三级map\n        v2.forEach((k3, v3) -> {\n            // 循环最里面的list,哎！\n            v3.forEach(e -> {\n                // 生成key\n                String ck = getKey(k1, k2, k3);\n                // 为空处理\n                List<TypeItem> types = typeMap.get(ck);\n                if (CollectionUtils.isEmpty(types)) {\n                    types = new ArrayList<>();\n                    typeMap.put(ck, types);\n                }\n                // 设置类型\n            }\n       }\n  }\n}\n```\n代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。\n### if-else过多\n```java\n// 下面截取的get25000OrderState的部分代码\nprivate static List<String> get25000OrderState(OrderTotalVO orderTotalVO) {\n    String mainState = String.valueOf(orderTotalVO.getOrderState());\n    String state = String.valueOf(orderTotalVO.getOrderState());\n    List<String> stateList = Lists.newArrayList();\n\n    ……\n\n    DispatchType dispatchType = DispatchType.getEnum(orderTotalVO.getDispatchType());\n    ServiceType serviceType = ServiceType.typeOf(orderTotalVO.getServiceType());\n    if (serviceType == ServiceType.CHARTERED_CAR) {\n        state = state + \"_\" + serviceType;\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = state + \"_dispatch\";\n        } else if(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties())){\t\tstate = state + \"_\" + dispatchType.getCode() + \"_phoneCall\";                                                                                   } else {\n            state = state + \"_\" + dispatchType.getCode() + \"_\" + pastOrderId;\n            if(isHighQuality(orderTotalVO.getHighQualityFlag()) && DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode()){\n                state += \"_highQuality\";\n            }\n        }\n    }\n    stateList.add(state);\n    if (isOtherPassengerOrder(orderTotalVO)) {\n        state = mainState + \"_\" + \"forOther_aly\";\n        stateList.add(state);\n    }\n    BigDecimal tickOtherPrice = orderTotalVO.getTicketOtherPrice();\n    if (tickOtherPrice != null && BigDecimal.ZERO.compareTo(tickOtherPrice) < 0) {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketOtherPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketOtherPrice\";\n        }\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketPrice\";\n        }\n    }\n    stateList.add(state);\n\t……\n    return stateList;\n}\n```\n这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。\n\n### 重复代码\n代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。\n\n最常见的一种重复场景就是在“**同一个类的两个函数含有相同的表达式**”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。\n还有一种和这类场景相似，就是在“**两个互为兄弟的子类含有相同的表达式**”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。\n\n### 单一功能职责\n```java\n@Data\npublic class BuyerInfoParam {\n    // Required Param\n    private Long buyerCompanyId;\n    private Long buyerAccountId;\n    private Long callerCompanyId;\n    private Long callerAccountId;\n\n    private String tenantId;\n    private String bizCode;\n    private String channel; //这个Channel在查询中不起任何作用，不应该放在这里\n}\n```\n功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。\n可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。\n那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。\nTips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。\n### 其他问题\n#### 函数过长\n一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。\n#### 命名规范\n一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。\n#### 不合理的注释\n注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。\n#### 无用代码\n无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。\n#### 过大的类\n一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。\n\n## 大型重构\n![image.png](/images/refactor-project/2.png)\n### 事前准备\n事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。\n在这个阶段大致可分为三步：\n\n- **明确重构的内容、目的以及方向、目标**\n\n在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。\n\n- **整理数据**\n\n这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。\n附上整个系统的架构和此次重点重构的部分（深色标记部分）\n![image.png](/images/refactor-project/3.png)\n\n- **项目立项**\n\n项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。\n注意：会议结束后需要进行会议纪要邮件周知。\n### 事中执行\n事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。\n\n- **架构设计与评审**\n\n架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。\n该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。\n\n- **详细落地设计方案与评审**\n\n这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。\n在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：\n![image.png](/images/refactor-project/4.png)\n在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。\n在AB程序中，会涉及到两个开关。**灰度开关**（只有它开启了，请求才会被发送到新的流程中进行代码执行）。**执行开关**（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。\n\n- **代码的编写、测试、线下实施**\n\n这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。\n### \n### 事后观测与复盘\n这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。\n\n- **灰度开关流程**\n\n逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。\n\n- **业务执行开关流程**\n\n在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。\n放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。\n\n# 总结\n## 代码技巧\n\n- 写代码的时候遵循一些基本原则，比如单一原则、依赖接口/抽象而不是依赖具体实现。\n- 严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。\n- 单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。\n- 我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。\n- 不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。\n## 重构技巧\n\n- 从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。\n- 提炼类，复用函数，下沉核心能力，让模块职责清晰明了。\n- 依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。\n- 类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。\n- 大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。\n\n代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：\n1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力\n2、代码洁癖、工匠精神\n3、产品思维\n\n","source":"_posts/Refactor-project.md","raw":"---\ntitle: 如何重构一个项目\ndate: 2024-02-02 00:14:01\ntags: 学习杂记\n---\n任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。\n# 什么是重构\n> 重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。\n\n\n根据重构的规模程度、时间长短，我们可以将代码重构分为**小型重构**和**大型重构**。\n\n**小型重构**：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。\n\n**大型重构**：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行**服务分层、业务模块化、组件化、代码抽象复用**等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。\n\n其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：\n\n- 不知道怎么重构、缺乏重构的经验和方法论。\n- 很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。\n- 重构可能会破坏现有程序，带来意想不到的bug。\n- 重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。\n\n# 为什么要重构\n程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： \n\n- **让软件架构始终保持良好的设计。**改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。\n- **增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。**无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。\n- **提高研发速度、缩短人力成本。**大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。\n\n![image.png](/images/refactor-project/1.png)\n# 怎么进行重构\n## 小型重构\n小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。\n### 业务语义显性化\n优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。\n如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。\n**原代码**\n```java\nif(!PvgContext.getCrmUserId().equals(NIL_VALUE) && icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)\n {\n     //业务逻辑        \n }\n```\n**重构后**\n```java\nif(canPickUpToPrivateSea())\n {\n     //业务逻辑        \n }\n\n //判断客户能否捡私入海\n private boolean canPickUpToPrivateSea(){\n     if(StringUtil.isBlank(PvgContext.getCrmUserId())){\n         return false;\n     }\n     if(this.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP){\n         return false;\n     }\n     return true;\n }\n```\n### 泛型问题\n```java\n//为了大家理解方便，增加了一些注释\n\n//msg是从MQ消费到消息\nMap ps = JSON.parseObject(msg); //\nString mobile = \"xxx\"；\nps.put(\"driverNumber\", mobile);\n……\n// 对ps进行操作\nSet<String> keySet = (Set<String>)ps.keySet();\nif (keySet.contains(\"driverPrice\") && ps.get(\"driverPrice\") != null) {\n\tObject factPrice = ps.get(\"driverPrice\");\n  if (factPrice instanceof BigDecimal) { 【1】\n  \tps.put(\"driverPrice\", String.format(\"%.2f\",((BigDecimal)factPrice).doubleValue()));\n  } else if (factPrice instanceof String) { 【2】\n  \tBigDecimal refund = new BigDecimal((String)factPrice);\n    ps.put(\"refundPrice\", refund.stripTrailingZeros().toPlainString());\n  }\n}\nif (keySet.contains(ORDER_TIP_PRICE) && ps.get(ORDER_TIP_PRICE) != null) {\n\tif (ps.get(ORDER_TIP_PRICE) instanceof BigDecimal) { 【3】\n  \tBigDecimal tipPrice = (BigDecimal)ps.get(ORDER_TIP_PRICE);\n    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));\n  }\n}\n……\n// 将ps作为传输传递给服务内部底层接口\nmsgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);\n\n//看一下底层接口定义\nvoid innerOrderTempMessage(String msg, Map<String, String> ps, PushOrderTotalVO vo);\n```\n这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map<String, String>限定的接口中就是有很大的问题的，未来底层接口使用String value = ps.get(XXX)获取一个非String类型时就会出现类型转换异常。\n### 无病呻吟\n```java\nConfig config = new Config();\n// 设置name和md5\nconfig.setName(item.getName());\nconfig.setMd5(item.getMd5());\n// 设置值\nconfig.setTypeMap(map);\n// 打印日志\nLOGGER.info(\"update done ({},{}), start replace\", getName(), getMd5());\n\n\n......\n\nExpiredConfig expireConfig = ConfigManager.getExpiredConfig();\n// 为空初始化\nif (Objects.isNull(expireConfig)) {\n  expireConfig = new ExpiredConfig();\n}\n\n......\nMap<String, List<TypeItem>> typeMap = ……;   \nMap<String, Map<String, Map<String, List<Map<String, Object>>>>> jsonMap = new HashMap<>();\n\n// 循环一级map\njsonMap.forEach((k1, v1) -> {\n    // 循环里面的二级map\n    v1.forEach((k2, v2) -> {\n        // 循环里面的三级map\n        v2.forEach((k3, v3) -> {\n            // 循环最里面的list,哎！\n            v3.forEach(e -> {\n                // 生成key\n                String ck = getKey(k1, k2, k3);\n                // 为空处理\n                List<TypeItem> types = typeMap.get(ck);\n                if (CollectionUtils.isEmpty(types)) {\n                    types = new ArrayList<>();\n                    typeMap.put(ck, types);\n                }\n                // 设置类型\n            }\n       }\n  }\n}\n```\n代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。\n### if-else过多\n```java\n// 下面截取的get25000OrderState的部分代码\nprivate static List<String> get25000OrderState(OrderTotalVO orderTotalVO) {\n    String mainState = String.valueOf(orderTotalVO.getOrderState());\n    String state = String.valueOf(orderTotalVO.getOrderState());\n    List<String> stateList = Lists.newArrayList();\n\n    ……\n\n    DispatchType dispatchType = DispatchType.getEnum(orderTotalVO.getDispatchType());\n    ServiceType serviceType = ServiceType.typeOf(orderTotalVO.getServiceType());\n    if (serviceType == ServiceType.CHARTERED_CAR) {\n        state = state + \"_\" + serviceType;\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = state + \"_dispatch\";\n        } else if(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties())){\t\tstate = state + \"_\" + dispatchType.getCode() + \"_phoneCall\";                                                                                   } else {\n            state = state + \"_\" + dispatchType.getCode() + \"_\" + pastOrderId;\n            if(isHighQuality(orderTotalVO.getHighQualityFlag()) && DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode()){\n                state += \"_highQuality\";\n            }\n        }\n    }\n    stateList.add(state);\n    if (isOtherPassengerOrder(orderTotalVO)) {\n        state = mainState + \"_\" + \"forOther_aly\";\n        stateList.add(state);\n    }\n    BigDecimal tickOtherPrice = orderTotalVO.getTicketOtherPrice();\n    if (tickOtherPrice != null && BigDecimal.ZERO.compareTo(tickOtherPrice) < 0) {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketOtherPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketOtherPrice\";\n        }\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketPrice\";\n        }\n    }\n    stateList.add(state);\n\t……\n    return stateList;\n}\n```\n这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。\n\n### 重复代码\n代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。\n\n最常见的一种重复场景就是在“**同一个类的两个函数含有相同的表达式**”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。\n还有一种和这类场景相似，就是在“**两个互为兄弟的子类含有相同的表达式**”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。\n\n### 单一功能职责\n```java\n@Data\npublic class BuyerInfoParam {\n    // Required Param\n    private Long buyerCompanyId;\n    private Long buyerAccountId;\n    private Long callerCompanyId;\n    private Long callerAccountId;\n\n    private String tenantId;\n    private String bizCode;\n    private String channel; //这个Channel在查询中不起任何作用，不应该放在这里\n}\n```\n功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。\n可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。\n那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。\nTips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。\n### 其他问题\n#### 函数过长\n一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。\n#### 命名规范\n一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。\n#### 不合理的注释\n注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。\n#### 无用代码\n无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。\n#### 过大的类\n一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。\n\n## 大型重构\n![image.png](/images/refactor-project/2.png)\n### 事前准备\n事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。\n在这个阶段大致可分为三步：\n\n- **明确重构的内容、目的以及方向、目标**\n\n在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。\n\n- **整理数据**\n\n这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。\n附上整个系统的架构和此次重点重构的部分（深色标记部分）\n![image.png](/images/refactor-project/3.png)\n\n- **项目立项**\n\n项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。\n注意：会议结束后需要进行会议纪要邮件周知。\n### 事中执行\n事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。\n\n- **架构设计与评审**\n\n架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。\n该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。\n\n- **详细落地设计方案与评审**\n\n这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。\n在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：\n![image.png](/images/refactor-project/4.png)\n在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。\n在AB程序中，会涉及到两个开关。**灰度开关**（只有它开启了，请求才会被发送到新的流程中进行代码执行）。**执行开关**（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。\n\n- **代码的编写、测试、线下实施**\n\n这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。\n### \n### 事后观测与复盘\n这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。\n\n- **灰度开关流程**\n\n逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。\n\n- **业务执行开关流程**\n\n在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。\n放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。\n\n# 总结\n## 代码技巧\n\n- 写代码的时候遵循一些基本原则，比如单一原则、依赖接口/抽象而不是依赖具体实现。\n- 严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。\n- 单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。\n- 我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。\n- 不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。\n## 重构技巧\n\n- 从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。\n- 提炼类，复用函数，下沉核心能力，让模块职责清晰明了。\n- 依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。\n- 类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。\n- 大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。\n\n代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：\n1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力\n2、代码洁癖、工匠精神\n3、产品思维\n\n","slug":"Refactor-project","published":1,"updated":"2024-02-01T16:16:49.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls3f5xxq0000r4x54i19cger","content":"<p>任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。</p>\n<h1 id=\"什么是重构\"><a href=\"#什么是重构\" class=\"headerlink\" title=\"什么是重构\"></a>什么是重构</h1><blockquote>\n<p>重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。</p>\n</blockquote>\n<p>根据重构的规模程度、时间长短，我们可以将代码重构分为<strong>小型重构</strong>和<strong>大型重构</strong>。</p>\n<p><strong>小型重构</strong>：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。</p>\n<p><strong>大型重构</strong>：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行<strong>服务分层、业务模块化、组件化、代码抽象复用</strong>等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。</p>\n<p>其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：</p>\n<ul>\n<li>不知道怎么重构、缺乏重构的经验和方法论。</li>\n<li>很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。</li>\n<li>重构可能会破坏现有程序，带来意想不到的bug。</li>\n<li>重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。</li>\n</ul>\n<h1 id=\"为什么要重构\"><a href=\"#为什么要重构\" class=\"headerlink\" title=\"为什么要重构\"></a>为什么要重构</h1><p>程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： </p>\n<ul>\n<li><strong>让软件架构始终保持良好的设计。</strong>改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。</li>\n<li><strong>增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。</strong>无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。</li>\n<li><strong>提高研发速度、缩短人力成本。</strong>大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。</li>\n</ul>\n<p><img src=\"/images/refactor-project/1.png\" alt=\"image.png\"></p>\n<h1 id=\"怎么进行重构\"><a href=\"#怎么进行重构\" class=\"headerlink\" title=\"怎么进行重构\"></a>怎么进行重构</h1><h2 id=\"小型重构\"><a href=\"#小型重构\" class=\"headerlink\" title=\"小型重构\"></a>小型重构</h2><p>小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。</p>\n<h3 id=\"业务语义显性化\"><a href=\"#业务语义显性化\" class=\"headerlink\" title=\"业务语义显性化\"></a>业务语义显性化</h3><p>优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。<br>如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。<br><strong>原代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!PvgContext.getCrmUserId().equals(NIL_VALUE) &amp;&amp; icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>重构后</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(canPickUpToPrivateSea())</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//判断客户能否捡私入海</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPickUpToPrivateSea</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(StringUtil.isBlank(PvgContext.getCrmUserId()))&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型问题\"><a href=\"#泛型问题\" class=\"headerlink\" title=\"泛型问题\"></a>泛型问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了大家理解方便，增加了一些注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//msg是从MQ消费到消息</span></span><br><span class=\"line\"><span class=\"type\">Map</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> JSON.parseObject(msg); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">mobile</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xxx&quot;</span>；</span><br><span class=\"line\">ps.put(<span class=\"string\">&quot;driverNumber&quot;</span>, mobile);</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 对ps进行操作</span></span><br><span class=\"line\">Set&lt;String&gt; keySet = (Set&lt;String&gt;)ps.keySet();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(<span class=\"string\">&quot;driverPrice&quot;</span>) &amp;&amp; ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"type\">Object</span> <span class=\"variable\">factPrice</span> <span class=\"operator\">=</span> ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">1</span>】</span><br><span class=\"line\">  \tps.put(<span class=\"string\">&quot;driverPrice&quot;</span>, String.format(<span class=\"string\">&quot;%.2f&quot;</span>,((BigDecimal)factPrice).doubleValue()));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> String) &#123; 【<span class=\"number\">2</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">refund</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>((String)factPrice);</span><br><span class=\"line\">    ps.put(<span class=\"string\">&quot;refundPrice&quot;</span>, refund.stripTrailingZeros().toPlainString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(ORDER_TIP_PRICE) &amp;&amp; ps.get(ORDER_TIP_PRICE) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ps.get(ORDER_TIP_PRICE) <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">3</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">tipPrice</span> <span class=\"operator\">=</span> (BigDecimal)ps.get(ORDER_TIP_PRICE);</span><br><span class=\"line\">    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 将ps作为传输传递给服务内部底层接口</span></span><br><span class=\"line\">msgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//看一下底层接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">innerOrderTempMessage</span><span class=\"params\">(String msg, Map&lt;String, String&gt; ps, PushOrderTotalVO vo)</span>;</span><br></pre></td></tr></table></figure>\n<p>这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map&lt;String, String&gt;限定的接口中就是有很大的问题的，未来底层接口使用String value &#x3D; ps.get(XXX)获取一个非String类型时就会出现类型转换异常。</p>\n<h3 id=\"无病呻吟\"><a href=\"#无病呻吟\" class=\"headerlink\" title=\"无病呻吟\"></a>无病呻吟</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\"><span class=\"comment\">// 设置name和md5</span></span><br><span class=\"line\">config.setName(item.getName());</span><br><span class=\"line\">config.setMd5(item.getMd5());</span><br><span class=\"line\"><span class=\"comment\">// 设置值</span></span><br><span class=\"line\">config.setTypeMap(map);</span><br><span class=\"line\"><span class=\"comment\">// 打印日志</span></span><br><span class=\"line\">LOGGER.info(<span class=\"string\">&quot;update done (&#123;&#125;,&#123;&#125;), start replace&quot;</span>, getName(), getMd5());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ExpiredConfig</span> <span class=\"variable\">expireConfig</span> <span class=\"operator\">=</span> ConfigManager.getExpiredConfig();</span><br><span class=\"line\"><span class=\"comment\">// 为空初始化</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Objects.isNull(expireConfig)) &#123;</span><br><span class=\"line\">  expireConfig = <span class=\"keyword\">new</span> <span class=\"title class_\">ExpiredConfig</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">Map&lt;String, List&lt;TypeItem&gt;&gt; typeMap = ……;   </span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt;&gt; jsonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 循环一级map</span></span><br><span class=\"line\">jsonMap.forEach((k1, v1) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环里面的二级map</span></span><br><span class=\"line\">    v1.forEach((k2, v2) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环里面的三级map</span></span><br><span class=\"line\">        v2.forEach((k3, v3) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 循环最里面的list,哎！</span></span><br><span class=\"line\">            v3.forEach(e -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生成key</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">ck</span> <span class=\"operator\">=</span> getKey(k1, k2, k3);</span><br><span class=\"line\">                <span class=\"comment\">// 为空处理</span></span><br><span class=\"line\">                List&lt;TypeItem&gt; types = typeMap.get(ck);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(types)) &#123;</span><br><span class=\"line\">                    types = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                    typeMap.put(ck, types);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 设置类型</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。</p>\n<h3 id=\"if-else过多\"><a href=\"#if-else过多\" class=\"headerlink\" title=\"if-else过多\"></a>if-else过多</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面截取的get25000OrderState的部分代码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">get25000OrderState</span><span class=\"params\">(OrderTotalVO orderTotalVO)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">mainState</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    List&lt;String&gt; stateList = Lists.newArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    ……</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DispatchType</span> <span class=\"variable\">dispatchType</span> <span class=\"operator\">=</span> DispatchType.getEnum(orderTotalVO.getDispatchType());</span><br><span class=\"line\">    <span class=\"type\">ServiceType</span> <span class=\"variable\">serviceType</span> <span class=\"operator\">=</span> ServiceType.typeOf(orderTotalVO.getServiceType());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (serviceType == ServiceType.CHARTERED_CAR) &#123;</span><br><span class=\"line\">        state = state + <span class=\"string\">&quot;_&quot;</span> + serviceType;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties()))&#123;\t\tstate = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_phoneCall&quot;</span>;                                                                                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_&quot;</span> + pastOrderId;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isHighQuality(orderTotalVO.getHighQualityFlag()) &amp;&amp; DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode())&#123;</span><br><span class=\"line\">                state += <span class=\"string\">&quot;_highQuality&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isOtherPassengerOrder(orderTotalVO)) &#123;</span><br><span class=\"line\">        state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;forOther_aly&quot;</span>;</span><br><span class=\"line\">        stateList.add(state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">BigDecimal</span> <span class=\"variable\">tickOtherPrice</span> <span class=\"operator\">=</span> orderTotalVO.getTicketOtherPrice();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tickOtherPrice != <span class=\"literal\">null</span> &amp;&amp; BigDecimal.ZERO.compareTo(tickOtherPrice) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">\t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stateList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。</p>\n<h3 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a>重复代码</h3><p>代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。</p>\n<p>最常见的一种重复场景就是在“<strong>同一个类的两个函数含有相同的表达式</strong>”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。<br>还有一种和这类场景相似，就是在“<strong>两个互为兄弟的子类含有相同的表达式</strong>”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。</p>\n<h3 id=\"单一功能职责\"><a href=\"#单一功能职责\" class=\"headerlink\" title=\"单一功能职责\"></a>单一功能职责</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BuyerInfoParam</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Required Param</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerAccountId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerAccountId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String tenantId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String bizCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String channel; <span class=\"comment\">//这个Channel在查询中不起任何作用，不应该放在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。<br>可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。<br>那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。<br>Tips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。</p>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><h4 id=\"函数过长\"><a href=\"#函数过长\" class=\"headerlink\" title=\"函数过长\"></a>函数过长</h4><p>一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。</p>\n<h4 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h4><p>一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。</p>\n<h4 id=\"不合理的注释\"><a href=\"#不合理的注释\" class=\"headerlink\" title=\"不合理的注释\"></a>不合理的注释</h4><p>注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。</p>\n<h4 id=\"无用代码\"><a href=\"#无用代码\" class=\"headerlink\" title=\"无用代码\"></a>无用代码</h4><p>无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。</p>\n<h4 id=\"过大的类\"><a href=\"#过大的类\" class=\"headerlink\" title=\"过大的类\"></a>过大的类</h4><p>一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。</p>\n<h2 id=\"大型重构\"><a href=\"#大型重构\" class=\"headerlink\" title=\"大型重构\"></a>大型重构</h2><p><img src=\"/images/refactor-project/2.png\" alt=\"image.png\"></p>\n<h3 id=\"事前准备\"><a href=\"#事前准备\" class=\"headerlink\" title=\"事前准备\"></a>事前准备</h3><p>事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。<br>在这个阶段大致可分为三步：</p>\n<ul>\n<li><strong>明确重构的内容、目的以及方向、目标</strong></li>\n</ul>\n<p>在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。</p>\n<ul>\n<li><strong>整理数据</strong></li>\n</ul>\n<p>这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。<br>附上整个系统的架构和此次重点重构的部分（深色标记部分）<br><img src=\"/images/refactor-project/3.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>项目立项</strong></li>\n</ul>\n<p>项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。<br>注意：会议结束后需要进行会议纪要邮件周知。</p>\n<h3 id=\"事中执行\"><a href=\"#事中执行\" class=\"headerlink\" title=\"事中执行\"></a>事中执行</h3><p>事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。</p>\n<ul>\n<li><strong>架构设计与评审</strong></li>\n</ul>\n<p>架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。<br>该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。</p>\n<ul>\n<li><strong>详细落地设计方案与评审</strong></li>\n</ul>\n<p>这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。<br>在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：<br><img src=\"/images/refactor-project/4.png\" alt=\"image.png\"><br>在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。<br>在AB程序中，会涉及到两个开关。<strong>灰度开关</strong>（只有它开启了，请求才会被发送到新的流程中进行代码执行）。<strong>执行开关</strong>（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。</p>\n<ul>\n<li><strong>代码的编写、测试、线下实施</strong></li>\n</ul>\n<p>这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"事后观测与复盘\"><a href=\"#事后观测与复盘\" class=\"headerlink\" title=\"事后观测与复盘\"></a>事后观测与复盘</h3><p>这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。</p>\n<ul>\n<li><strong>灰度开关流程</strong></li>\n</ul>\n<p>逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。</p>\n<ul>\n<li><strong>业务执行开关流程</strong></li>\n</ul>\n<p>在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。<br>放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"代码技巧\"><a href=\"#代码技巧\" class=\"headerlink\" title=\"代码技巧\"></a>代码技巧</h2><ul>\n<li>写代码的时候遵循一些基本原则，比如单一原则、依赖接口&#x2F;抽象而不是依赖具体实现。</li>\n<li>严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。</li>\n<li>单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。</li>\n<li>我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。</li>\n<li>不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。</li>\n</ul>\n<h2 id=\"重构技巧\"><a href=\"#重构技巧\" class=\"headerlink\" title=\"重构技巧\"></a>重构技巧</h2><ul>\n<li>从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。</li>\n<li>提炼类，复用函数，下沉核心能力，让模块职责清晰明了。</li>\n<li>依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。</li>\n<li>类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。</li>\n<li>大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。</li>\n</ul>\n<p>代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：<br>1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力<br>2、代码洁癖、工匠精神<br>3、产品思维</p>\n","site":{"data":{}},"excerpt":"","more":"<p>任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。</p>\n<h1 id=\"什么是重构\"><a href=\"#什么是重构\" class=\"headerlink\" title=\"什么是重构\"></a>什么是重构</h1><blockquote>\n<p>重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。</p>\n</blockquote>\n<p>根据重构的规模程度、时间长短，我们可以将代码重构分为<strong>小型重构</strong>和<strong>大型重构</strong>。</p>\n<p><strong>小型重构</strong>：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。</p>\n<p><strong>大型重构</strong>：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行<strong>服务分层、业务模块化、组件化、代码抽象复用</strong>等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。</p>\n<p>其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：</p>\n<ul>\n<li>不知道怎么重构、缺乏重构的经验和方法论。</li>\n<li>很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。</li>\n<li>重构可能会破坏现有程序，带来意想不到的bug。</li>\n<li>重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。</li>\n</ul>\n<h1 id=\"为什么要重构\"><a href=\"#为什么要重构\" class=\"headerlink\" title=\"为什么要重构\"></a>为什么要重构</h1><p>程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： </p>\n<ul>\n<li><strong>让软件架构始终保持良好的设计。</strong>改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。</li>\n<li><strong>增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。</strong>无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。</li>\n<li><strong>提高研发速度、缩短人力成本。</strong>大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。</li>\n</ul>\n<p><img src=\"/images/refactor-project/1.png\" alt=\"image.png\"></p>\n<h1 id=\"怎么进行重构\"><a href=\"#怎么进行重构\" class=\"headerlink\" title=\"怎么进行重构\"></a>怎么进行重构</h1><h2 id=\"小型重构\"><a href=\"#小型重构\" class=\"headerlink\" title=\"小型重构\"></a>小型重构</h2><p>小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。</p>\n<h3 id=\"业务语义显性化\"><a href=\"#业务语义显性化\" class=\"headerlink\" title=\"业务语义显性化\"></a>业务语义显性化</h3><p>优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。<br>如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。<br><strong>原代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!PvgContext.getCrmUserId().equals(NIL_VALUE) &amp;&amp; icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>重构后</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(canPickUpToPrivateSea())</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//判断客户能否捡私入海</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPickUpToPrivateSea</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(StringUtil.isBlank(PvgContext.getCrmUserId()))&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型问题\"><a href=\"#泛型问题\" class=\"headerlink\" title=\"泛型问题\"></a>泛型问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了大家理解方便，增加了一些注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//msg是从MQ消费到消息</span></span><br><span class=\"line\"><span class=\"type\">Map</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> JSON.parseObject(msg); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">mobile</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xxx&quot;</span>；</span><br><span class=\"line\">ps.put(<span class=\"string\">&quot;driverNumber&quot;</span>, mobile);</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 对ps进行操作</span></span><br><span class=\"line\">Set&lt;String&gt; keySet = (Set&lt;String&gt;)ps.keySet();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(<span class=\"string\">&quot;driverPrice&quot;</span>) &amp;&amp; ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"type\">Object</span> <span class=\"variable\">factPrice</span> <span class=\"operator\">=</span> ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">1</span>】</span><br><span class=\"line\">  \tps.put(<span class=\"string\">&quot;driverPrice&quot;</span>, String.format(<span class=\"string\">&quot;%.2f&quot;</span>,((BigDecimal)factPrice).doubleValue()));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> String) &#123; 【<span class=\"number\">2</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">refund</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>((String)factPrice);</span><br><span class=\"line\">    ps.put(<span class=\"string\">&quot;refundPrice&quot;</span>, refund.stripTrailingZeros().toPlainString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(ORDER_TIP_PRICE) &amp;&amp; ps.get(ORDER_TIP_PRICE) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ps.get(ORDER_TIP_PRICE) <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">3</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">tipPrice</span> <span class=\"operator\">=</span> (BigDecimal)ps.get(ORDER_TIP_PRICE);</span><br><span class=\"line\">    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 将ps作为传输传递给服务内部底层接口</span></span><br><span class=\"line\">msgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//看一下底层接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">innerOrderTempMessage</span><span class=\"params\">(String msg, Map&lt;String, String&gt; ps, PushOrderTotalVO vo)</span>;</span><br></pre></td></tr></table></figure>\n<p>这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map&lt;String, String&gt;限定的接口中就是有很大的问题的，未来底层接口使用String value &#x3D; ps.get(XXX)获取一个非String类型时就会出现类型转换异常。</p>\n<h3 id=\"无病呻吟\"><a href=\"#无病呻吟\" class=\"headerlink\" title=\"无病呻吟\"></a>无病呻吟</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\"><span class=\"comment\">// 设置name和md5</span></span><br><span class=\"line\">config.setName(item.getName());</span><br><span class=\"line\">config.setMd5(item.getMd5());</span><br><span class=\"line\"><span class=\"comment\">// 设置值</span></span><br><span class=\"line\">config.setTypeMap(map);</span><br><span class=\"line\"><span class=\"comment\">// 打印日志</span></span><br><span class=\"line\">LOGGER.info(<span class=\"string\">&quot;update done (&#123;&#125;,&#123;&#125;), start replace&quot;</span>, getName(), getMd5());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ExpiredConfig</span> <span class=\"variable\">expireConfig</span> <span class=\"operator\">=</span> ConfigManager.getExpiredConfig();</span><br><span class=\"line\"><span class=\"comment\">// 为空初始化</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Objects.isNull(expireConfig)) &#123;</span><br><span class=\"line\">  expireConfig = <span class=\"keyword\">new</span> <span class=\"title class_\">ExpiredConfig</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">Map&lt;String, List&lt;TypeItem&gt;&gt; typeMap = ……;   </span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt;&gt; jsonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 循环一级map</span></span><br><span class=\"line\">jsonMap.forEach((k1, v1) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环里面的二级map</span></span><br><span class=\"line\">    v1.forEach((k2, v2) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环里面的三级map</span></span><br><span class=\"line\">        v2.forEach((k3, v3) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 循环最里面的list,哎！</span></span><br><span class=\"line\">            v3.forEach(e -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生成key</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">ck</span> <span class=\"operator\">=</span> getKey(k1, k2, k3);</span><br><span class=\"line\">                <span class=\"comment\">// 为空处理</span></span><br><span class=\"line\">                List&lt;TypeItem&gt; types = typeMap.get(ck);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(types)) &#123;</span><br><span class=\"line\">                    types = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                    typeMap.put(ck, types);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 设置类型</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。</p>\n<h3 id=\"if-else过多\"><a href=\"#if-else过多\" class=\"headerlink\" title=\"if-else过多\"></a>if-else过多</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面截取的get25000OrderState的部分代码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">get25000OrderState</span><span class=\"params\">(OrderTotalVO orderTotalVO)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">mainState</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    List&lt;String&gt; stateList = Lists.newArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    ……</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DispatchType</span> <span class=\"variable\">dispatchType</span> <span class=\"operator\">=</span> DispatchType.getEnum(orderTotalVO.getDispatchType());</span><br><span class=\"line\">    <span class=\"type\">ServiceType</span> <span class=\"variable\">serviceType</span> <span class=\"operator\">=</span> ServiceType.typeOf(orderTotalVO.getServiceType());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (serviceType == ServiceType.CHARTERED_CAR) &#123;</span><br><span class=\"line\">        state = state + <span class=\"string\">&quot;_&quot;</span> + serviceType;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties()))&#123;\t\tstate = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_phoneCall&quot;</span>;                                                                                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_&quot;</span> + pastOrderId;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isHighQuality(orderTotalVO.getHighQualityFlag()) &amp;&amp; DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode())&#123;</span><br><span class=\"line\">                state += <span class=\"string\">&quot;_highQuality&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isOtherPassengerOrder(orderTotalVO)) &#123;</span><br><span class=\"line\">        state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;forOther_aly&quot;</span>;</span><br><span class=\"line\">        stateList.add(state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">BigDecimal</span> <span class=\"variable\">tickOtherPrice</span> <span class=\"operator\">=</span> orderTotalVO.getTicketOtherPrice();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tickOtherPrice != <span class=\"literal\">null</span> &amp;&amp; BigDecimal.ZERO.compareTo(tickOtherPrice) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">\t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stateList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。</p>\n<h3 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a>重复代码</h3><p>代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。</p>\n<p>最常见的一种重复场景就是在“<strong>同一个类的两个函数含有相同的表达式</strong>”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。<br>还有一种和这类场景相似，就是在“<strong>两个互为兄弟的子类含有相同的表达式</strong>”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。</p>\n<h3 id=\"单一功能职责\"><a href=\"#单一功能职责\" class=\"headerlink\" title=\"单一功能职责\"></a>单一功能职责</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BuyerInfoParam</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Required Param</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerAccountId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerAccountId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String tenantId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String bizCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String channel; <span class=\"comment\">//这个Channel在查询中不起任何作用，不应该放在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。<br>可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。<br>那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。<br>Tips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。</p>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><h4 id=\"函数过长\"><a href=\"#函数过长\" class=\"headerlink\" title=\"函数过长\"></a>函数过长</h4><p>一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。</p>\n<h4 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h4><p>一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。</p>\n<h4 id=\"不合理的注释\"><a href=\"#不合理的注释\" class=\"headerlink\" title=\"不合理的注释\"></a>不合理的注释</h4><p>注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。</p>\n<h4 id=\"无用代码\"><a href=\"#无用代码\" class=\"headerlink\" title=\"无用代码\"></a>无用代码</h4><p>无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。</p>\n<h4 id=\"过大的类\"><a href=\"#过大的类\" class=\"headerlink\" title=\"过大的类\"></a>过大的类</h4><p>一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。</p>\n<h2 id=\"大型重构\"><a href=\"#大型重构\" class=\"headerlink\" title=\"大型重构\"></a>大型重构</h2><p><img src=\"/images/refactor-project/2.png\" alt=\"image.png\"></p>\n<h3 id=\"事前准备\"><a href=\"#事前准备\" class=\"headerlink\" title=\"事前准备\"></a>事前准备</h3><p>事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。<br>在这个阶段大致可分为三步：</p>\n<ul>\n<li><strong>明确重构的内容、目的以及方向、目标</strong></li>\n</ul>\n<p>在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。</p>\n<ul>\n<li><strong>整理数据</strong></li>\n</ul>\n<p>这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。<br>附上整个系统的架构和此次重点重构的部分（深色标记部分）<br><img src=\"/images/refactor-project/3.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>项目立项</strong></li>\n</ul>\n<p>项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。<br>注意：会议结束后需要进行会议纪要邮件周知。</p>\n<h3 id=\"事中执行\"><a href=\"#事中执行\" class=\"headerlink\" title=\"事中执行\"></a>事中执行</h3><p>事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。</p>\n<ul>\n<li><strong>架构设计与评审</strong></li>\n</ul>\n<p>架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。<br>该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。</p>\n<ul>\n<li><strong>详细落地设计方案与评审</strong></li>\n</ul>\n<p>这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。<br>在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：<br><img src=\"/images/refactor-project/4.png\" alt=\"image.png\"><br>在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。<br>在AB程序中，会涉及到两个开关。<strong>灰度开关</strong>（只有它开启了，请求才会被发送到新的流程中进行代码执行）。<strong>执行开关</strong>（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。</p>\n<ul>\n<li><strong>代码的编写、测试、线下实施</strong></li>\n</ul>\n<p>这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"事后观测与复盘\"><a href=\"#事后观测与复盘\" class=\"headerlink\" title=\"事后观测与复盘\"></a>事后观测与复盘</h3><p>这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。</p>\n<ul>\n<li><strong>灰度开关流程</strong></li>\n</ul>\n<p>逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。</p>\n<ul>\n<li><strong>业务执行开关流程</strong></li>\n</ul>\n<p>在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。<br>放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"代码技巧\"><a href=\"#代码技巧\" class=\"headerlink\" title=\"代码技巧\"></a>代码技巧</h2><ul>\n<li>写代码的时候遵循一些基本原则，比如单一原则、依赖接口&#x2F;抽象而不是依赖具体实现。</li>\n<li>严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。</li>\n<li>单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。</li>\n<li>我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。</li>\n<li>不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。</li>\n</ul>\n<h2 id=\"重构技巧\"><a href=\"#重构技巧\" class=\"headerlink\" title=\"重构技巧\"></a>重构技巧</h2><ul>\n<li>从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。</li>\n<li>提炼类，复用函数，下沉核心能力，让模块职责清晰明了。</li>\n<li>依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。</li>\n<li>类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。</li>\n<li>大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。</li>\n</ul>\n<p>代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：<br>1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力<br>2、代码洁癖、工匠精神<br>3、产品思维</p>\n"},{"title":"线程安全的无锁日志","date":"2024-02-02T05:40:24.000Z","_content":"因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。\n具体源码可见：[Fly-Log](https://github.com/LiaoYuanF/Fly-Log)\n# 日志系统应该满足的要求\n\n1. 高效，作为一个日志系统，不应该占据太多资源\n2. 简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度\n3. 线程安全，服务端的各个线程都能同时读写日志\n4. 轮替问题，如果半年到一年的日志放到一个文件会导致文件过大\n5. 及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失\n# 难点问题及其解决\n当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。\n### 线程安全\n解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。\n\n1. 使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程/多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。\n2. 每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。\n### 轮替问题\n#### 有锁方案\n轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。\n#### 无锁方案\n可以使用posix中的dup2来实现无锁轮替文件。\n```cpp\n//轮替时，首先重命名已打开的日志文件，保持打开状态，\nrename(filename, newname);\n//然后创建新的日志文件\nfd = open(filename,...);\n//使用dup2系统函数把fd（新）复制到fd_（旧）上\ndup2(fd, fd_);\n//关闭fd（新）\nclose(fd);\n```\n其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, ...)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。\n","source":"_posts/Look-free-log.md","raw":"---\ntitle: 线程安全的无锁日志\ndate: 2024-02-02 13:40:24\ntags: 工具集合\n---\n因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。\n具体源码可见：[Fly-Log](https://github.com/LiaoYuanF/Fly-Log)\n# 日志系统应该满足的要求\n\n1. 高效，作为一个日志系统，不应该占据太多资源\n2. 简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度\n3. 线程安全，服务端的各个线程都能同时读写日志\n4. 轮替问题，如果半年到一年的日志放到一个文件会导致文件过大\n5. 及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失\n# 难点问题及其解决\n当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。\n### 线程安全\n解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。\n\n1. 使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程/多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。\n2. 每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。\n### 轮替问题\n#### 有锁方案\n轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。\n#### 无锁方案\n可以使用posix中的dup2来实现无锁轮替文件。\n```cpp\n//轮替时，首先重命名已打开的日志文件，保持打开状态，\nrename(filename, newname);\n//然后创建新的日志文件\nfd = open(filename,...);\n//使用dup2系统函数把fd（新）复制到fd_（旧）上\ndup2(fd, fd_);\n//关闭fd（新）\nclose(fd);\n```\n其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, ...)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。\n","slug":"Look-free-log","published":1,"updated":"2024-02-02T05:48:30.498Z","_id":"cls482gg500006lx5024naovq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。<br>具体源码可见：<a href=\"https://github.com/LiaoYuanF/Fly-Log\">Fly-Log</a></p>\n<h1 id=\"日志系统应该满足的要求\"><a href=\"#日志系统应该满足的要求\" class=\"headerlink\" title=\"日志系统应该满足的要求\"></a>日志系统应该满足的要求</h1><ol>\n<li>高效，作为一个日志系统，不应该占据太多资源</li>\n<li>简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度</li>\n<li>线程安全，服务端的各个线程都能同时读写日志</li>\n<li>轮替问题，如果半年到一年的日志放到一个文件会导致文件过大</li>\n<li>及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失</li>\n</ol>\n<h1 id=\"难点问题及其解决\"><a href=\"#难点问题及其解决\" class=\"headerlink\" title=\"难点问题及其解决\"></a>难点问题及其解决</h1><p>当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。</p>\n<ol>\n<li>使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程&#x2F;多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。</li>\n<li>每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。</li>\n</ol>\n<h3 id=\"轮替问题\"><a href=\"#轮替问题\" class=\"headerlink\" title=\"轮替问题\"></a>轮替问题</h3><h4 id=\"有锁方案\"><a href=\"#有锁方案\" class=\"headerlink\" title=\"有锁方案\"></a>有锁方案</h4><p>轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。</p>\n<h4 id=\"无锁方案\"><a href=\"#无锁方案\" class=\"headerlink\" title=\"无锁方案\"></a>无锁方案</h4><p>可以使用posix中的dup2来实现无锁轮替文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//轮替时，首先重命名已打开的日志文件，保持打开状态，</span></span><br><span class=\"line\"><span class=\"built_in\">rename</span>(filename, newname);</span><br><span class=\"line\"><span class=\"comment\">//然后创建新的日志文件</span></span><br><span class=\"line\">fd = <span class=\"built_in\">open</span>(filename,...);</span><br><span class=\"line\"><span class=\"comment\">//使用dup2系统函数把fd（新）复制到fd_（旧）上</span></span><br><span class=\"line\"><span class=\"built_in\">dup2</span>(fd, fd_);</span><br><span class=\"line\"><span class=\"comment\">//关闭fd（新）</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(fd);</span><br></pre></td></tr></table></figure>\n<p>其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, …)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。<br>具体源码可见：<a href=\"https://github.com/LiaoYuanF/Fly-Log\">Fly-Log</a></p>\n<h1 id=\"日志系统应该满足的要求\"><a href=\"#日志系统应该满足的要求\" class=\"headerlink\" title=\"日志系统应该满足的要求\"></a>日志系统应该满足的要求</h1><ol>\n<li>高效，作为一个日志系统，不应该占据太多资源</li>\n<li>简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度</li>\n<li>线程安全，服务端的各个线程都能同时读写日志</li>\n<li>轮替问题，如果半年到一年的日志放到一个文件会导致文件过大</li>\n<li>及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失</li>\n</ol>\n<h1 id=\"难点问题及其解决\"><a href=\"#难点问题及其解决\" class=\"headerlink\" title=\"难点问题及其解决\"></a>难点问题及其解决</h1><p>当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。</p>\n<ol>\n<li>使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程&#x2F;多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。</li>\n<li>每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。</li>\n</ol>\n<h3 id=\"轮替问题\"><a href=\"#轮替问题\" class=\"headerlink\" title=\"轮替问题\"></a>轮替问题</h3><h4 id=\"有锁方案\"><a href=\"#有锁方案\" class=\"headerlink\" title=\"有锁方案\"></a>有锁方案</h4><p>轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。</p>\n<h4 id=\"无锁方案\"><a href=\"#无锁方案\" class=\"headerlink\" title=\"无锁方案\"></a>无锁方案</h4><p>可以使用posix中的dup2来实现无锁轮替文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//轮替时，首先重命名已打开的日志文件，保持打开状态，</span></span><br><span class=\"line\"><span class=\"built_in\">rename</span>(filename, newname);</span><br><span class=\"line\"><span class=\"comment\">//然后创建新的日志文件</span></span><br><span class=\"line\">fd = <span class=\"built_in\">open</span>(filename,...);</span><br><span class=\"line\"><span class=\"comment\">//使用dup2系统函数把fd（新）复制到fd_（旧）上</span></span><br><span class=\"line\"><span class=\"built_in\">dup2</span>(fd, fd_);</span><br><span class=\"line\"><span class=\"comment\">//关闭fd（新）</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(fd);</span><br></pre></td></tr></table></figure>\n<p>其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, …)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。</p>\n"},{"title":"线程安全的无锁循环队列","date":"2023-12-28T05:30:34.000Z","_content":"想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。\n# 需求的自然语言描述\n用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释\n具体要求如下：\n\n1. 环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写\n2. 支持模板，存放的数据类型可以自定义\n3. 代码风格使用google C++风格\n4. 在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由\n# Gpt第一轮尝试\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n\n// 线程安全的循环队列模板\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity) {}\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不满\n        notFull_.wait(lock, [this] { return queue_.size() < capacity_; });\n        queue_.push(item);\n        lock.unlock();\n        // 通知等待的线程队列不为空\n        notEmpty_.notify_one();\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (queue_.size() < capacity_) {\n            queue_.push(item);\n            // 通知等待的线程队列不为空\n            notEmpty_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不空\n        notEmpty_.wait(lock, [this] { return !queue_.empty(); });\n        T item = queue_.front();\n        queue_.pop();\n        lock.unlock();\n        // 通知等待的线程队列不满\n        notFull_.notify_one();\n        return item;\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (!queue_.empty()) {\n            item = queue_.front();\n            queue_.pop();\n            // 通知等待的线程队列不满\n            notFull_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::queue<T> queue_;\n    std::mutex mutex_;\n    std::condition_variable notFull_;\n    std::condition_variable notEmpty_;\n};\n```\n## 对代码的分析\n代码最低限度地实现了我们提出的需求，比如阻塞/非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。\n\n1. 可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。\n2. gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。\n#  Gpt的第二轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 由于采用deque的数据结构，导致存在动态分配内存的开销\n2. mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        while (true) {\n            size_t currentTail = tail_.load(std::memory_order_relaxed);\n            size_t nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail != head_.load(std::memory_order_acquire)) {\n                data_[currentTail] = item;\n                tail_.store(nextTail, std::memory_order_release);\n                return;\n            }\n            // 队列已满，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        while (true) {\n            size_t currentHead = head_.load(std::memory_order_relaxed);\n            size_t currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead != currentTail) {\n                T item = data_[currentHead];\n                head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n                return item;\n            }\n            // 队列为空，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead != currentTail) {\n            item = data_[currentHead];\n            head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n```\n## 对代码的分析\n从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。\n可以简单分析一下，这轮优化过程中使用到的一些知识点：\n### 为什么舍弃条件变量\n**std::condition_variable** 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用**condition_variable** 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。\n但是**condition_variable** 必须搭配mutex使用，在我们限定无锁编程的情况下，**condition_variable** 显然是无法被采用的，所以被舍弃了。\n### 阻塞写时安全性论证\n```cpp\nvoid Enqueue(const T& item) {\n    while (true) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return;\n        }\n        // 队列已满，等待\n        std::this_thread::yield();\n    }\n}\n```\n这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。\n**错误一：**\n下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。\n```cpp\nsize_t currentTail = tail_.load(std::memory_order_relaxed);\nsize_t nextTail = (currentTail + 1) % capacity_;\n```\n**错误二：**\n虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。\n```cpp\nif (nextTail != head_.load(std::memory_order_acquire)) {\n    data_[currentTail] = item;\n    // something else\n}\n```\n所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。\n# Gpt的第三轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                // 队列已满，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = item;\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail == head_.load(std::memory_order_acquire))\n            return false;\n\n        if (tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行写入操作\n            data_[currentTail] = item;\n            return true;\n        }\n\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                // 队列为空，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        return data_[currentHead];\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead == currentTail)\n            return false;\n\n        if (head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行读取操作\n            item = data_[currentHead];\n            return true;\n        }\n\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n## 对代码的分析\n我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：\n```cpp\nvoid Enqueue(const T& item) {\n    size_t currentTail;\n    size_t nextTail;\n    do {\n        currentTail = tail_.load(std::memory_order_relaxed);\n        nextTail = (currentTail + 1) % capacity_;\n        if (nextTail == head_.load(std::memory_order_acquire)) {\n            // 队列已满，等待\n            std::this_thread::yield();\n            continue;\n        }\n        // 尝试使用CAS进行原子操作\n    } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n    // CAS成功，可以进行写入操作\n    data_[currentTail] = item;\n}\n```\n在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。\n# 一些更远的优化点\n此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。\n\n1. 阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。\n2. 该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。\n\n改良后的代码如下：\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 通用的入队操作\n    template <typename U>\n    bool Enqueue(U&& item, bool blocking = true) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = std::forward<U>(item);\n        return true;\n    }\n\n    // 通用的出队操作\n    template <typename U>\n    bool Dequeue(U& item, bool blocking = true) {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        item = std::move(data_[currentHead]);\n        return true;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n\n","source":"_posts/Look-free-circular-queue.md","raw":"---\ntitle: 线程安全的无锁循环队列\ndate: 2023-12-28 13:30:34\ntags: 工具集合\n---\n想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。\n# 需求的自然语言描述\n用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释\n具体要求如下：\n\n1. 环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写\n2. 支持模板，存放的数据类型可以自定义\n3. 代码风格使用google C++风格\n4. 在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由\n# Gpt第一轮尝试\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n\n// 线程安全的循环队列模板\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity) {}\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不满\n        notFull_.wait(lock, [this] { return queue_.size() < capacity_; });\n        queue_.push(item);\n        lock.unlock();\n        // 通知等待的线程队列不为空\n        notEmpty_.notify_one();\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (queue_.size() < capacity_) {\n            queue_.push(item);\n            // 通知等待的线程队列不为空\n            notEmpty_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不空\n        notEmpty_.wait(lock, [this] { return !queue_.empty(); });\n        T item = queue_.front();\n        queue_.pop();\n        lock.unlock();\n        // 通知等待的线程队列不满\n        notFull_.notify_one();\n        return item;\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (!queue_.empty()) {\n            item = queue_.front();\n            queue_.pop();\n            // 通知等待的线程队列不满\n            notFull_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::queue<T> queue_;\n    std::mutex mutex_;\n    std::condition_variable notFull_;\n    std::condition_variable notEmpty_;\n};\n```\n## 对代码的分析\n代码最低限度地实现了我们提出的需求，比如阻塞/非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。\n\n1. 可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。\n2. gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。\n#  Gpt的第二轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 由于采用deque的数据结构，导致存在动态分配内存的开销\n2. mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        while (true) {\n            size_t currentTail = tail_.load(std::memory_order_relaxed);\n            size_t nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail != head_.load(std::memory_order_acquire)) {\n                data_[currentTail] = item;\n                tail_.store(nextTail, std::memory_order_release);\n                return;\n            }\n            // 队列已满，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        while (true) {\n            size_t currentHead = head_.load(std::memory_order_relaxed);\n            size_t currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead != currentTail) {\n                T item = data_[currentHead];\n                head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n                return item;\n            }\n            // 队列为空，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead != currentTail) {\n            item = data_[currentHead];\n            head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n```\n## 对代码的分析\n从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。\n可以简单分析一下，这轮优化过程中使用到的一些知识点：\n### 为什么舍弃条件变量\n**std::condition_variable** 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用**condition_variable** 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。\n但是**condition_variable** 必须搭配mutex使用，在我们限定无锁编程的情况下，**condition_variable** 显然是无法被采用的，所以被舍弃了。\n### 阻塞写时安全性论证\n```cpp\nvoid Enqueue(const T& item) {\n    while (true) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return;\n        }\n        // 队列已满，等待\n        std::this_thread::yield();\n    }\n}\n```\n这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。\n**错误一：**\n下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。\n```cpp\nsize_t currentTail = tail_.load(std::memory_order_relaxed);\nsize_t nextTail = (currentTail + 1) % capacity_;\n```\n**错误二：**\n虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。\n```cpp\nif (nextTail != head_.load(std::memory_order_acquire)) {\n    data_[currentTail] = item;\n    // something else\n}\n```\n所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。\n# Gpt的第三轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                // 队列已满，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = item;\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail == head_.load(std::memory_order_acquire))\n            return false;\n\n        if (tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行写入操作\n            data_[currentTail] = item;\n            return true;\n        }\n\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                // 队列为空，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        return data_[currentHead];\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead == currentTail)\n            return false;\n\n        if (head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行读取操作\n            item = data_[currentHead];\n            return true;\n        }\n\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n## 对代码的分析\n我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：\n```cpp\nvoid Enqueue(const T& item) {\n    size_t currentTail;\n    size_t nextTail;\n    do {\n        currentTail = tail_.load(std::memory_order_relaxed);\n        nextTail = (currentTail + 1) % capacity_;\n        if (nextTail == head_.load(std::memory_order_acquire)) {\n            // 队列已满，等待\n            std::this_thread::yield();\n            continue;\n        }\n        // 尝试使用CAS进行原子操作\n    } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n    // CAS成功，可以进行写入操作\n    data_[currentTail] = item;\n}\n```\n在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。\n# 一些更远的优化点\n此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。\n\n1. 阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。\n2. 该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。\n\n改良后的代码如下：\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 通用的入队操作\n    template <typename U>\n    bool Enqueue(U&& item, bool blocking = true) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = std::forward<U>(item);\n        return true;\n    }\n\n    // 通用的出队操作\n    template <typename U>\n    bool Dequeue(U& item, bool blocking = true) {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        item = std::move(data_[currentHead]);\n        return true;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n\n","slug":"Look-free-circular-queue","published":1,"updated":"2024-02-02T05:57:50.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls48hpdw0000ecx576pb11hl","content":"<p>想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。</p>\n<h1 id=\"需求的自然语言描述\"><a href=\"#需求的自然语言描述\" class=\"headerlink\" title=\"需求的自然语言描述\"></a>需求的自然语言描述</h1><p>用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释<br>具体要求如下：</p>\n<ol>\n<li>环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写</li>\n<li>支持模板，存放的数据类型可以自定义</li>\n<li>代码风格使用google C++风格</li>\n<li>在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由</li>\n</ol>\n<h1 id=\"Gpt第一轮尝试\"><a href=\"#Gpt第一轮尝试\" class=\"headerlink\" title=\"Gpt第一轮尝试\"></a>Gpt第一轮尝试</h1><h2 id=\"Gpt给出的结果\"><a href=\"#Gpt给出的结果\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的循环队列模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>() &lt; capacity_; &#125;);</span><br><span class=\"line\">        queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue_.<span class=\"built_in\">size</span>() &lt; capacity_) &#123;</span><br><span class=\"line\">            queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">            notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> !queue_.<span class=\"built_in\">empty</span>(); &#125;);</span><br><span class=\"line\">        T item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::queue&lt;T&gt; queue_;</span><br><span class=\"line\">    std::mutex mutex_;</span><br><span class=\"line\">    std::condition_variable notFull_;</span><br><span class=\"line\">    std::condition_variable notEmpty_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析\"><a href=\"#对代码的分析\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>代码最低限度地实现了我们提出的需求，比如阻塞&#x2F;非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。</p>\n<ol>\n<li>可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。</li>\n<li>gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。</li>\n</ol>\n<h1 id=\"Gpt的第二轮尝试\"><a href=\"#Gpt的第二轮尝试\" class=\"headerlink\" title=\"Gpt的第二轮尝试\"></a>Gpt的第二轮尝试</h1><h2 id=\"对功能修改的描述\"><a href=\"#对功能修改的描述\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>由于采用deque的数据结构，导致存在动态分配内存的开销</li>\n<li>mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作</li>\n</ol>\n<h2 id=\"Gpt给出的结果-1\"><a href=\"#Gpt给出的结果-1\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                data_[currentTail] = item;</span><br><span class=\"line\">                tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">                T item = data_[currentHead];</span><br><span class=\"line\">                head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-1\"><a href=\"#对代码的分析-1\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。<br>可以简单分析一下，这轮优化过程中使用到的一些知识点：</p>\n<h3 id=\"为什么舍弃条件变量\"><a href=\"#为什么舍弃条件变量\" class=\"headerlink\" title=\"为什么舍弃条件变量\"></a>为什么舍弃条件变量</h3><p><strong>std::condition_variable</strong> 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用<strong>condition_variable</strong> 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。<br>但是<strong>condition_variable</strong> 必须搭配mutex使用，在我们限定无锁编程的情况下，<strong>condition_variable</strong> 显然是无法被采用的，所以被舍弃了。</p>\n<h3 id=\"阻塞写时安全性论证\"><a href=\"#阻塞写时安全性论证\" class=\"headerlink\" title=\"阻塞写时安全性论证\"></a>阻塞写时安全性论证</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。<br><strong>错误一：</strong><br>下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\"><span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br></pre></td></tr></table></figure>\n<p><strong>错误二：</strong><br>虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">    <span class=\"comment\">// something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。</p>\n<h1 id=\"Gpt的第三轮尝试\"><a href=\"#Gpt的第三轮尝试\" class=\"headerlink\" title=\"Gpt的第三轮尝试\"></a>Gpt的第三轮尝试</h1><h2 id=\"对功能修改的描述-1\"><a href=\"#对功能修改的描述-1\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化</li>\n</ol>\n<h2 id=\"Gpt给出的结果-2\"><a href=\"#Gpt给出的结果-2\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data_[currentHead];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead == currentTail)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-2\"><a href=\"#对代码的分析-2\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\">    <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。</p>\n<h1 id=\"一些更远的优化点\"><a href=\"#一些更远的优化点\" class=\"headerlink\" title=\"一些更远的优化点\"></a>一些更远的优化点</h1><p>此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。</p>\n<ol>\n<li>阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。</li>\n<li>该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。</li>\n</ol>\n<p>改良后的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的入队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Enqueue</span><span class=\"params\">(U&amp;&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = std::forward&lt;U&gt;(item);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的出队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Dequeue</span><span class=\"params\">(U&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        item = std::<span class=\"built_in\">move</span>(data_[currentHead]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。</p>\n<h1 id=\"需求的自然语言描述\"><a href=\"#需求的自然语言描述\" class=\"headerlink\" title=\"需求的自然语言描述\"></a>需求的自然语言描述</h1><p>用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释<br>具体要求如下：</p>\n<ol>\n<li>环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写</li>\n<li>支持模板，存放的数据类型可以自定义</li>\n<li>代码风格使用google C++风格</li>\n<li>在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由</li>\n</ol>\n<h1 id=\"Gpt第一轮尝试\"><a href=\"#Gpt第一轮尝试\" class=\"headerlink\" title=\"Gpt第一轮尝试\"></a>Gpt第一轮尝试</h1><h2 id=\"Gpt给出的结果\"><a href=\"#Gpt给出的结果\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的循环队列模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>() &lt; capacity_; &#125;);</span><br><span class=\"line\">        queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue_.<span class=\"built_in\">size</span>() &lt; capacity_) &#123;</span><br><span class=\"line\">            queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">            notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> !queue_.<span class=\"built_in\">empty</span>(); &#125;);</span><br><span class=\"line\">        T item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::queue&lt;T&gt; queue_;</span><br><span class=\"line\">    std::mutex mutex_;</span><br><span class=\"line\">    std::condition_variable notFull_;</span><br><span class=\"line\">    std::condition_variable notEmpty_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析\"><a href=\"#对代码的分析\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>代码最低限度地实现了我们提出的需求，比如阻塞&#x2F;非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。</p>\n<ol>\n<li>可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。</li>\n<li>gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。</li>\n</ol>\n<h1 id=\"Gpt的第二轮尝试\"><a href=\"#Gpt的第二轮尝试\" class=\"headerlink\" title=\"Gpt的第二轮尝试\"></a>Gpt的第二轮尝试</h1><h2 id=\"对功能修改的描述\"><a href=\"#对功能修改的描述\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>由于采用deque的数据结构，导致存在动态分配内存的开销</li>\n<li>mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作</li>\n</ol>\n<h2 id=\"Gpt给出的结果-1\"><a href=\"#Gpt给出的结果-1\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                data_[currentTail] = item;</span><br><span class=\"line\">                tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">                T item = data_[currentHead];</span><br><span class=\"line\">                head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-1\"><a href=\"#对代码的分析-1\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。<br>可以简单分析一下，这轮优化过程中使用到的一些知识点：</p>\n<h3 id=\"为什么舍弃条件变量\"><a href=\"#为什么舍弃条件变量\" class=\"headerlink\" title=\"为什么舍弃条件变量\"></a>为什么舍弃条件变量</h3><p><strong>std::condition_variable</strong> 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用<strong>condition_variable</strong> 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。<br>但是<strong>condition_variable</strong> 必须搭配mutex使用，在我们限定无锁编程的情况下，<strong>condition_variable</strong> 显然是无法被采用的，所以被舍弃了。</p>\n<h3 id=\"阻塞写时安全性论证\"><a href=\"#阻塞写时安全性论证\" class=\"headerlink\" title=\"阻塞写时安全性论证\"></a>阻塞写时安全性论证</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。<br><strong>错误一：</strong><br>下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\"><span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br></pre></td></tr></table></figure>\n<p><strong>错误二：</strong><br>虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">    <span class=\"comment\">// something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。</p>\n<h1 id=\"Gpt的第三轮尝试\"><a href=\"#Gpt的第三轮尝试\" class=\"headerlink\" title=\"Gpt的第三轮尝试\"></a>Gpt的第三轮尝试</h1><h2 id=\"对功能修改的描述-1\"><a href=\"#对功能修改的描述-1\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化</li>\n</ol>\n<h2 id=\"Gpt给出的结果-2\"><a href=\"#Gpt给出的结果-2\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data_[currentHead];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead == currentTail)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-2\"><a href=\"#对代码的分析-2\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\">    <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。</p>\n<h1 id=\"一些更远的优化点\"><a href=\"#一些更远的优化点\" class=\"headerlink\" title=\"一些更远的优化点\"></a>一些更远的优化点</h1><p>此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。</p>\n<ol>\n<li>阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。</li>\n<li>该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。</li>\n</ol>\n<p>改良后的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的入队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Enqueue</span><span class=\"params\">(U&amp;&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = std::forward&lt;U&gt;(item);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的出队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Dequeue</span><span class=\"params\">(U&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        item = std::<span class=\"built_in\">move</span>(data_[currentHead]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"共享内存（二）：POSIX Api","date":"2024-02-02T06:31:42.000Z","_content":"POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。\n# POSIX Api简介\nPOSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在/dev/shm下创建一个文件，并将其mmap之后映射其内存地址即可。\n# mmap系列函数简介\nmmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。\n## mmap函数主要的作用\n\n- 对普通文件提供内存映射I/O，可以提供无亲缘进程间的通信；\n- 提供匿名内存映射，以供亲缘进程间进行通信。\n-  对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。\n## mmap函数主要的API\n### mmap 映射内存\nmmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。\n```cpp\n/**\n* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址\n* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0\n* prot：内存映射区的保护由该参数来设定\n* \tPROT_READ：数据可读\n* \tPROT_WRITE：数据可写\n* \tPROT_EXEC：数据可执行\n* \tPROT_NONE：数据不可访问\n* flags：设置内存映射区的类型标志\n* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象\n* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象\n*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志\n*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制\n* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1\n* offset：相对文件的起始偏移\n*/\nvoid *mmap(void *start, \n           size_t len, \n           int prot, \n           int flags, \n           int fd, \n           off_t offset);\n```\n\n![image.png](/images/shared-mem/2.png)\n### munmap删除映射\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n*/\nint munmap(void *start, size_t len);\n```\n### msync实时同步\n对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n* flags：同步标志\n*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；\n*\tMS_SYNC：同步写，要等到写操作完成后才返回。\n*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。\n*/\nint msync(void *start, size_t len, int flags);\n```\n## mmap实现线程中通信\n### 通过匿名内存映射提供亲缘进程间的通信\n我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。\n在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。\n简化测试代码：\n```cpp\nint main(int argc, char **argv)\n{\n    int *memPtr;\n    memPtr = (int *) mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, 0, 0);\n    if (memPtr == MAP_FAILED)\treturn -1;\n    *memPtr = 0;\n    if (fork() == 0)\n    {\n        *memPtr = 1;\n        cout<<\"child:set memory \"<<*memPtr<<endl;\n        exit(0);\n    }\n    sleep(1);\n    cout<<\"parent:memory value \"<<*memPtr<<endl;\n    return 0;\n}\n```\n### 通过内存映射文件提供无亲缘进程间的通信\n通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。\n简化测试代码：\n```cpp\n//process 1\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(int));\n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    *memPtr = 111;\n\tcout<<\"process:\"<<getpid()<<\" send:\"<<*memPtr<<endl;\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    cout<<\"process:\"<<getpid()<<\" receive:\"<<*memPtr<<endl;\n \n    return 0;\n}\n```\n# 基于mmap的POSIX共享内存\n## 具体步骤\n\n1. 通过shm_open创建或打开一个POSIX共享内存对象\n2. 然后调用mmap将它映射到当前进程的地址空间\n## POSIX共享内存底层支撑对象\n![image.png](/images/shared-mem/3.png)\n### 内存映射文件(memory-mapped file)\n由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。\n### 主流：共享内存区对象(shared-memory object)\n由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。\n## 共享内存区对象API\n### shm_open打开共享内存区\nshm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。\n```cpp\n/**\n* name：POSIX IPC的名字\n* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。\n* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项\n* mode：用于设置创建的共享内存区对象的权限属性。\n* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0\n*/\nint shm_open(const char *name, int oflag, mode_t mode);\n```\n### shm_unlink删除共享内存对象\nshm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。\n```cpp\nint shm_unlink(const char *name);\n```\n### 代码简单测试实例\n```cpp\n//process 1\n#define SHM_NAME \"/memmap\"\n#define SHM_NAME_SEM \"/memmap_sem\" \nchar sharedMem[10];\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR | O_CREAT, 0666);\n    sem = sem_open(SHM_NAME_SEM, O_CREAT, 0666, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(sharedMem));\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, sizeof(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    char msg[] = \"yuki...\";\n \n    memmove(memPtr, msg, sizeof(msg));\n    cout<<\"process:\"<<getpid()<<\" send:\"<<memPtr<<endl;\n \n    sem_post(sem);\n    sem_close(sem);\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR, 0);\n    sem = sem_open(SHM_NAME_SEM, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    struct stat fileStat;\n    fstat(fd, &fileStat);\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    sem_wait(sem);\n \n    cout<<\"process:\"<<getpid()<<\" recv:\"<<memPtr<<endl;\n \n    sem_close(sem);\n \n    return 0;\n}\n```\n\n","source":"_posts/Poxis-api.md","raw":"---\ntitle: 共享内存（二）：POSIX Api\ndate: 2024-02-02 14:31:42\ntags: 共享内存\n---\nPOSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。\n# POSIX Api简介\nPOSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在/dev/shm下创建一个文件，并将其mmap之后映射其内存地址即可。\n# mmap系列函数简介\nmmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。\n## mmap函数主要的作用\n\n- 对普通文件提供内存映射I/O，可以提供无亲缘进程间的通信；\n- 提供匿名内存映射，以供亲缘进程间进行通信。\n-  对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。\n## mmap函数主要的API\n### mmap 映射内存\nmmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。\n```cpp\n/**\n* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址\n* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0\n* prot：内存映射区的保护由该参数来设定\n* \tPROT_READ：数据可读\n* \tPROT_WRITE：数据可写\n* \tPROT_EXEC：数据可执行\n* \tPROT_NONE：数据不可访问\n* flags：设置内存映射区的类型标志\n* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象\n* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象\n*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志\n*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制\n* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1\n* offset：相对文件的起始偏移\n*/\nvoid *mmap(void *start, \n           size_t len, \n           int prot, \n           int flags, \n           int fd, \n           off_t offset);\n```\n\n![image.png](/images/shared-mem/2.png)\n### munmap删除映射\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n*/\nint munmap(void *start, size_t len);\n```\n### msync实时同步\n对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n* flags：同步标志\n*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；\n*\tMS_SYNC：同步写，要等到写操作完成后才返回。\n*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。\n*/\nint msync(void *start, size_t len, int flags);\n```\n## mmap实现线程中通信\n### 通过匿名内存映射提供亲缘进程间的通信\n我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。\n在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。\n简化测试代码：\n```cpp\nint main(int argc, char **argv)\n{\n    int *memPtr;\n    memPtr = (int *) mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, 0, 0);\n    if (memPtr == MAP_FAILED)\treturn -1;\n    *memPtr = 0;\n    if (fork() == 0)\n    {\n        *memPtr = 1;\n        cout<<\"child:set memory \"<<*memPtr<<endl;\n        exit(0);\n    }\n    sleep(1);\n    cout<<\"parent:memory value \"<<*memPtr<<endl;\n    return 0;\n}\n```\n### 通过内存映射文件提供无亲缘进程间的通信\n通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。\n简化测试代码：\n```cpp\n//process 1\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(int));\n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    *memPtr = 111;\n\tcout<<\"process:\"<<getpid()<<\" send:\"<<*memPtr<<endl;\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    cout<<\"process:\"<<getpid()<<\" receive:\"<<*memPtr<<endl;\n \n    return 0;\n}\n```\n# 基于mmap的POSIX共享内存\n## 具体步骤\n\n1. 通过shm_open创建或打开一个POSIX共享内存对象\n2. 然后调用mmap将它映射到当前进程的地址空间\n## POSIX共享内存底层支撑对象\n![image.png](/images/shared-mem/3.png)\n### 内存映射文件(memory-mapped file)\n由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。\n### 主流：共享内存区对象(shared-memory object)\n由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。\n## 共享内存区对象API\n### shm_open打开共享内存区\nshm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。\n```cpp\n/**\n* name：POSIX IPC的名字\n* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。\n* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项\n* mode：用于设置创建的共享内存区对象的权限属性。\n* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0\n*/\nint shm_open(const char *name, int oflag, mode_t mode);\n```\n### shm_unlink删除共享内存对象\nshm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。\n```cpp\nint shm_unlink(const char *name);\n```\n### 代码简单测试实例\n```cpp\n//process 1\n#define SHM_NAME \"/memmap\"\n#define SHM_NAME_SEM \"/memmap_sem\" \nchar sharedMem[10];\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR | O_CREAT, 0666);\n    sem = sem_open(SHM_NAME_SEM, O_CREAT, 0666, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(sharedMem));\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, sizeof(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    char msg[] = \"yuki...\";\n \n    memmove(memPtr, msg, sizeof(msg));\n    cout<<\"process:\"<<getpid()<<\" send:\"<<memPtr<<endl;\n \n    sem_post(sem);\n    sem_close(sem);\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR, 0);\n    sem = sem_open(SHM_NAME_SEM, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    struct stat fileStat;\n    fstat(fd, &fileStat);\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    sem_wait(sem);\n \n    cout<<\"process:\"<<getpid()<<\" recv:\"<<memPtr<<endl;\n \n    sem_close(sem);\n \n    return 0;\n}\n```\n\n","slug":"Poxis-api","published":1,"updated":"2024-02-02T06:44:33.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4a5r4h0000pjx585w7f6ng","content":"<p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。</p>\n<h1 id=\"POSIX-Api简介\"><a href=\"#POSIX-Api简介\" class=\"headerlink\" title=\"POSIX Api简介\"></a>POSIX Api简介</h1><p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在&#x2F;dev&#x2F;shm下创建一个文件，并将其mmap之后映射其内存地址即可。</p>\n<h1 id=\"mmap系列函数简介\"><a href=\"#mmap系列函数简介\" class=\"headerlink\" title=\"mmap系列函数简介\"></a>mmap系列函数简介</h1><p>mmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。</p>\n<h2 id=\"mmap函数主要的作用\"><a href=\"#mmap函数主要的作用\" class=\"headerlink\" title=\"mmap函数主要的作用\"></a>mmap函数主要的作用</h2><ul>\n<li>对普通文件提供内存映射I&#x2F;O，可以提供无亲缘进程间的通信；</li>\n<li>提供匿名内存映射，以供亲缘进程间进行通信。</li>\n<li>对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。</li>\n</ul>\n<h2 id=\"mmap函数主要的API\"><a href=\"#mmap函数主要的API\" class=\"headerlink\" title=\"mmap函数主要的API\"></a>mmap函数主要的API</h2><h3 id=\"mmap-映射内存\"><a href=\"#mmap-映射内存\" class=\"headerlink\" title=\"mmap 映射内存\"></a>mmap 映射内存</h3><p>mmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0</span></span><br><span class=\"line\"><span class=\"comment\">* prot：内存映射区的保护由该参数来设定</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_READ：数据可读</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_WRITE：数据可写</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_EXEC：数据可执行</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_NONE：数据不可访问</span></span><br><span class=\"line\"><span class=\"comment\">* flags：设置内存映射区的类型标志</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制</span></span><br><span class=\"line\"><span class=\"comment\">* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1</span></span><br><span class=\"line\"><span class=\"comment\">* offset：相对文件的起始偏移</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">size_t</span> len, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> prot, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> flags, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> fd, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/shared-mem/2.png\" alt=\"image.png\"></p>\n<h3 id=\"munmap删除映射\"><a href=\"#munmap删除映射\" class=\"headerlink\" title=\"munmap删除映射\"></a>munmap删除映射</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"msync实时同步\"><a href=\"#msync实时同步\" class=\"headerlink\" title=\"msync实时同步\"></a>msync实时同步</h3><p>对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">* flags：同步标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_SYNC：同步写，要等到写操作完成后才返回。</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">msync</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mmap实现线程中通信\"><a href=\"#mmap实现线程中通信\" class=\"headerlink\" title=\"mmap实现线程中通信\"></a>mmap实现线程中通信</h2><h3 id=\"通过匿名内存映射提供亲缘进程间的通信\"><a href=\"#通过匿名内存映射提供亲缘进程间的通信\" class=\"headerlink\" title=\"通过匿名内存映射提供亲缘进程间的通信\"></a>通过匿名内存映射提供亲缘进程间的通信</h3><p>我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。<br>在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *) <span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    *memPtr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fork() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *memPtr = <span class=\"number\">1</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;child:set memory &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;parent:memory value &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过内存映射文件提供无亲缘进程间的通信\"><a href=\"#通过内存映射文件提供无亲缘进程间的通信\" class=\"headerlink\" title=\"通过内存映射文件提供无亲缘进程间的通信\"></a>通过内存映射文件提供无亲缘进程间的通信</h3><p>通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    *memPtr = <span class=\"number\">111</span>;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; receive:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基于mmap的POSIX共享内存\"><a href=\"#基于mmap的POSIX共享内存\" class=\"headerlink\" title=\"基于mmap的POSIX共享内存\"></a>基于mmap的POSIX共享内存</h1><h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><ol>\n<li>通过shm_open创建或打开一个POSIX共享内存对象</li>\n<li>然后调用mmap将它映射到当前进程的地址空间</li>\n</ol>\n<h2 id=\"POSIX共享内存底层支撑对象\"><a href=\"#POSIX共享内存底层支撑对象\" class=\"headerlink\" title=\"POSIX共享内存底层支撑对象\"></a>POSIX共享内存底层支撑对象</h2><p><img src=\"/images/shared-mem/3.png\" alt=\"image.png\"></p>\n<h3 id=\"内存映射文件-memory-mapped-file\"><a href=\"#内存映射文件-memory-mapped-file\" class=\"headerlink\" title=\"内存映射文件(memory-mapped file)\"></a>内存映射文件(memory-mapped file)</h3><p>由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。</p>\n<h3 id=\"主流：共享内存区对象-shared-memory-object\"><a href=\"#主流：共享内存区对象-shared-memory-object\" class=\"headerlink\" title=\"主流：共享内存区对象(shared-memory object)\"></a>主流：共享内存区对象(shared-memory object)</h3><p>由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。</p>\n<h2 id=\"共享内存区对象API\"><a href=\"#共享内存区对象API\" class=\"headerlink\" title=\"共享内存区对象API\"></a>共享内存区对象API</h2><h3 id=\"shm-open打开共享内存区\"><a href=\"#shm-open打开共享内存区\" class=\"headerlink\" title=\"shm_open打开共享内存区\"></a>shm_open打开共享内存区</h3><p>shm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* name：POSIX IPC的名字</span></span><br><span class=\"line\"><span class=\"comment\">* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。</span></span><br><span class=\"line\"><span class=\"comment\">* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项</span></span><br><span class=\"line\"><span class=\"comment\">* mode：用于设置创建的共享内存区对象的权限属性。</span></span><br><span class=\"line\"><span class=\"comment\">* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">int</span> oflag, <span class=\"type\">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"shm-unlink删除共享内存对象\"><a href=\"#shm-unlink删除共享内存对象\" class=\"headerlink\" title=\"shm_unlink删除共享内存对象\"></a>shm_unlink删除共享内存对象</h3><p>shm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_unlink</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码简单测试实例\"><a href=\"#代码简单测试实例\" class=\"headerlink\" title=\"代码简单测试实例\"></a>代码简单测试实例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME <span class=\"string\">&quot;/memmap&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME_SEM <span class=\"string\">&quot;/memmap_sem&quot;</span> </span></span><br><span class=\"line\"><span class=\"type\">char</span> sharedMem[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, O_CREAT, <span class=\"number\">0666</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(sharedMem));</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;yuki...&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">memmove</span>(memPtr, msg, <span class=\"built_in\">sizeof</span>(msg));</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_post</span>(sem);</span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> fileStat;</span><br><span class=\"line\">    <span class=\"built_in\">fstat</span>(fd, &amp;fileStat);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_wait</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; recv:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。</p>\n<h1 id=\"POSIX-Api简介\"><a href=\"#POSIX-Api简介\" class=\"headerlink\" title=\"POSIX Api简介\"></a>POSIX Api简介</h1><p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在&#x2F;dev&#x2F;shm下创建一个文件，并将其mmap之后映射其内存地址即可。</p>\n<h1 id=\"mmap系列函数简介\"><a href=\"#mmap系列函数简介\" class=\"headerlink\" title=\"mmap系列函数简介\"></a>mmap系列函数简介</h1><p>mmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。</p>\n<h2 id=\"mmap函数主要的作用\"><a href=\"#mmap函数主要的作用\" class=\"headerlink\" title=\"mmap函数主要的作用\"></a>mmap函数主要的作用</h2><ul>\n<li>对普通文件提供内存映射I&#x2F;O，可以提供无亲缘进程间的通信；</li>\n<li>提供匿名内存映射，以供亲缘进程间进行通信。</li>\n<li>对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。</li>\n</ul>\n<h2 id=\"mmap函数主要的API\"><a href=\"#mmap函数主要的API\" class=\"headerlink\" title=\"mmap函数主要的API\"></a>mmap函数主要的API</h2><h3 id=\"mmap-映射内存\"><a href=\"#mmap-映射内存\" class=\"headerlink\" title=\"mmap 映射内存\"></a>mmap 映射内存</h3><p>mmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0</span></span><br><span class=\"line\"><span class=\"comment\">* prot：内存映射区的保护由该参数来设定</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_READ：数据可读</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_WRITE：数据可写</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_EXEC：数据可执行</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_NONE：数据不可访问</span></span><br><span class=\"line\"><span class=\"comment\">* flags：设置内存映射区的类型标志</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制</span></span><br><span class=\"line\"><span class=\"comment\">* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1</span></span><br><span class=\"line\"><span class=\"comment\">* offset：相对文件的起始偏移</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">size_t</span> len, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> prot, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> flags, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> fd, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/shared-mem/2.png\" alt=\"image.png\"></p>\n<h3 id=\"munmap删除映射\"><a href=\"#munmap删除映射\" class=\"headerlink\" title=\"munmap删除映射\"></a>munmap删除映射</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"msync实时同步\"><a href=\"#msync实时同步\" class=\"headerlink\" title=\"msync实时同步\"></a>msync实时同步</h3><p>对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">* flags：同步标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_SYNC：同步写，要等到写操作完成后才返回。</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">msync</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mmap实现线程中通信\"><a href=\"#mmap实现线程中通信\" class=\"headerlink\" title=\"mmap实现线程中通信\"></a>mmap实现线程中通信</h2><h3 id=\"通过匿名内存映射提供亲缘进程间的通信\"><a href=\"#通过匿名内存映射提供亲缘进程间的通信\" class=\"headerlink\" title=\"通过匿名内存映射提供亲缘进程间的通信\"></a>通过匿名内存映射提供亲缘进程间的通信</h3><p>我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。<br>在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *) <span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    *memPtr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fork() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *memPtr = <span class=\"number\">1</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;child:set memory &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;parent:memory value &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过内存映射文件提供无亲缘进程间的通信\"><a href=\"#通过内存映射文件提供无亲缘进程间的通信\" class=\"headerlink\" title=\"通过内存映射文件提供无亲缘进程间的通信\"></a>通过内存映射文件提供无亲缘进程间的通信</h3><p>通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    *memPtr = <span class=\"number\">111</span>;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; receive:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基于mmap的POSIX共享内存\"><a href=\"#基于mmap的POSIX共享内存\" class=\"headerlink\" title=\"基于mmap的POSIX共享内存\"></a>基于mmap的POSIX共享内存</h1><h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><ol>\n<li>通过shm_open创建或打开一个POSIX共享内存对象</li>\n<li>然后调用mmap将它映射到当前进程的地址空间</li>\n</ol>\n<h2 id=\"POSIX共享内存底层支撑对象\"><a href=\"#POSIX共享内存底层支撑对象\" class=\"headerlink\" title=\"POSIX共享内存底层支撑对象\"></a>POSIX共享内存底层支撑对象</h2><p><img src=\"/images/shared-mem/3.png\" alt=\"image.png\"></p>\n<h3 id=\"内存映射文件-memory-mapped-file\"><a href=\"#内存映射文件-memory-mapped-file\" class=\"headerlink\" title=\"内存映射文件(memory-mapped file)\"></a>内存映射文件(memory-mapped file)</h3><p>由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。</p>\n<h3 id=\"主流：共享内存区对象-shared-memory-object\"><a href=\"#主流：共享内存区对象-shared-memory-object\" class=\"headerlink\" title=\"主流：共享内存区对象(shared-memory object)\"></a>主流：共享内存区对象(shared-memory object)</h3><p>由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。</p>\n<h2 id=\"共享内存区对象API\"><a href=\"#共享内存区对象API\" class=\"headerlink\" title=\"共享内存区对象API\"></a>共享内存区对象API</h2><h3 id=\"shm-open打开共享内存区\"><a href=\"#shm-open打开共享内存区\" class=\"headerlink\" title=\"shm_open打开共享内存区\"></a>shm_open打开共享内存区</h3><p>shm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* name：POSIX IPC的名字</span></span><br><span class=\"line\"><span class=\"comment\">* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。</span></span><br><span class=\"line\"><span class=\"comment\">* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项</span></span><br><span class=\"line\"><span class=\"comment\">* mode：用于设置创建的共享内存区对象的权限属性。</span></span><br><span class=\"line\"><span class=\"comment\">* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">int</span> oflag, <span class=\"type\">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"shm-unlink删除共享内存对象\"><a href=\"#shm-unlink删除共享内存对象\" class=\"headerlink\" title=\"shm_unlink删除共享内存对象\"></a>shm_unlink删除共享内存对象</h3><p>shm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_unlink</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码简单测试实例\"><a href=\"#代码简单测试实例\" class=\"headerlink\" title=\"代码简单测试实例\"></a>代码简单测试实例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME <span class=\"string\">&quot;/memmap&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME_SEM <span class=\"string\">&quot;/memmap_sem&quot;</span> </span></span><br><span class=\"line\"><span class=\"type\">char</span> sharedMem[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, O_CREAT, <span class=\"number\">0666</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(sharedMem));</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;yuki...&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">memmove</span>(memPtr, msg, <span class=\"built_in\">sizeof</span>(msg));</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_post</span>(sem);</span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> fileStat;</span><br><span class=\"line\">    <span class=\"built_in\">fstat</span>(fd, &amp;fileStat);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_wait</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; recv:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"共享内存（一）：SystemV Api","date":"2024-02-02T06:31:01.000Z","_content":"SymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。\n#  基本API\n## shmget 获取共享内存 \n使用shmget函数获取共享内存，函数原型如下：\n```cpp\n/**\n* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源\n* 参数 size 指定创建的共享内存大小\n* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存\n* 函数调用成功时返回一个新建或已经存在的的共享内存标识符\n* 取决于shmflg的参数。失败返回-1，并设置错误码\n*/\nint shmget(key_t key, size_t size, int shmflg);\n```\nshmget函数返回的是一个标识符，而不是可用的内存地址。\n## shmat 关联共享内存\n使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：\n```cpp\n/**\n* 参数 shmid 是 shmget() 函数返回的标识符\n* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址\n* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段\n* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1\n*/\nvoid *shmat(int shmid, const void *shmaddr, int shmflg);\n```\n## shmdt 取消关联共享内存\n当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：\n```cpp\n/**\n* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值\n* 函数调用成功返回0，出错返回-1\n*/\nint shmdt(const void *shmaddr);\n```\n# 共享内存原理\n概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。\n![image.png](/images/shared-mem/1.png)\n在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。\n```cpp\n/**\n* 用于管理共享内存的信息\n*/\nstruct shmid_ds {\n struct ipc_perm  shm_perm; /* operation perms */\n int   shm_segsz; /* size of segment (bytes) */\n __kernel_time_t  shm_atime; /* last attach time */\n __kernel_time_t  shm_dtime; /* last detach time */\n __kernel_time_t  shm_ctime; /* last change time */\n __kernel_ipc_pid_t shm_cpid; /* pid of creator */\n __kernel_ipc_pid_t shm_lpid; /* pid of last operator */\n unsigned short  shm_nattch; /* no. of current attaches */\n unsigned short   shm_unused; /* compatibility */\n void    *shm_unused2; /* ditto - used by DIPC */\n void   *shm_unused3; /* unused */\n};\n\nstruct shmid_kernel\n{ \n struct shmid_ds  u;\n /* the following are private */\n unsigned long  shm_npages; /* size of segment (pages) */\n pte_t   *shm_pages; /* array of ptrs to frames -> SHMMAX */ \n struct vm_area_struct *attaches; /* descriptors for attaches */\n};\n\n/**\n* shm_segs数组 用于管理系统中所有的共享内存\n*/\nstatic struct shmid_kernel *shm_segs[SHMMNI]; // SHMMNI等于128\n```\n## shmget 函数实现\nshmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。\n```cpp\nasmlinkage long sys_shmget (key_t key, int size, int shmflg)\n{\n struct shmid_kernel *shp;\n int err, id = 0;\n\n down(&current->mm->mmap_sem);\n spin_lock(&shm_lock);\n if (size < 0 || size > shmmax) \n {\n      err = -EINVAL;\n } else if (key == IPC_PRIVATE) \n {\n      err = newseg(key, shmflg, size);\n } else if ((id = findkey (key)) == -1) \n {\n      if (!(shmflg & IPC_CREAT))\n           err = -ENOENT;\n      else\n           err = newseg(key, shmflg, size);\n } else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL)) \n {\n      err = -EEXIST;\n } else {\n      shp = shm_segs[id];\n      if (shp->u.shm_perm.mode & SHM_DEST)\n           err = -EIDRM;\n      else if (size > shp->u.shm_segsz)\n           err = -EINVAL;\n      else if (ipcperms (&shp->u.shm_perm, shmflg))\n           err = -EACCES;\n      else\n           err = (int) shp->u.shm_perm.seq * SHMMNI + id;\n }\n spin_unlock(&shm_lock);\n up(&current->mm->mmap_sem);\n return err;\n}\n```\n## shmat 函数实现\n```cpp\nasmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *raddr)\n{\n    struct shmid_kernel *shp;\n    struct vm_area_struct *shmd;\n    int err = -EINVAL;\n    unsigned int id;\n    unsigned long addr;\n    unsigned long len;\n\n    down(&current->mm->mmap_sem);\n    spin_lock(&shm_lock);\n    if (shmid < 0)\t\t\n        goto out;\n\n   /**\n   * 通过 shmid 标识符来找到共享内存描述符\n   * 系统中所有的共享内存到保存在 shm_segs 数组中\n   */\n    shp = shm_segs[id = (unsigned int) shmid % SHMMNI];\n    if (shp == IPC_UNUSED || shp == IPC_NOID)\t\t\n        goto out;\n   \n    /**\n    * 找到一个可用的虚拟内存地址\n    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址\n    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址\n    */\n    if (!(addr = (ulong) shmaddr)) {\n         if (shmflg & SHM_REMAP)\n              goto out;\n         err = -ENOMEM;\n         addr = 0;\n         again:\n             //获取一个空闲的虚拟内存空间\n             if (!(addr = get_unmapped_area(addr, shp->u.shm_segsz))) \n                  goto out;\n             if(addr & (SHMLBA - 1)) \n             {\n                  addr = (addr + (SHMLBA - 1)) & ~(SHMLBA - 1);\n                  goto again;\n              }\n    } else if (addr & (SHMLBA-1)) \n    {\n         if (shmflg & SHM_RND)\n              addr &= ~(SHMLBA-1);       /* round down */\n         else\n              goto out;\n    }\n   \n    /**\n    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，\n    * vm_area_struct 结构用于管理进程的虚拟内存空间\n    */\n    spin_unlock(&shm_lock);\n    err = -ENOMEM;\n    shmd = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);\n    spin_lock(&shm_lock);\n    if (!shmd)\n         goto out;\n    if ((shp != shm_segs[id]) || (shp->u.shm_perm.seq != (unsigned int) shmid / SHMMNI)) \n    {\n         kmem_cache_free(vm_area_cachep, shmd);\n         err = -EIDRM;\n         goto out;\n    }\n   \n    /**\n    * 设置刚创建的 vm_area_struct 结构的各个字段\n    */\n    shmd->vm_private_data = shm_segs + id;\n    shmd->vm_start = addr;\n    shmd->vm_end = addr + shp->shm_npages * PAGE_SIZE;\n    shmd->vm_mm = current->mm;\n    shmd->vm_page_prot = (shmflg & SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;\n    shmd->vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED\n       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC\n       | ((shmflg & SHM_RDONLY) ? 0 : VM_MAYWRITE | VM_WRITE);\n    shmd->vm_file = NULL;\n    shmd->vm_offset = 0;\n    //这个字段比较重要，数据结构如下\n    shmd->vm_ops = &shm_vm_ops;\n    //shm_vm_ops 的 nopage 回调为 shm_nopage() 函数\n    //当发生页缺失异常时将会调用此函数来恢复内存的映射\n    /**\n    * static struct vm_operations_struct shm_vm_ops = {\n    * \tshm_open,  //open - callback for a new vm-area open \n    * \tshm_close,  //close - callback for when the vm-area is released \n    * \tNULL,   //no need to sync pages at unmap \n    * \tNULL,   //protect \n    * \tNULL,   //sync \n    * \tNULL,   //advise \n    * \tshm_nopage,  //nopage \n    * \tNULL,   //wppage \n    * \tshm_swapout  //swapout \n    * };\n    */\n    shp->u.shm_nattch++;     /* prevent destruction */\n    spin_unlock(&shm_lock);\n    err = shm_map(shmd);\n    spin_lock(&shm_lock);\n    if (err)\n         goto failed_shm_map;\n\n    insert_attach(shp,shmd);  /* insert shmd into shp->attaches */\n\n    shp->u.shm_lpid = current->pid;\n    shp->u.shm_atime = CURRENT_TIME;\n\n    *raddr = addr;\n    err = 0;\n    out:\n        spin_unlock(&shm_lock);\n        up(&current->mm->mmap_sem);\n        return err;\n        ...\n}\n```\n从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。\n## shm_nopage 函数实现\nshm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。\n\n```cpp\nstatic struct page * shm_nopage(struct vm_area_struct * shmd, unsigned long address, int no_share)\n{\n    pte_t pte;\n    struct shmid_kernel *shp;\n    unsigned int idx;\n    struct page * page;\n\n    shp = *(struct shmid_kernel **) shmd->vm_private_data;\n    idx = (address - shmd->vm_start + shmd->vm_offset) >> PAGE_SHIFT;\n\n    spin_lock(&shm_lock);\n    again:\n        pte = shp->shm_pages[idx]; // 共享内存的页表项\n        if (!pte_present(pte)) \n        {   // 如果内存页不存在\n            if (pte_none(pte)) {\n                spin_unlock(&shm_lock);\n                page = get_free_highpage(GFP_HIGHUSER); // 申请一个新的物理内存页\n                if (!page)\n                    goto oom;\n                clear_highpage(page);\n                spin_lock(&shm_lock);\n                if (pte_val(pte) != pte_val(shp->shm_pages[idx]))\n                    goto changed;\n            } else {\n               ...\n            }\n            shm_rss++;\n            pte = pte_mkdirty(mk_pte(page, PAGE_SHARED));   // 创建页表项\n            shp->shm_pages[idx] = pte;                      // 保存共享内存的页表项\n        } else\n              --current->maj_flt;  /* was incremented in do_no_page */\n    done:\n        get_page(pte_page(pte));\n        spin_unlock(&shm_lock);\n        current->min_flt++;\n        return pte_page(pte);\n        ...\n}\n```\n","source":"_posts/Systemv-api.md","raw":"---\ntitle: 共享内存（一）：SystemV Api\ndate: 2024-02-02 14:31:01\ntags: 共享内存\n---\nSymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。\n#  基本API\n## shmget 获取共享内存 \n使用shmget函数获取共享内存，函数原型如下：\n```cpp\n/**\n* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源\n* 参数 size 指定创建的共享内存大小\n* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存\n* 函数调用成功时返回一个新建或已经存在的的共享内存标识符\n* 取决于shmflg的参数。失败返回-1，并设置错误码\n*/\nint shmget(key_t key, size_t size, int shmflg);\n```\nshmget函数返回的是一个标识符，而不是可用的内存地址。\n## shmat 关联共享内存\n使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：\n```cpp\n/**\n* 参数 shmid 是 shmget() 函数返回的标识符\n* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址\n* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段\n* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1\n*/\nvoid *shmat(int shmid, const void *shmaddr, int shmflg);\n```\n## shmdt 取消关联共享内存\n当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：\n```cpp\n/**\n* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值\n* 函数调用成功返回0，出错返回-1\n*/\nint shmdt(const void *shmaddr);\n```\n# 共享内存原理\n概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。\n![image.png](/images/shared-mem/1.png)\n在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。\n```cpp\n/**\n* 用于管理共享内存的信息\n*/\nstruct shmid_ds {\n struct ipc_perm  shm_perm; /* operation perms */\n int   shm_segsz; /* size of segment (bytes) */\n __kernel_time_t  shm_atime; /* last attach time */\n __kernel_time_t  shm_dtime; /* last detach time */\n __kernel_time_t  shm_ctime; /* last change time */\n __kernel_ipc_pid_t shm_cpid; /* pid of creator */\n __kernel_ipc_pid_t shm_lpid; /* pid of last operator */\n unsigned short  shm_nattch; /* no. of current attaches */\n unsigned short   shm_unused; /* compatibility */\n void    *shm_unused2; /* ditto - used by DIPC */\n void   *shm_unused3; /* unused */\n};\n\nstruct shmid_kernel\n{ \n struct shmid_ds  u;\n /* the following are private */\n unsigned long  shm_npages; /* size of segment (pages) */\n pte_t   *shm_pages; /* array of ptrs to frames -> SHMMAX */ \n struct vm_area_struct *attaches; /* descriptors for attaches */\n};\n\n/**\n* shm_segs数组 用于管理系统中所有的共享内存\n*/\nstatic struct shmid_kernel *shm_segs[SHMMNI]; // SHMMNI等于128\n```\n## shmget 函数实现\nshmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。\n```cpp\nasmlinkage long sys_shmget (key_t key, int size, int shmflg)\n{\n struct shmid_kernel *shp;\n int err, id = 0;\n\n down(&current->mm->mmap_sem);\n spin_lock(&shm_lock);\n if (size < 0 || size > shmmax) \n {\n      err = -EINVAL;\n } else if (key == IPC_PRIVATE) \n {\n      err = newseg(key, shmflg, size);\n } else if ((id = findkey (key)) == -1) \n {\n      if (!(shmflg & IPC_CREAT))\n           err = -ENOENT;\n      else\n           err = newseg(key, shmflg, size);\n } else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL)) \n {\n      err = -EEXIST;\n } else {\n      shp = shm_segs[id];\n      if (shp->u.shm_perm.mode & SHM_DEST)\n           err = -EIDRM;\n      else if (size > shp->u.shm_segsz)\n           err = -EINVAL;\n      else if (ipcperms (&shp->u.shm_perm, shmflg))\n           err = -EACCES;\n      else\n           err = (int) shp->u.shm_perm.seq * SHMMNI + id;\n }\n spin_unlock(&shm_lock);\n up(&current->mm->mmap_sem);\n return err;\n}\n```\n## shmat 函数实现\n```cpp\nasmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *raddr)\n{\n    struct shmid_kernel *shp;\n    struct vm_area_struct *shmd;\n    int err = -EINVAL;\n    unsigned int id;\n    unsigned long addr;\n    unsigned long len;\n\n    down(&current->mm->mmap_sem);\n    spin_lock(&shm_lock);\n    if (shmid < 0)\t\t\n        goto out;\n\n   /**\n   * 通过 shmid 标识符来找到共享内存描述符\n   * 系统中所有的共享内存到保存在 shm_segs 数组中\n   */\n    shp = shm_segs[id = (unsigned int) shmid % SHMMNI];\n    if (shp == IPC_UNUSED || shp == IPC_NOID)\t\t\n        goto out;\n   \n    /**\n    * 找到一个可用的虚拟内存地址\n    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址\n    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址\n    */\n    if (!(addr = (ulong) shmaddr)) {\n         if (shmflg & SHM_REMAP)\n              goto out;\n         err = -ENOMEM;\n         addr = 0;\n         again:\n             //获取一个空闲的虚拟内存空间\n             if (!(addr = get_unmapped_area(addr, shp->u.shm_segsz))) \n                  goto out;\n             if(addr & (SHMLBA - 1)) \n             {\n                  addr = (addr + (SHMLBA - 1)) & ~(SHMLBA - 1);\n                  goto again;\n              }\n    } else if (addr & (SHMLBA-1)) \n    {\n         if (shmflg & SHM_RND)\n              addr &= ~(SHMLBA-1);       /* round down */\n         else\n              goto out;\n    }\n   \n    /**\n    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，\n    * vm_area_struct 结构用于管理进程的虚拟内存空间\n    */\n    spin_unlock(&shm_lock);\n    err = -ENOMEM;\n    shmd = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);\n    spin_lock(&shm_lock);\n    if (!shmd)\n         goto out;\n    if ((shp != shm_segs[id]) || (shp->u.shm_perm.seq != (unsigned int) shmid / SHMMNI)) \n    {\n         kmem_cache_free(vm_area_cachep, shmd);\n         err = -EIDRM;\n         goto out;\n    }\n   \n    /**\n    * 设置刚创建的 vm_area_struct 结构的各个字段\n    */\n    shmd->vm_private_data = shm_segs + id;\n    shmd->vm_start = addr;\n    shmd->vm_end = addr + shp->shm_npages * PAGE_SIZE;\n    shmd->vm_mm = current->mm;\n    shmd->vm_page_prot = (shmflg & SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;\n    shmd->vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED\n       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC\n       | ((shmflg & SHM_RDONLY) ? 0 : VM_MAYWRITE | VM_WRITE);\n    shmd->vm_file = NULL;\n    shmd->vm_offset = 0;\n    //这个字段比较重要，数据结构如下\n    shmd->vm_ops = &shm_vm_ops;\n    //shm_vm_ops 的 nopage 回调为 shm_nopage() 函数\n    //当发生页缺失异常时将会调用此函数来恢复内存的映射\n    /**\n    * static struct vm_operations_struct shm_vm_ops = {\n    * \tshm_open,  //open - callback for a new vm-area open \n    * \tshm_close,  //close - callback for when the vm-area is released \n    * \tNULL,   //no need to sync pages at unmap \n    * \tNULL,   //protect \n    * \tNULL,   //sync \n    * \tNULL,   //advise \n    * \tshm_nopage,  //nopage \n    * \tNULL,   //wppage \n    * \tshm_swapout  //swapout \n    * };\n    */\n    shp->u.shm_nattch++;     /* prevent destruction */\n    spin_unlock(&shm_lock);\n    err = shm_map(shmd);\n    spin_lock(&shm_lock);\n    if (err)\n         goto failed_shm_map;\n\n    insert_attach(shp,shmd);  /* insert shmd into shp->attaches */\n\n    shp->u.shm_lpid = current->pid;\n    shp->u.shm_atime = CURRENT_TIME;\n\n    *raddr = addr;\n    err = 0;\n    out:\n        spin_unlock(&shm_lock);\n        up(&current->mm->mmap_sem);\n        return err;\n        ...\n}\n```\n从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。\n## shm_nopage 函数实现\nshm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。\n\n```cpp\nstatic struct page * shm_nopage(struct vm_area_struct * shmd, unsigned long address, int no_share)\n{\n    pte_t pte;\n    struct shmid_kernel *shp;\n    unsigned int idx;\n    struct page * page;\n\n    shp = *(struct shmid_kernel **) shmd->vm_private_data;\n    idx = (address - shmd->vm_start + shmd->vm_offset) >> PAGE_SHIFT;\n\n    spin_lock(&shm_lock);\n    again:\n        pte = shp->shm_pages[idx]; // 共享内存的页表项\n        if (!pte_present(pte)) \n        {   // 如果内存页不存在\n            if (pte_none(pte)) {\n                spin_unlock(&shm_lock);\n                page = get_free_highpage(GFP_HIGHUSER); // 申请一个新的物理内存页\n                if (!page)\n                    goto oom;\n                clear_highpage(page);\n                spin_lock(&shm_lock);\n                if (pte_val(pte) != pte_val(shp->shm_pages[idx]))\n                    goto changed;\n            } else {\n               ...\n            }\n            shm_rss++;\n            pte = pte_mkdirty(mk_pte(page, PAGE_SHARED));   // 创建页表项\n            shp->shm_pages[idx] = pte;                      // 保存共享内存的页表项\n        } else\n              --current->maj_flt;  /* was incremented in do_no_page */\n    done:\n        get_page(pte_page(pte));\n        spin_unlock(&shm_lock);\n        current->min_flt++;\n        return pte_page(pte);\n        ...\n}\n```\n","slug":"Systemv-api","published":1,"updated":"2024-02-02T06:42:56.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4a5r4m0001pjx5g5thd3g9","content":"<p>SymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。</p>\n<h1 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h1><h2 id=\"shmget-获取共享内存\"><a href=\"#shmget-获取共享内存\" class=\"headerlink\" title=\"shmget 获取共享内存\"></a>shmget 获取共享内存</h2><p>使用shmget函数获取共享内存，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 size 指定创建的共享内存大小</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功时返回一个新建或已经存在的的共享内存标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 取决于shmflg的参数。失败返回-1，并设置错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">size_t</span> size, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>shmget函数返回的是一个标识符，而不是可用的内存地址。</p>\n<h2 id=\"shmat-关联共享内存\"><a href=\"#shmat-关联共享内存\" class=\"headerlink\" title=\"shmat 关联共享内存\"></a>shmat 关联共享内存</h2><p>使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmid 是 shmget() 函数返回的标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmdt-取消关联共享内存\"><a href=\"#shmdt-取消关联共享内存\" class=\"headerlink\" title=\"shmdt 取消关联共享内存\"></a>shmdt 取消关联共享内存</h2><p>当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回0，出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"共享内存原理\"><a href=\"#共享内存原理\" class=\"headerlink\" title=\"共享内存原理\"></a>共享内存原理</h1><p>概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。<br><img src=\"/images/shared-mem/1.png\" alt=\"image.png\"><br>在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 用于管理共享内存的信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">ipc_perm</span>  shm_perm; <span class=\"comment\">/* operation perms */</span></span><br><span class=\"line\"> <span class=\"type\">int</span>   shm_segsz; <span class=\"comment\">/* size of segment (bytes) */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_atime; <span class=\"comment\">/* last attach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_dtime; <span class=\"comment\">/* last detach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_ctime; <span class=\"comment\">/* last change time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_cpid; <span class=\"comment\">/* pid of creator */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_lpid; <span class=\"comment\">/* pid of last operator */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>  shm_nattch; <span class=\"comment\">/* no. of current attaches */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>   shm_unused; <span class=\"comment\">/* compatibility */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>    *shm_unused2; <span class=\"comment\">/* ditto - used by DIPC */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>   *shm_unused3; <span class=\"comment\">/* unused */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span>  u;</span><br><span class=\"line\"> <span class=\"comment\">/* the following are private */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">long</span>  shm_npages; <span class=\"comment\">/* size of segment (pages) */</span></span><br><span class=\"line\"> <span class=\"type\">pte_t</span>   *shm_pages; <span class=\"comment\">/* array of ptrs to frames -&gt; SHMMAX */</span> </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *attaches; <span class=\"comment\">/* descriptors for attaches */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* shm_segs数组 用于管理系统中所有的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shm_segs[SHMMNI]; <span class=\"comment\">// SHMMNI等于128</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shmget-函数实现\"><a href=\"#shmget-函数实现\" class=\"headerlink\" title=\"shmget 函数实现\"></a>shmget 函数实现</h2><p>shmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmget</span> <span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">int</span> size, <span class=\"type\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\"> <span class=\"type\">int</span> err, id = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || size &gt; shmmax) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EINVAL;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == IPC_PRIVATE) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((id = <span class=\"built_in\">findkey</span> (key)) == <span class=\"number\">-1</span>) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(shmflg &amp; IPC_CREAT))</span><br><span class=\"line\">           err = -ENOENT;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((shmflg &amp; IPC_CREAT) &amp;&amp; (shmflg &amp; IPC_EXCL)) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EEXIST;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      shp = shm_segs[id];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shp-&gt;u.shm_perm.mode &amp; SHM_DEST)</span><br><span class=\"line\">           err = -EIDRM;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size &gt; shp-&gt;u.shm_segsz)</span><br><span class=\"line\">           err = -EINVAL;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">ipcperms</span> (&amp;shp-&gt;u.shm_perm, shmflg))</span><br><span class=\"line\">           err = -EACCES;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = (<span class=\"type\">int</span>) shp-&gt;u.shm_perm.seq * SHMMNI + id;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmat-函数实现\"><a href=\"#shmat-函数实现\" class=\"headerlink\" title=\"shmat 函数实现\"></a>shmat 函数实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmat</span> <span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">char</span> *shmaddr, <span class=\"type\">int</span> shmflg, ulong *raddr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *shmd;</span><br><span class=\"line\">    <span class=\"type\">int</span> err = -EINVAL;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shmid &lt; <span class=\"number\">0</span>)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过 shmid 标识符来找到共享内存描述符</span></span><br><span class=\"line\"><span class=\"comment\">   * 系统中所有的共享内存到保存在 shm_segs 数组中</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    shp = shm_segs[id = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid % SHMMNI];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shp == IPC_UNUSED || shp == IPC_NOID)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 找到一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(addr = (ulong) shmaddr)) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_REMAP)</span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">         err = -ENOMEM;</span><br><span class=\"line\">         addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">         again:</span><br><span class=\"line\">             <span class=\"comment\">//获取一个空闲的虚拟内存空间</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (!(addr = <span class=\"built_in\">get_unmapped_area</span>(addr, shp-&gt;u.shm_segsz))) </span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(addr &amp; (SHMLBA - <span class=\"number\">1</span>)) </span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                  addr = (addr + (SHMLBA - <span class=\"number\">1</span>)) &amp; ~(SHMLBA - <span class=\"number\">1</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> again;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (addr &amp; (SHMLBA<span class=\"number\">-1</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_RND)</span><br><span class=\"line\">              addr &amp;= ~(SHMLBA<span class=\"number\">-1</span>);       <span class=\"comment\">/* round down */</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，</span></span><br><span class=\"line\"><span class=\"comment\">    * vm_area_struct 结构用于管理进程的虚拟内存空间</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = -ENOMEM;</span><br><span class=\"line\">    shmd = <span class=\"built_in\">kmem_cache_alloc</span>(vm_area_cachep, SLAB_KERNEL);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shmd)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((shp != shm_segs[id]) || (shp-&gt;u.shm_perm.seq != (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid / SHMMNI)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"built_in\">kmem_cache_free</span>(vm_area_cachep, shmd);</span><br><span class=\"line\">         err = -EIDRM;</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 设置刚创建的 vm_area_struct 结构的各个字段</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shmd-&gt;vm_private_data = shm_segs + id;</span><br><span class=\"line\">    shmd-&gt;vm_start = addr;</span><br><span class=\"line\">    shmd-&gt;vm_end = addr + shp-&gt;shm_npages * PAGE_SIZE;</span><br><span class=\"line\">    shmd-&gt;vm_mm = current-&gt;mm;</span><br><span class=\"line\">    shmd-&gt;vm_page_prot = (shmflg &amp; SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;</span><br><span class=\"line\">    shmd-&gt;vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED</span><br><span class=\"line\">       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC</span><br><span class=\"line\">       | ((shmflg &amp; SHM_RDONLY) ? <span class=\"number\">0</span> : VM_MAYWRITE | VM_WRITE);</span><br><span class=\"line\">    shmd-&gt;vm_file = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    shmd-&gt;vm_offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这个字段比较重要，数据结构如下</span></span><br><span class=\"line\">    shmd-&gt;vm_ops = &amp;shm_vm_ops;</span><br><span class=\"line\">    <span class=\"comment\">//shm_vm_ops 的 nopage 回调为 shm_nopage() 函数</span></span><br><span class=\"line\">    <span class=\"comment\">//当发生页缺失异常时将会调用此函数来恢复内存的映射</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * static struct vm_operations_struct shm_vm_ops = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_open,  //open - callback for a new vm-area open </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_close,  //close - callback for when the vm-area is released </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //no need to sync pages at unmap </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //protect </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //sync </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //advise </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_nopage,  //nopage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //wppage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_swapout  //swapout </span></span><br><span class=\"line\"><span class=\"comment\">    * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shp-&gt;u.shm_nattch++;     <span class=\"comment\">/* prevent destruction */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = <span class=\"built_in\">shm_map</span>(shmd);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> failed_shm_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">insert_attach</span>(shp,shmd);  <span class=\"comment\">/* insert shmd into shp-&gt;attaches */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    shp-&gt;u.shm_lpid = current-&gt;pid;</span><br><span class=\"line\">    shp-&gt;u.shm_atime = CURRENT_TIME;</span><br><span class=\"line\"></span><br><span class=\"line\">    *raddr = addr;</span><br><span class=\"line\">    err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    out:</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。</p>\n<h2 id=\"shm-nopage-函数实现\"><a href=\"#shm-nopage-函数实现\" class=\"headerlink\" title=\"shm_nopage 函数实现\"></a>shm_nopage 函数实现</h2><p>shm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * <span class=\"built_in\">shm_nopage</span>(<span class=\"keyword\">struct</span> vm_area_struct * shmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address, <span class=\"type\">int</span> no_share)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">pte_t</span> pte;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * page;</span><br><span class=\"line\"></span><br><span class=\"line\">    shp = *(<span class=\"keyword\">struct</span> shmid_kernel **) shmd-&gt;vm_private_data;</span><br><span class=\"line\">    idx = (address - shmd-&gt;vm_start + shmd-&gt;vm_offset) &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    again:</span><br><span class=\"line\">        pte = shp-&gt;shm_pages[idx]; <span class=\"comment\">// 共享内存的页表项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">pte_present</span>(pte)) </span><br><span class=\"line\">        &#123;   <span class=\"comment\">// 如果内存页不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_none</span>(pte)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">                page = <span class=\"built_in\">get_free_highpage</span>(GFP_HIGHUSER); <span class=\"comment\">// 申请一个新的物理内存页</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> oom;</span><br><span class=\"line\">                <span class=\"built_in\">clear_highpage</span>(page);</span><br><span class=\"line\">                <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_val</span>(pte) != <span class=\"built_in\">pte_val</span>(shp-&gt;shm_pages[idx]))</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> changed;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            shm_rss++;</span><br><span class=\"line\">            pte = <span class=\"built_in\">pte_mkdirty</span>(<span class=\"built_in\">mk_pte</span>(page, PAGE_SHARED));   <span class=\"comment\">// 创建页表项</span></span><br><span class=\"line\">            shp-&gt;shm_pages[idx] = pte;                      <span class=\"comment\">// 保存共享内存的页表项</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">              --current-&gt;maj_flt;  <span class=\"comment\">/* was incremented in do_no_page */</span></span><br><span class=\"line\">    done:</span><br><span class=\"line\">        <span class=\"built_in\">get_page</span>(<span class=\"built_in\">pte_page</span>(pte));</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        current-&gt;min_flt++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pte_page</span>(pte);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>SymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。</p>\n<h1 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h1><h2 id=\"shmget-获取共享内存\"><a href=\"#shmget-获取共享内存\" class=\"headerlink\" title=\"shmget 获取共享内存\"></a>shmget 获取共享内存</h2><p>使用shmget函数获取共享内存，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 size 指定创建的共享内存大小</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功时返回一个新建或已经存在的的共享内存标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 取决于shmflg的参数。失败返回-1，并设置错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">size_t</span> size, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>shmget函数返回的是一个标识符，而不是可用的内存地址。</p>\n<h2 id=\"shmat-关联共享内存\"><a href=\"#shmat-关联共享内存\" class=\"headerlink\" title=\"shmat 关联共享内存\"></a>shmat 关联共享内存</h2><p>使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmid 是 shmget() 函数返回的标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmdt-取消关联共享内存\"><a href=\"#shmdt-取消关联共享内存\" class=\"headerlink\" title=\"shmdt 取消关联共享内存\"></a>shmdt 取消关联共享内存</h2><p>当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回0，出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"共享内存原理\"><a href=\"#共享内存原理\" class=\"headerlink\" title=\"共享内存原理\"></a>共享内存原理</h1><p>概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。<br><img src=\"/images/shared-mem/1.png\" alt=\"image.png\"><br>在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 用于管理共享内存的信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">ipc_perm</span>  shm_perm; <span class=\"comment\">/* operation perms */</span></span><br><span class=\"line\"> <span class=\"type\">int</span>   shm_segsz; <span class=\"comment\">/* size of segment (bytes) */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_atime; <span class=\"comment\">/* last attach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_dtime; <span class=\"comment\">/* last detach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_ctime; <span class=\"comment\">/* last change time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_cpid; <span class=\"comment\">/* pid of creator */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_lpid; <span class=\"comment\">/* pid of last operator */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>  shm_nattch; <span class=\"comment\">/* no. of current attaches */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>   shm_unused; <span class=\"comment\">/* compatibility */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>    *shm_unused2; <span class=\"comment\">/* ditto - used by DIPC */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>   *shm_unused3; <span class=\"comment\">/* unused */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span>  u;</span><br><span class=\"line\"> <span class=\"comment\">/* the following are private */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">long</span>  shm_npages; <span class=\"comment\">/* size of segment (pages) */</span></span><br><span class=\"line\"> <span class=\"type\">pte_t</span>   *shm_pages; <span class=\"comment\">/* array of ptrs to frames -&gt; SHMMAX */</span> </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *attaches; <span class=\"comment\">/* descriptors for attaches */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* shm_segs数组 用于管理系统中所有的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shm_segs[SHMMNI]; <span class=\"comment\">// SHMMNI等于128</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shmget-函数实现\"><a href=\"#shmget-函数实现\" class=\"headerlink\" title=\"shmget 函数实现\"></a>shmget 函数实现</h2><p>shmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmget</span> <span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">int</span> size, <span class=\"type\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\"> <span class=\"type\">int</span> err, id = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || size &gt; shmmax) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EINVAL;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == IPC_PRIVATE) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((id = <span class=\"built_in\">findkey</span> (key)) == <span class=\"number\">-1</span>) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(shmflg &amp; IPC_CREAT))</span><br><span class=\"line\">           err = -ENOENT;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((shmflg &amp; IPC_CREAT) &amp;&amp; (shmflg &amp; IPC_EXCL)) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EEXIST;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      shp = shm_segs[id];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shp-&gt;u.shm_perm.mode &amp; SHM_DEST)</span><br><span class=\"line\">           err = -EIDRM;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size &gt; shp-&gt;u.shm_segsz)</span><br><span class=\"line\">           err = -EINVAL;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">ipcperms</span> (&amp;shp-&gt;u.shm_perm, shmflg))</span><br><span class=\"line\">           err = -EACCES;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = (<span class=\"type\">int</span>) shp-&gt;u.shm_perm.seq * SHMMNI + id;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmat-函数实现\"><a href=\"#shmat-函数实现\" class=\"headerlink\" title=\"shmat 函数实现\"></a>shmat 函数实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmat</span> <span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">char</span> *shmaddr, <span class=\"type\">int</span> shmflg, ulong *raddr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *shmd;</span><br><span class=\"line\">    <span class=\"type\">int</span> err = -EINVAL;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shmid &lt; <span class=\"number\">0</span>)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过 shmid 标识符来找到共享内存描述符</span></span><br><span class=\"line\"><span class=\"comment\">   * 系统中所有的共享内存到保存在 shm_segs 数组中</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    shp = shm_segs[id = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid % SHMMNI];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shp == IPC_UNUSED || shp == IPC_NOID)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 找到一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(addr = (ulong) shmaddr)) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_REMAP)</span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">         err = -ENOMEM;</span><br><span class=\"line\">         addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">         again:</span><br><span class=\"line\">             <span class=\"comment\">//获取一个空闲的虚拟内存空间</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (!(addr = <span class=\"built_in\">get_unmapped_area</span>(addr, shp-&gt;u.shm_segsz))) </span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(addr &amp; (SHMLBA - <span class=\"number\">1</span>)) </span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                  addr = (addr + (SHMLBA - <span class=\"number\">1</span>)) &amp; ~(SHMLBA - <span class=\"number\">1</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> again;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (addr &amp; (SHMLBA<span class=\"number\">-1</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_RND)</span><br><span class=\"line\">              addr &amp;= ~(SHMLBA<span class=\"number\">-1</span>);       <span class=\"comment\">/* round down */</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，</span></span><br><span class=\"line\"><span class=\"comment\">    * vm_area_struct 结构用于管理进程的虚拟内存空间</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = -ENOMEM;</span><br><span class=\"line\">    shmd = <span class=\"built_in\">kmem_cache_alloc</span>(vm_area_cachep, SLAB_KERNEL);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shmd)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((shp != shm_segs[id]) || (shp-&gt;u.shm_perm.seq != (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid / SHMMNI)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"built_in\">kmem_cache_free</span>(vm_area_cachep, shmd);</span><br><span class=\"line\">         err = -EIDRM;</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 设置刚创建的 vm_area_struct 结构的各个字段</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shmd-&gt;vm_private_data = shm_segs + id;</span><br><span class=\"line\">    shmd-&gt;vm_start = addr;</span><br><span class=\"line\">    shmd-&gt;vm_end = addr + shp-&gt;shm_npages * PAGE_SIZE;</span><br><span class=\"line\">    shmd-&gt;vm_mm = current-&gt;mm;</span><br><span class=\"line\">    shmd-&gt;vm_page_prot = (shmflg &amp; SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;</span><br><span class=\"line\">    shmd-&gt;vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED</span><br><span class=\"line\">       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC</span><br><span class=\"line\">       | ((shmflg &amp; SHM_RDONLY) ? <span class=\"number\">0</span> : VM_MAYWRITE | VM_WRITE);</span><br><span class=\"line\">    shmd-&gt;vm_file = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    shmd-&gt;vm_offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这个字段比较重要，数据结构如下</span></span><br><span class=\"line\">    shmd-&gt;vm_ops = &amp;shm_vm_ops;</span><br><span class=\"line\">    <span class=\"comment\">//shm_vm_ops 的 nopage 回调为 shm_nopage() 函数</span></span><br><span class=\"line\">    <span class=\"comment\">//当发生页缺失异常时将会调用此函数来恢复内存的映射</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * static struct vm_operations_struct shm_vm_ops = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_open,  //open - callback for a new vm-area open </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_close,  //close - callback for when the vm-area is released </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //no need to sync pages at unmap </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //protect </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //sync </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //advise </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_nopage,  //nopage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //wppage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_swapout  //swapout </span></span><br><span class=\"line\"><span class=\"comment\">    * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shp-&gt;u.shm_nattch++;     <span class=\"comment\">/* prevent destruction */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = <span class=\"built_in\">shm_map</span>(shmd);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> failed_shm_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">insert_attach</span>(shp,shmd);  <span class=\"comment\">/* insert shmd into shp-&gt;attaches */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    shp-&gt;u.shm_lpid = current-&gt;pid;</span><br><span class=\"line\">    shp-&gt;u.shm_atime = CURRENT_TIME;</span><br><span class=\"line\"></span><br><span class=\"line\">    *raddr = addr;</span><br><span class=\"line\">    err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    out:</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。</p>\n<h2 id=\"shm-nopage-函数实现\"><a href=\"#shm-nopage-函数实现\" class=\"headerlink\" title=\"shm_nopage 函数实现\"></a>shm_nopage 函数实现</h2><p>shm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * <span class=\"built_in\">shm_nopage</span>(<span class=\"keyword\">struct</span> vm_area_struct * shmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address, <span class=\"type\">int</span> no_share)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">pte_t</span> pte;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * page;</span><br><span class=\"line\"></span><br><span class=\"line\">    shp = *(<span class=\"keyword\">struct</span> shmid_kernel **) shmd-&gt;vm_private_data;</span><br><span class=\"line\">    idx = (address - shmd-&gt;vm_start + shmd-&gt;vm_offset) &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    again:</span><br><span class=\"line\">        pte = shp-&gt;shm_pages[idx]; <span class=\"comment\">// 共享内存的页表项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">pte_present</span>(pte)) </span><br><span class=\"line\">        &#123;   <span class=\"comment\">// 如果内存页不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_none</span>(pte)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">                page = <span class=\"built_in\">get_free_highpage</span>(GFP_HIGHUSER); <span class=\"comment\">// 申请一个新的物理内存页</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> oom;</span><br><span class=\"line\">                <span class=\"built_in\">clear_highpage</span>(page);</span><br><span class=\"line\">                <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_val</span>(pte) != <span class=\"built_in\">pte_val</span>(shp-&gt;shm_pages[idx]))</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> changed;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            shm_rss++;</span><br><span class=\"line\">            pte = <span class=\"built_in\">pte_mkdirty</span>(<span class=\"built_in\">mk_pte</span>(page, PAGE_SHARED));   <span class=\"comment\">// 创建页表项</span></span><br><span class=\"line\">            shp-&gt;shm_pages[idx] = pte;                      <span class=\"comment\">// 保存共享内存的页表项</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">              --current-&gt;maj_flt;  <span class=\"comment\">/* was incremented in do_no_page */</span></span><br><span class=\"line\">    done:</span><br><span class=\"line\">        <span class=\"built_in\">get_page</span>(<span class=\"built_in\">pte_page</span>(pte));</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        current-&gt;min_flt++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pte_page</span>(pte);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"同步与阻塞概念的区别","date":"2024-02-05T05:31:33.000Z","_content":"sync/async这组概念和block/unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。\n# 直接解释\n## 同步/异步\n关注的是消息通信机制 (synchronous communication/ asynchronous communication) 。\n\n- 所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。\n- 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。\n## 阻塞/非阻塞\n关注的是程序在等待调用结果（消息，返回值）时的状态。\n\n- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n# 进程间的场景\n> 进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是**阻塞的**或**非阻塞的** – 也被称为**同步**或**异步**的\n\n从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对**发送方**和**接收方**作区分对待。\n\n- 阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。\n- 非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。\n- 阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。\n- 非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。\n# 系统调用的场景\n在 I/O 系统调用层面， **非阻塞 IO 系统调用 **和** 异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。\n\n- 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。\n- 而**异步I/O系统调用 read()** 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。\n# 结论\n因此，非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。\n","source":"_posts/Sync-and-block.md","raw":"---\ntitle: 同步与阻塞概念的区别\ndate: 2024-02-05 13:31:33\ntags: 随感杂记\n---\nsync/async这组概念和block/unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。\n# 直接解释\n## 同步/异步\n关注的是消息通信机制 (synchronous communication/ asynchronous communication) 。\n\n- 所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。\n- 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。\n## 阻塞/非阻塞\n关注的是程序在等待调用结果（消息，返回值）时的状态。\n\n- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n# 进程间的场景\n> 进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是**阻塞的**或**非阻塞的** – 也被称为**同步**或**异步**的\n\n从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对**发送方**和**接收方**作区分对待。\n\n- 阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。\n- 非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。\n- 阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。\n- 非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。\n# 系统调用的场景\n在 I/O 系统调用层面， **非阻塞 IO 系统调用 **和** 异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。\n\n- 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。\n- 而**异步I/O系统调用 read()** 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。\n# 结论\n因此，非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。\n","slug":"Sync-and-block","published":1,"updated":"2024-02-05T05:33:17.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8hy75u0000czx5b01l49t8","content":"<p>sync&#x2F;async这组概念和block&#x2F;unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。</p>\n<h1 id=\"直接解释\"><a href=\"#直接解释\" class=\"headerlink\" title=\"直接解释\"></a>直接解释</h1><h2 id=\"同步-异步\"><a href=\"#同步-异步\" class=\"headerlink\" title=\"同步&#x2F;异步\"></a>同步&#x2F;异步</h2><p>关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication) 。</p>\n<ul>\n<li>所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。</li>\n<li>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。</li>\n</ul>\n<h2 id=\"阻塞-非阻塞\"><a href=\"#阻塞-非阻塞\" class=\"headerlink\" title=\"阻塞&#x2F;非阻塞\"></a>阻塞&#x2F;非阻塞</h2><p>关注的是程序在等待调用结果（消息，返回值）时的状态。</p>\n<ul>\n<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>\n<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>\n</ul>\n<h1 id=\"进程间的场景\"><a href=\"#进程间的场景\" class=\"headerlink\" title=\"进程间的场景\"></a>进程间的场景</h1><blockquote>\n<p>进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是<strong>阻塞的</strong>或<strong>非阻塞的</strong> – 也被称为<strong>同步</strong>或<strong>异步</strong>的</p>\n</blockquote>\n<p>从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对<strong>发送方</strong>和<strong>接收方</strong>作区分对待。</p>\n<ul>\n<li>阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li>\n<li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li>\n<li>阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li>\n<li>非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li>\n</ul>\n<h1 id=\"系统调用的场景\"><a href=\"#系统调用的场景\" class=\"headerlink\" title=\"系统调用的场景\"></a>系统调用的场景</h1><p>在 I&#x2F;O 系统调用层面， <strong>非阻塞 IO 系统调用 <strong>和</strong> 异步 IO 系统调用</strong>存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。</p>\n<ul>\n<li>一个<strong>非阻塞I&#x2F;O 系统调用 read()</strong> 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li>\n<li>而<strong>异步I&#x2F;O系统调用 read()</strong> 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li>\n</ul>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>因此，非阻塞系统调用（non-blocking I&#x2F;O system call 与 asynchronous I&#x2F;O system call） 的存在可以用来实现线程级别的 I&#x2F;O 并发， 与通过多进程实现的 I&#x2F;O 并发相比可以减少内存消耗以及进程切换的开销。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>sync&#x2F;async这组概念和block&#x2F;unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。</p>\n<h1 id=\"直接解释\"><a href=\"#直接解释\" class=\"headerlink\" title=\"直接解释\"></a>直接解释</h1><h2 id=\"同步-异步\"><a href=\"#同步-异步\" class=\"headerlink\" title=\"同步&#x2F;异步\"></a>同步&#x2F;异步</h2><p>关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication) 。</p>\n<ul>\n<li>所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。</li>\n<li>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。</li>\n</ul>\n<h2 id=\"阻塞-非阻塞\"><a href=\"#阻塞-非阻塞\" class=\"headerlink\" title=\"阻塞&#x2F;非阻塞\"></a>阻塞&#x2F;非阻塞</h2><p>关注的是程序在等待调用结果（消息，返回值）时的状态。</p>\n<ul>\n<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>\n<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>\n</ul>\n<h1 id=\"进程间的场景\"><a href=\"#进程间的场景\" class=\"headerlink\" title=\"进程间的场景\"></a>进程间的场景</h1><blockquote>\n<p>进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是<strong>阻塞的</strong>或<strong>非阻塞的</strong> – 也被称为<strong>同步</strong>或<strong>异步</strong>的</p>\n</blockquote>\n<p>从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对<strong>发送方</strong>和<strong>接收方</strong>作区分对待。</p>\n<ul>\n<li>阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li>\n<li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li>\n<li>阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li>\n<li>非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li>\n</ul>\n<h1 id=\"系统调用的场景\"><a href=\"#系统调用的场景\" class=\"headerlink\" title=\"系统调用的场景\"></a>系统调用的场景</h1><p>在 I&#x2F;O 系统调用层面， <strong>非阻塞 IO 系统调用 <strong>和</strong> 异步 IO 系统调用</strong>存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。</p>\n<ul>\n<li>一个<strong>非阻塞I&#x2F;O 系统调用 read()</strong> 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li>\n<li>而<strong>异步I&#x2F;O系统调用 read()</strong> 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li>\n</ul>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>因此，非阻塞系统调用（non-blocking I&#x2F;O system call 与 asynchronous I&#x2F;O system call） 的存在可以用来实现线程级别的 I&#x2F;O 并发， 与通过多进程实现的 I&#x2F;O 并发相比可以减少内存消耗以及进程切换的开销。</p>\n"},{"title":"异步事件框架学习","date":"2024-02-05T05:44:59.000Z","_content":"最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。\n因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。\n# 核心构成\nevent-loop + 基于I/O或者其他事件通知的回调函数。\n在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：\n```cpp\nwhile there are still events to process:\n    e = get the next event\n    if there is a callback associated with e:\n        call the callback\n```\n# 异步实现\n## 需要非阻塞原因\n系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。\n## 解决方案一：多线程\n每一个阻塞的I/O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。\n## 解决方案二：异步\n现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。\n例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。\n异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。\n# 异步实现的基础\n为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。\n## epoll简介\nepoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：\n\n- 告诉系统帮助我们同时监控多个文件描述符\n- 当这其中的一个或者多个文件描述符的 I/O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）\n## epoll流程示例\n![image.png](/images/async-framework/1.png)\n使用伪代码写一个epoll的具体实现流程，即如下：\n```cpp\n// 创建 epoll 实例\nint epfd = epoll_create(MAX_EVENTS);\n// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`\nepoll_ctl_add(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);\n\nwhile(1) {\n  // 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时\n  // 由系统通知应用。通知的形式如下：\n  //\n  // epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生\n  // 变化时返回\n  //\n  // epoll_wait 调用返回后：\n  // nfds 表示发生变化的文件描述符数量\n  // events 会保存当前的事件，它的数量就是 nfds\n  int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);\n\n  // 遍历 events，对事件作出符合应用预期的响应\n  for (int i = 0; i < nfds; i++) {\n    consume events[i]\n  }\n}\n\n```\n## epoll的触发模式\n触发模式分为水平触发和边缘触发。\n### 名词来源\n触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。\n水平触发：在高低电压的峰谷值周期内部会激活对应的电路。![image.png](/images/async-framework/2.png)\n边缘触发：在高低电压变化的瞬间会激活对应的电路。![image.png](/images/async-framework/3.png)\n### epoll中触发模式实例\n比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。\n**如果是水平触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容\n\n**如果是边缘触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）\n- 系统唤醒我们的应用，此时缓冲区有 6 bytes = (4 + 2) bytes\n\n**对此场景下两种触发模式的理解：**\n水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；\n边缘触发，对应的是**状态的变化**，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。\n## epoll的局限性\nepoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。\n所以在实现异步操作框架时，一般会混合多种非阻塞手段：\n\n- 将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）\n- 对于可以利用系统调用的 IO 操作，优先使用统一后的 API\n- 对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API\n- 最后，将上面的细节封装在内部，对外提供统一的 API\n# 框架逻辑结构\n## 基础代码示例\n这个是一个异步事件框架的基本骨架，很重要。\n主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。\n```cpp\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r) uv__update_time(loop);\n\n  // 是循环，没错了\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    // 处理 timer 队列\n    uv__run_timers(loop);\n    // 处理 pending 队列\n    ran_pending = uv__run_pending(loop);\n    // 处理 idle 队列\n    uv__run_idle(loop);\n    // 处理 prepare 队列\n    uv__run_prepare(loop);\n\n    // 执行 io_poll\n    uv__io_poll(loop, timeout);\n    uv__metrics_update_idle_time(loop);\n\n    // 执行 check 队列\n    uv__run_check(loop);\n    // 执行 closing 队列\n    uv__run_closing_handles(loop);\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break;\n  }\n\n  return r;\n}\n```\n## 抽象的操作概念\nevent-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。\n### Handle\nHandle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。\n**handle的API如下：**\n因为是长期存在的操作，所以基本上会拥有三个步骤：初始化/开始/停止。\n```cpp\n// IO 操作\nint uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket);\nint uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nint uv_poll_stop(uv_poll_t* poll);\n\n// timer\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n### Requet\n**request的API如下：**\nrequst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。\n```cpp\nint uv_getaddrinfo\n(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, /* ... */);\n```\n### 联系\n Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。\n## 不同的回调队列\n### timer\ntimer存在以下三个API：\n```cpp\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n#### init\ninit没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。\n#### start\nstart内部做了如下的一些工作：\n```cpp\nint uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  // loop->time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值\n  // clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要\n  // 计算了，直接从 timers 中取符合条件的即可\n  if (clamped_timeout < timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle->timer_cb = cb;\n  handle->timeout = clamped_timeout;\n  handle->repeat = repeat;\n\n  // 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的\n  //自增 start_id 作为比较条件来觉得 handle 的执行先后顺序\n  handle->start_id = handle->loop->timer_counter++;\n\n  // 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是\n  // clamped_timeout 值（或者 start_id）最小的 handle\n  heap_insert(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的开始状态\n  uv__handle_start(handle);\n\n  return 0;\n}\n```\n#### stop\nstop内部做了如下的一些工作：\n```cpp\nint uv_timer_stop(uv_timer_t* handle) {\n  if (!uv__is_active(handle))\n    return 0;\n\n  // 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外\n  // 还会维护 timer_heap 以保障其始终是 binary min heap\n  heap_remove(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的状态为停止\n  uv__handle_stop(handle);\n\n  return 0;\n}\n```\n#### timers串联分析\nstart 和 stop 其实可以粗略地概括为，往属性 loop->timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。\n**整个timers的启动：**\n```cpp\nvoid uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    // 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个\n    heap_node = heap_min(timer_heap(loop));\n    if (heap_node == NULL)\n      break;\n\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle->timeout > loop->time)\n      break;\n\n    // 停止、移出 handle、顺便维护 timer_heap\n    uv_timer_stop(handle);\n    // 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中\n    // 会在下一次事件循环中、由本方法继续执行\n    uv_timer_again(handle);\n    // 执行超时 handle 其对应的回调\n    handle->timer_cb(handle);\n  }\n}\n```\n### pending\n#### pending数据结构\n使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。\n#### pending串联分析\n```cpp\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  // 不断从队列中弹出元素进行操作\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n```\n### idle，check，prepare\n这部分感觉不重要，思想上和pending大同小异，不重点看了。\n### io poll\n在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。\n```cpp\nvoid uv__io_poll(uv_loop_t* loop, int timeout) {\n  while (!QUEUE_EMPTY(&loop->watcher_queue)) {\n    // ...\n    // `loop->backend_fd` 是使用 `epoll_create` 创建的 epoll 实例\n    epoll_ctl(loop->backend_fd, op, w->fd, &e)\n    // ...\n  }\n\n  // ...\n  for (;;) {\n  // ...\n    if (/* ... */) {\n      // ...\n    } else {\n      // ...\n      // `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者\n      nfds = epoll_wait(loop->backend_fd,\n                        events,\n                        ARRAY_SIZE(events),\n                        timeout);\n      // ...\n    }\n  }\n  // ...\n\n  for (i = 0; i < nfds; i++) {\n    // ...\n    w = loop->watchers[fd];\n    // ...\n    w->cb(loop, w, pe->events);\n  }\n}\n```\n#### timeout参数\n**在epoll_wait中timeout参数的含义：**\n\n- 如果是 -1 表示一直等到有事件产生\n- 如果是 0 则立即返回，包含调用时产生的事件\n- 如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内\n\n**在epoll_wait中timeout参数的获得：**\n核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。\n 在uv__next_timeout 实现主要分为三部分：\n\n- 只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达\n- 当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer\n- 当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间\n```cpp\nint uv_backend_timeout(const uv_loop_t* loop) {\n  // 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环\n  if (loop->stop_flag != 0)\n    return 0;\n\n  // 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回\n  if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))\n    return 0;\n\n  // idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环\n  // 否则会导致 idle 产生过高的延迟\n  if (!QUEUE_EMPTY(&loop->idle_handles))\n    return 0;\n\n  // 和上一步目的一样，不过这里是换成了 pending 队列\n  if (!QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  // 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟\n  if (loop->closing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}\n\nint uv__next_timeout(const uv_loop_t* loop) {\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  heap_node = heap_min(timer_heap(loop));\n  // 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达\n  if (heap_node == NULL)\n    return -1; /* block indefinitely */\n\n  handle = container_of(heap_node, uv_timer_t, heap_node);\n  // 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`\n  // 尽快返回，以在下一个事件循环迭代内处理超时的 timer\n  if (handle->timeout <= loop->time)\n    return 0;\n\n  // 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间\n  // 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待\n  // epoll 事件\n  diff = handle->timeout - loop->time;\n  if (diff > INT_MAX)\n    diff = INT_MAX;\n\n  return (int) diff;\n}\n```\n### thread pool\n在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。\n#### init\n通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。\n```cpp\nvoid uv__work_submit(uv_loop_t* loop,\n                     struct uv__work* w,\n                     enum uv__work_kind kind,\n                     void (*work)(struct uv__work* w),\n                     void (*done)(struct uv__work* w, int status)) {\n  uv_once(&once, init_once);\n  // ...\n  post(&w->wq, kind);\n}\n```\ninit_once 内部会调用 init_threads 来完成线程池初始化工作。\n```cpp\nstatic uv_thread_t default_threads[4];\n\nstatic void init_threads(void) {\n  // ...\n  nthreads = ARRAY_SIZE(default_threads);\n  val = getenv(\"UV_THREADPOOL_SIZE\");\n  // ...\n  for (i = 0; i < nthreads; i++)\n    if (uv_thread_create(threads + i, worker, &sem))\n      abort();\n  // ...\n}\n```\n#### post\n还是uv__work_submit 方法，内部通过post函数完成任务的提交。\n提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。\n```cpp\nstatic void post(QUEUE* q, enum uv__work_kind kind) {\n  uv_mutex_lock(&mutex);\n  // ...\n  // 将任务插入到 `wq` 这个线程共享的队列中\n  QUEUE_INSERT_TAIL(&wq, q);\n  // 如果有空闲线程，则通知它们开始工作\n  if (idle_threads > 0)\n    uv_cond_signal(&cond);\n  uv_mutex_unlock(&mutex);\n}\n```\n#### 更多逻辑\n线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。\n### closing\n通过closing队列来实现对长操作handle的关闭操作。\n调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。\n```cpp\nvoid uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!uv__is_closing(handle));\n\n  handle->flags |= UV_HANDLE_CLOSING;\n  handle->close_cb = close_cb;\n\n  switch (handle->type) {\n  // 根据不同的 handle 类型，执行各自的资源回收工作\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n  // ...\n\n  default:\n    assert(0);\n  }\n  \n  // 添加到 `loop->closing_handles`\n  uv__make_close_pending(handle);\n}\n\nvoid uv__make_close_pending(uv_handle_t* handle) {\n  assert(handle->flags & UV_HANDLE_CLOSING);\n  assert(!(handle->flags & UV_HANDLE_CLOSED));\n  handle->next_closing = handle->loop->closing_handles;\n  handle->loop->closing_handles = handle;\n}\n```\n","source":"_posts/Async-framework.md","raw":"---\ntitle: 异步事件框架学习\ndate: 2024-02-05 13:44:59\ntags: 学习笔记\n---\n最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。\n因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。\n# 核心构成\nevent-loop + 基于I/O或者其他事件通知的回调函数。\n在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：\n```cpp\nwhile there are still events to process:\n    e = get the next event\n    if there is a callback associated with e:\n        call the callback\n```\n# 异步实现\n## 需要非阻塞原因\n系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。\n## 解决方案一：多线程\n每一个阻塞的I/O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。\n## 解决方案二：异步\n现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。\n例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。\n异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。\n# 异步实现的基础\n为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。\n## epoll简介\nepoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：\n\n- 告诉系统帮助我们同时监控多个文件描述符\n- 当这其中的一个或者多个文件描述符的 I/O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）\n## epoll流程示例\n![image.png](/images/async-framework/1.png)\n使用伪代码写一个epoll的具体实现流程，即如下：\n```cpp\n// 创建 epoll 实例\nint epfd = epoll_create(MAX_EVENTS);\n// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`\nepoll_ctl_add(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);\n\nwhile(1) {\n  // 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时\n  // 由系统通知应用。通知的形式如下：\n  //\n  // epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生\n  // 变化时返回\n  //\n  // epoll_wait 调用返回后：\n  // nfds 表示发生变化的文件描述符数量\n  // events 会保存当前的事件，它的数量就是 nfds\n  int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);\n\n  // 遍历 events，对事件作出符合应用预期的响应\n  for (int i = 0; i < nfds; i++) {\n    consume events[i]\n  }\n}\n\n```\n## epoll的触发模式\n触发模式分为水平触发和边缘触发。\n### 名词来源\n触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。\n水平触发：在高低电压的峰谷值周期内部会激活对应的电路。![image.png](/images/async-framework/2.png)\n边缘触发：在高低电压变化的瞬间会激活对应的电路。![image.png](/images/async-framework/3.png)\n### epoll中触发模式实例\n比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。\n**如果是水平触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容\n\n**如果是边缘触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）\n- 系统唤醒我们的应用，此时缓冲区有 6 bytes = (4 + 2) bytes\n\n**对此场景下两种触发模式的理解：**\n水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；\n边缘触发，对应的是**状态的变化**，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。\n## epoll的局限性\nepoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。\n所以在实现异步操作框架时，一般会混合多种非阻塞手段：\n\n- 将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）\n- 对于可以利用系统调用的 IO 操作，优先使用统一后的 API\n- 对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API\n- 最后，将上面的细节封装在内部，对外提供统一的 API\n# 框架逻辑结构\n## 基础代码示例\n这个是一个异步事件框架的基本骨架，很重要。\n主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。\n```cpp\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r) uv__update_time(loop);\n\n  // 是循环，没错了\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    // 处理 timer 队列\n    uv__run_timers(loop);\n    // 处理 pending 队列\n    ran_pending = uv__run_pending(loop);\n    // 处理 idle 队列\n    uv__run_idle(loop);\n    // 处理 prepare 队列\n    uv__run_prepare(loop);\n\n    // 执行 io_poll\n    uv__io_poll(loop, timeout);\n    uv__metrics_update_idle_time(loop);\n\n    // 执行 check 队列\n    uv__run_check(loop);\n    // 执行 closing 队列\n    uv__run_closing_handles(loop);\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break;\n  }\n\n  return r;\n}\n```\n## 抽象的操作概念\nevent-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。\n### Handle\nHandle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。\n**handle的API如下：**\n因为是长期存在的操作，所以基本上会拥有三个步骤：初始化/开始/停止。\n```cpp\n// IO 操作\nint uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket);\nint uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nint uv_poll_stop(uv_poll_t* poll);\n\n// timer\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n### Requet\n**request的API如下：**\nrequst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。\n```cpp\nint uv_getaddrinfo\n(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, /* ... */);\n```\n### 联系\n Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。\n## 不同的回调队列\n### timer\ntimer存在以下三个API：\n```cpp\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n#### init\ninit没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。\n#### start\nstart内部做了如下的一些工作：\n```cpp\nint uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  // loop->time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值\n  // clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要\n  // 计算了，直接从 timers 中取符合条件的即可\n  if (clamped_timeout < timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle->timer_cb = cb;\n  handle->timeout = clamped_timeout;\n  handle->repeat = repeat;\n\n  // 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的\n  //自增 start_id 作为比较条件来觉得 handle 的执行先后顺序\n  handle->start_id = handle->loop->timer_counter++;\n\n  // 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是\n  // clamped_timeout 值（或者 start_id）最小的 handle\n  heap_insert(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的开始状态\n  uv__handle_start(handle);\n\n  return 0;\n}\n```\n#### stop\nstop内部做了如下的一些工作：\n```cpp\nint uv_timer_stop(uv_timer_t* handle) {\n  if (!uv__is_active(handle))\n    return 0;\n\n  // 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外\n  // 还会维护 timer_heap 以保障其始终是 binary min heap\n  heap_remove(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的状态为停止\n  uv__handle_stop(handle);\n\n  return 0;\n}\n```\n#### timers串联分析\nstart 和 stop 其实可以粗略地概括为，往属性 loop->timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。\n**整个timers的启动：**\n```cpp\nvoid uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    // 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个\n    heap_node = heap_min(timer_heap(loop));\n    if (heap_node == NULL)\n      break;\n\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle->timeout > loop->time)\n      break;\n\n    // 停止、移出 handle、顺便维护 timer_heap\n    uv_timer_stop(handle);\n    // 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中\n    // 会在下一次事件循环中、由本方法继续执行\n    uv_timer_again(handle);\n    // 执行超时 handle 其对应的回调\n    handle->timer_cb(handle);\n  }\n}\n```\n### pending\n#### pending数据结构\n使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。\n#### pending串联分析\n```cpp\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  // 不断从队列中弹出元素进行操作\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n```\n### idle，check，prepare\n这部分感觉不重要，思想上和pending大同小异，不重点看了。\n### io poll\n在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。\n```cpp\nvoid uv__io_poll(uv_loop_t* loop, int timeout) {\n  while (!QUEUE_EMPTY(&loop->watcher_queue)) {\n    // ...\n    // `loop->backend_fd` 是使用 `epoll_create` 创建的 epoll 实例\n    epoll_ctl(loop->backend_fd, op, w->fd, &e)\n    // ...\n  }\n\n  // ...\n  for (;;) {\n  // ...\n    if (/* ... */) {\n      // ...\n    } else {\n      // ...\n      // `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者\n      nfds = epoll_wait(loop->backend_fd,\n                        events,\n                        ARRAY_SIZE(events),\n                        timeout);\n      // ...\n    }\n  }\n  // ...\n\n  for (i = 0; i < nfds; i++) {\n    // ...\n    w = loop->watchers[fd];\n    // ...\n    w->cb(loop, w, pe->events);\n  }\n}\n```\n#### timeout参数\n**在epoll_wait中timeout参数的含义：**\n\n- 如果是 -1 表示一直等到有事件产生\n- 如果是 0 则立即返回，包含调用时产生的事件\n- 如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内\n\n**在epoll_wait中timeout参数的获得：**\n核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。\n 在uv__next_timeout 实现主要分为三部分：\n\n- 只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达\n- 当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer\n- 当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间\n```cpp\nint uv_backend_timeout(const uv_loop_t* loop) {\n  // 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环\n  if (loop->stop_flag != 0)\n    return 0;\n\n  // 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回\n  if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))\n    return 0;\n\n  // idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环\n  // 否则会导致 idle 产生过高的延迟\n  if (!QUEUE_EMPTY(&loop->idle_handles))\n    return 0;\n\n  // 和上一步目的一样，不过这里是换成了 pending 队列\n  if (!QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  // 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟\n  if (loop->closing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}\n\nint uv__next_timeout(const uv_loop_t* loop) {\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  heap_node = heap_min(timer_heap(loop));\n  // 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达\n  if (heap_node == NULL)\n    return -1; /* block indefinitely */\n\n  handle = container_of(heap_node, uv_timer_t, heap_node);\n  // 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`\n  // 尽快返回，以在下一个事件循环迭代内处理超时的 timer\n  if (handle->timeout <= loop->time)\n    return 0;\n\n  // 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间\n  // 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待\n  // epoll 事件\n  diff = handle->timeout - loop->time;\n  if (diff > INT_MAX)\n    diff = INT_MAX;\n\n  return (int) diff;\n}\n```\n### thread pool\n在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。\n#### init\n通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。\n```cpp\nvoid uv__work_submit(uv_loop_t* loop,\n                     struct uv__work* w,\n                     enum uv__work_kind kind,\n                     void (*work)(struct uv__work* w),\n                     void (*done)(struct uv__work* w, int status)) {\n  uv_once(&once, init_once);\n  // ...\n  post(&w->wq, kind);\n}\n```\ninit_once 内部会调用 init_threads 来完成线程池初始化工作。\n```cpp\nstatic uv_thread_t default_threads[4];\n\nstatic void init_threads(void) {\n  // ...\n  nthreads = ARRAY_SIZE(default_threads);\n  val = getenv(\"UV_THREADPOOL_SIZE\");\n  // ...\n  for (i = 0; i < nthreads; i++)\n    if (uv_thread_create(threads + i, worker, &sem))\n      abort();\n  // ...\n}\n```\n#### post\n还是uv__work_submit 方法，内部通过post函数完成任务的提交。\n提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。\n```cpp\nstatic void post(QUEUE* q, enum uv__work_kind kind) {\n  uv_mutex_lock(&mutex);\n  // ...\n  // 将任务插入到 `wq` 这个线程共享的队列中\n  QUEUE_INSERT_TAIL(&wq, q);\n  // 如果有空闲线程，则通知它们开始工作\n  if (idle_threads > 0)\n    uv_cond_signal(&cond);\n  uv_mutex_unlock(&mutex);\n}\n```\n#### 更多逻辑\n线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。\n### closing\n通过closing队列来实现对长操作handle的关闭操作。\n调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。\n```cpp\nvoid uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!uv__is_closing(handle));\n\n  handle->flags |= UV_HANDLE_CLOSING;\n  handle->close_cb = close_cb;\n\n  switch (handle->type) {\n  // 根据不同的 handle 类型，执行各自的资源回收工作\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n  // ...\n\n  default:\n    assert(0);\n  }\n  \n  // 添加到 `loop->closing_handles`\n  uv__make_close_pending(handle);\n}\n\nvoid uv__make_close_pending(uv_handle_t* handle) {\n  assert(handle->flags & UV_HANDLE_CLOSING);\n  assert(!(handle->flags & UV_HANDLE_CLOSED));\n  handle->next_closing = handle->loop->closing_handles;\n  handle->loop->closing_handles = handle;\n}\n```\n","slug":"Async-framework","published":1,"updated":"2024-02-05T05:52:42.390Z","_id":"cls8ihuyg0000icx5gxv6hdkd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。<br>因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。</p>\n<h1 id=\"核心构成\"><a href=\"#核心构成\" class=\"headerlink\" title=\"核心构成\"></a>核心构成</h1><p>event-loop + 基于I&#x2F;O或者其他事件通知的回调函数。<br>在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> there are still events to process:</span><br><span class=\"line\">    e = get the next event</span><br><span class=\"line\">    <span class=\"keyword\">if</span> there is a callback associated with e:</span><br><span class=\"line\">        call the callback</span><br></pre></td></tr></table></figure>\n<h1 id=\"异步实现\"><a href=\"#异步实现\" class=\"headerlink\" title=\"异步实现\"></a>异步实现</h1><h2 id=\"需要非阻塞原因\"><a href=\"#需要非阻塞原因\" class=\"headerlink\" title=\"需要非阻塞原因\"></a>需要非阻塞原因</h2><p>系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。</p>\n<h2 id=\"解决方案一：多线程\"><a href=\"#解决方案一：多线程\" class=\"headerlink\" title=\"解决方案一：多线程\"></a>解决方案一：多线程</h2><p>每一个阻塞的I&#x2F;O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。</p>\n<h2 id=\"解决方案二：异步\"><a href=\"#解决方案二：异步\" class=\"headerlink\" title=\"解决方案二：异步\"></a>解决方案二：异步</h2><p>现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。<br>例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。<br>异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。</p>\n<h1 id=\"异步实现的基础\"><a href=\"#异步实现的基础\" class=\"headerlink\" title=\"异步实现的基础\"></a>异步实现的基础</h1><p>为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。</p>\n<h2 id=\"epoll简介\"><a href=\"#epoll简介\" class=\"headerlink\" title=\"epoll简介\"></a>epoll简介</h2><p>epoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：</p>\n<ul>\n<li>告诉系统帮助我们同时监控多个文件描述符</li>\n<li>当这其中的一个或者多个文件描述符的 I&#x2F;O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）</li>\n</ul>\n<h2 id=\"epoll流程示例\"><a href=\"#epoll流程示例\" class=\"headerlink\" title=\"epoll流程示例\"></a>epoll流程示例</h2><p><img src=\"/images/async-framework/1.png\" alt=\"image.png\"><br>使用伪代码写一个epoll的具体实现流程，即如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 epoll 实例</span></span><br><span class=\"line\"><span class=\"type\">int</span> epfd = <span class=\"built_in\">epoll_create</span>(MAX_EVENTS);</span><br><span class=\"line\"><span class=\"comment\">// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`</span></span><br><span class=\"line\"><span class=\"built_in\">epoll_ctl_add</span>(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时</span></span><br><span class=\"line\">  <span class=\"comment\">// 由系统通知应用。通知的形式如下：</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生</span></span><br><span class=\"line\">  <span class=\"comment\">// 变化时返回</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用返回后：</span></span><br><span class=\"line\">  <span class=\"comment\">// nfds 表示发生变化的文件描述符数量</span></span><br><span class=\"line\">  <span class=\"comment\">// events 会保存当前的事件，它的数量就是 nfds</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nfds = <span class=\"built_in\">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 遍历 events，对事件作出符合应用预期的响应</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    consume events[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll的触发模式\"><a href=\"#epoll的触发模式\" class=\"headerlink\" title=\"epoll的触发模式\"></a>epoll的触发模式</h2><p>触发模式分为水平触发和边缘触发。</p>\n<h3 id=\"名词来源\"><a href=\"#名词来源\" class=\"headerlink\" title=\"名词来源\"></a>名词来源</h3><p>触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。<br>水平触发：在高低电压的峰谷值周期内部会激活对应的电路。<img src=\"/images/async-framework/2.png\" alt=\"image.png\"><br>边缘触发：在高低电压变化的瞬间会激活对应的电路。<img src=\"/images/async-framework/3.png\" alt=\"image.png\"></p>\n<h3 id=\"epoll中触发模式实例\"><a href=\"#epoll中触发模式实例\" class=\"headerlink\" title=\"epoll中触发模式实例\"></a>epoll中触发模式实例</h3><p>比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。<br><strong>如果是水平触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容</li>\n</ul>\n<p><strong>如果是边缘触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）</li>\n<li>系统唤醒我们的应用，此时缓冲区有 6 bytes &#x3D; (4 + 2) bytes</li>\n</ul>\n<p><strong>对此场景下两种触发模式的理解：</strong><br>水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；<br>边缘触发，对应的是<strong>状态的变化</strong>，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。</p>\n<h2 id=\"epoll的局限性\"><a href=\"#epoll的局限性\" class=\"headerlink\" title=\"epoll的局限性\"></a>epoll的局限性</h2><p>epoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。<br>所以在实现异步操作框架时，一般会混合多种非阻塞手段：</p>\n<ul>\n<li>将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）</li>\n<li>对于可以利用系统调用的 IO 操作，优先使用统一后的 API</li>\n<li>对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API</li>\n<li>最后，将上面的细节封装在内部，对外提供统一的 API</li>\n</ul>\n<h1 id=\"框架逻辑结构\"><a href=\"#框架逻辑结构\" class=\"headerlink\" title=\"框架逻辑结构\"></a>框架逻辑结构</h1><h2 id=\"基础代码示例\"><a href=\"#基础代码示例\" class=\"headerlink\" title=\"基础代码示例\"></a>基础代码示例</h2><p>这个是一个异步事件框架的基本骨架，很重要。<br>主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_run</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">  <span class=\"type\">int</span> r;</span><br><span class=\"line\">  <span class=\"type\">int</span> ran_pending;</span><br><span class=\"line\"></span><br><span class=\"line\">  r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!r) <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是循环，没错了</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (r != <span class=\"number\">0</span> &amp;&amp; loop-&gt;stop_flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 timer 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_timers</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 pending 队列</span></span><br><span class=\"line\">    ran_pending = <span class=\"built_in\">uv__run_pending</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 idle 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_idle</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 prepare 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_prepare</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 io_poll</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__io_poll</span>(loop, timeout);</span><br><span class=\"line\">    <span class=\"built_in\">uv__metrics_update_idle_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 check 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_check</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 closing 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_closing_handles</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"抽象的操作概念\"><a href=\"#抽象的操作概念\" class=\"headerlink\" title=\"抽象的操作概念\"></a>抽象的操作概念</h2><p>event-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。</p>\n<h3 id=\"Handle\"><a href=\"#Handle\" class=\"headerlink\" title=\"Handle\"></a>Handle</h3><p>Handle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。<br><strong>handle的API如下：</strong><br>因为是长期存在的操作，所以基本上会拥有三个步骤：初始化&#x2F;开始&#x2F;停止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IO 操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_init_socket</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">uv_os_sock_t</span> socket)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_start</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">int</span> events, uv_poll_cb cb)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_stop</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* poll)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// timer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Requet\"><a href=\"#Requet\" class=\"headerlink\" title=\"Requet\"></a>Requet</h3><p><strong>request的API如下：</strong><br>requst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_getaddrinfo</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_getaddrinfo_t</span>* req, uv_getaddrinfo_cb getaddrinfo_cb, <span class=\"comment\">/* ... */</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><p> Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。</p>\n<h2 id=\"不同的回调队列\"><a href=\"#不同的回调队列\" class=\"headerlink\" title=\"不同的回调队列\"></a>不同的回调队列</h2><h3 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h3><p>timer存在以下三个API：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h4><p>init没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。</p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h4><p>start内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   uv_timer_cb cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> timeout,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> repeat)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> clamped_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// loop-&gt;time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要</span></span><br><span class=\"line\">  <span class=\"comment\">// 计算了，直接从 timers 中取符合条件的即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (clamped_timeout &lt; timeout)</span><br><span class=\"line\">    clamped_timeout = (<span class=\"type\">uint64_t</span>) <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;timer_cb = cb;</span><br><span class=\"line\">  handle-&gt;timeout = clamped_timeout;</span><br><span class=\"line\">  handle-&gt;repeat = repeat;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的</span></span><br><span class=\"line\">  <span class=\"comment\">//自增 start_id 作为比较条件来觉得 handle 的执行先后顺序</span></span><br><span class=\"line\">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 值（或者 start_id）最小的 handle</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_insert</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的开始状态</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_start</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h4><p>stop内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__is_active</span>(handle))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外</span></span><br><span class=\"line\">  <span class=\"comment\">// 还会维护 timer_heap 以保障其始终是 binary min heap</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_remove</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的状态为停止</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_stop</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timers串联分析\"><a href=\"#timers串联分析\" class=\"headerlink\" title=\"timers串联分析\"></a>timers串联分析</h4><p>start 和 stop 其实可以粗略地概括为，往属性 loop-&gt;timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。<br><strong>整个timers的启动：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__run_timers</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个</span></span><br><span class=\"line\">    heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 停止、移出 handle、顺便维护 timer_heap</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_stop</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中</span></span><br><span class=\"line\">    <span class=\"comment\">// 会在下一次事件循环中、由本方法继续执行</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_again</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 执行超时 handle 其对应的回调</span></span><br><span class=\"line\">    handle-&gt;<span class=\"built_in\">timer_cb</span>(handle);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pending\"><a href=\"#pending\" class=\"headerlink\" title=\"pending\"></a>pending</h3><h4 id=\"pending数据结构\"><a href=\"#pending数据结构\" class=\"headerlink\" title=\"pending数据结构\"></a>pending数据结构</h4><p>使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。</p>\n<h4 id=\"pending串联分析\"><a href=\"#pending串联分析\" class=\"headerlink\" title=\"pending串联分析\"></a>pending串联分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">uv__run_pending</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  QUEUE* q;</span><br><span class=\"line\">  QUEUE pq;</span><br><span class=\"line\">  <span class=\"type\">uv__io_t</span>* w;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_MOVE</span>(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不断从队列中弹出元素进行操作</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;pq)) &#123;</span><br><span class=\"line\">    q = <span class=\"built_in\">QUEUE_HEAD</span>(&amp;pq);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_REMOVE</span>(q);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_INIT</span>(q);</span><br><span class=\"line\">    w = <span class=\"built_in\">QUEUE_DATA</span>(q, <span class=\"type\">uv__io_t</span>, pending_queue);</span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, POLLOUT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"idle，check，prepare\"><a href=\"#idle，check，prepare\" class=\"headerlink\" title=\"idle，check，prepare\"></a>idle，check，prepare</h3><p>这部分感觉不重要，思想上和pending大同小异，不重点看了。</p>\n<h3 id=\"io-poll\"><a href=\"#io-poll\" class=\"headerlink\" title=\"io poll\"></a>io poll</h3><p>在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__io_poll</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">int</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// `loop-&gt;backend_fd` 是使用 `epoll_create` 创建的 epoll 实例</span></span><br><span class=\"line\">    <span class=\"built_in\">epoll_ctl</span>(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* ... */</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者</span></span><br><span class=\"line\">      nfds = <span class=\"built_in\">epoll_wait</span>(loop-&gt;backend_fd,</span><br><span class=\"line\">                        events,</span><br><span class=\"line\">                        <span class=\"built_in\">ARRAY_SIZE</span>(events),</span><br><span class=\"line\">                        timeout);</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w = loop-&gt;watchers[fd];</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, pe-&gt;events);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timeout参数\"><a href=\"#timeout参数\" class=\"headerlink\" title=\"timeout参数\"></a>timeout参数</h4><p><strong>在epoll_wait中timeout参数的含义：</strong></p>\n<ul>\n<li>如果是 -1 表示一直等到有事件产生</li>\n<li>如果是 0 则立即返回，包含调用时产生的事件</li>\n<li>如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内</li>\n</ul>\n<p><strong>在epoll_wait中timeout参数的获得：</strong><br>核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。<br> 在uv__next_timeout 实现主要分为三部分：</p>\n<ul>\n<li>只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达</li>\n<li>当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer</li>\n<li>当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_backend_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;stop_flag != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__has_active_handles</span>(loop) &amp;&amp; !<span class=\"built_in\">uv__has_active_reqs</span>(loop))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则会导致 idle 产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;idle_handles))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里是换成了 pending 队列</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;closing_handles)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">uv__next_timeout</span>(loop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv__next_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> diff;</span><br><span class=\"line\"></span><br><span class=\"line\">  heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">/* block indefinitely */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">  <span class=\"comment\">// 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`</span></span><br><span class=\"line\">  <span class=\"comment\">// 尽快返回，以在下一个事件循环迭代内处理超时的 timer</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll 事件</span></span><br><span class=\"line\">  diff = handle-&gt;timeout - loop-&gt;time;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (diff &gt; INT_MAX)</span><br><span class=\"line\">    diff = INT_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) diff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"thread-pool\"><a href=\"#thread-pool\" class=\"headerlink\" title=\"thread pool\"></a>thread pool</h3><p>在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。</p>\n<h4 id=\"init-1\"><a href=\"#init-1\" class=\"headerlink\" title=\"init\"></a>init</h4><p>通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__work_submit</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">struct</span> uv__work* w,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">enum</span> uv__work_kind kind,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*work)(<span class=\"keyword\">struct</span> uv__work* w),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*done)(<span class=\"keyword\">struct</span> uv__work* w, <span class=\"type\">int</span> status))</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_once</span>(&amp;once, init_once);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">post</span>(&amp;w-&gt;wq, kind);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>init_once 内部会调用 init_threads 来完成线程池初始化工作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uv_thread_t</span> default_threads[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">init_threads</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  nthreads = <span class=\"built_in\">ARRAY_SIZE</span>(default_threads);</span><br><span class=\"line\">  val = <span class=\"built_in\">getenv</span>(<span class=\"string\">&quot;UV_THREADPOOL_SIZE&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nthreads; i++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">uv_thread_create</span>(threads + i, worker, &amp;sem))</span><br><span class=\"line\">      <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"post\"></a>post</h4><p>还是uv__work_submit 方法，内部通过post函数完成任务的提交。<br>提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">post</span><span class=\"params\">(QUEUE* q, <span class=\"keyword\">enum</span> uv__work_kind kind)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_lock</span>(&amp;mutex);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 将任务插入到 `wq` 这个线程共享的队列中</span></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_INSERT_TAIL</span>(&amp;wq, q);</span><br><span class=\"line\">  <span class=\"comment\">// 如果有空闲线程，则通知它们开始工作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (idle_threads &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">uv_cond_signal</span>(&amp;cond);</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_unlock</span>(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"更多逻辑\"><a href=\"#更多逻辑\" class=\"headerlink\" title=\"更多逻辑\"></a>更多逻辑</h4><p>线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。</p>\n<h3 id=\"closing\"><a href=\"#closing\" class=\"headerlink\" title=\"closing\"></a>closing</h3><p>通过closing队列来实现对长操作handle的关闭操作。<br>调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv_close</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle, uv_close_cb close_cb)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!<span class=\"built_in\">uv__is_closing</span>(handle));</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;flags |= UV_HANDLE_CLOSING;</span><br><span class=\"line\">  handle-&gt;close_cb = close_cb;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (handle-&gt;type) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据不同的 handle 类型，执行各自的资源回收工作</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_NAMED_PIPE:</span><br><span class=\"line\">    <span class=\"built_in\">uv__pipe_close</span>((<span class=\"type\">uv_pipe_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TTY:</span><br><span class=\"line\">    <span class=\"built_in\">uv__stream_close</span>((<span class=\"type\">uv_stream_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TCP:</span><br><span class=\"line\">    <span class=\"built_in\">uv__tcp_close</span>((<span class=\"type\">uv_tcp_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 添加到 `loop-&gt;closing_handles`</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__make_close_pending</span>(handle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__make_close_pending</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class=\"line\">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class=\"line\">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。<br>因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。</p>\n<h1 id=\"核心构成\"><a href=\"#核心构成\" class=\"headerlink\" title=\"核心构成\"></a>核心构成</h1><p>event-loop + 基于I&#x2F;O或者其他事件通知的回调函数。<br>在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> there are still events to process:</span><br><span class=\"line\">    e = get the next event</span><br><span class=\"line\">    <span class=\"keyword\">if</span> there is a callback associated with e:</span><br><span class=\"line\">        call the callback</span><br></pre></td></tr></table></figure>\n<h1 id=\"异步实现\"><a href=\"#异步实现\" class=\"headerlink\" title=\"异步实现\"></a>异步实现</h1><h2 id=\"需要非阻塞原因\"><a href=\"#需要非阻塞原因\" class=\"headerlink\" title=\"需要非阻塞原因\"></a>需要非阻塞原因</h2><p>系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。</p>\n<h2 id=\"解决方案一：多线程\"><a href=\"#解决方案一：多线程\" class=\"headerlink\" title=\"解决方案一：多线程\"></a>解决方案一：多线程</h2><p>每一个阻塞的I&#x2F;O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。</p>\n<h2 id=\"解决方案二：异步\"><a href=\"#解决方案二：异步\" class=\"headerlink\" title=\"解决方案二：异步\"></a>解决方案二：异步</h2><p>现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。<br>例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。<br>异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。</p>\n<h1 id=\"异步实现的基础\"><a href=\"#异步实现的基础\" class=\"headerlink\" title=\"异步实现的基础\"></a>异步实现的基础</h1><p>为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。</p>\n<h2 id=\"epoll简介\"><a href=\"#epoll简介\" class=\"headerlink\" title=\"epoll简介\"></a>epoll简介</h2><p>epoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：</p>\n<ul>\n<li>告诉系统帮助我们同时监控多个文件描述符</li>\n<li>当这其中的一个或者多个文件描述符的 I&#x2F;O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）</li>\n</ul>\n<h2 id=\"epoll流程示例\"><a href=\"#epoll流程示例\" class=\"headerlink\" title=\"epoll流程示例\"></a>epoll流程示例</h2><p><img src=\"/images/async-framework/1.png\" alt=\"image.png\"><br>使用伪代码写一个epoll的具体实现流程，即如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 epoll 实例</span></span><br><span class=\"line\"><span class=\"type\">int</span> epfd = <span class=\"built_in\">epoll_create</span>(MAX_EVENTS);</span><br><span class=\"line\"><span class=\"comment\">// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`</span></span><br><span class=\"line\"><span class=\"built_in\">epoll_ctl_add</span>(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时</span></span><br><span class=\"line\">  <span class=\"comment\">// 由系统通知应用。通知的形式如下：</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生</span></span><br><span class=\"line\">  <span class=\"comment\">// 变化时返回</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用返回后：</span></span><br><span class=\"line\">  <span class=\"comment\">// nfds 表示发生变化的文件描述符数量</span></span><br><span class=\"line\">  <span class=\"comment\">// events 会保存当前的事件，它的数量就是 nfds</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nfds = <span class=\"built_in\">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 遍历 events，对事件作出符合应用预期的响应</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    consume events[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll的触发模式\"><a href=\"#epoll的触发模式\" class=\"headerlink\" title=\"epoll的触发模式\"></a>epoll的触发模式</h2><p>触发模式分为水平触发和边缘触发。</p>\n<h3 id=\"名词来源\"><a href=\"#名词来源\" class=\"headerlink\" title=\"名词来源\"></a>名词来源</h3><p>触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。<br>水平触发：在高低电压的峰谷值周期内部会激活对应的电路。<img src=\"/images/async-framework/2.png\" alt=\"image.png\"><br>边缘触发：在高低电压变化的瞬间会激活对应的电路。<img src=\"/images/async-framework/3.png\" alt=\"image.png\"></p>\n<h3 id=\"epoll中触发模式实例\"><a href=\"#epoll中触发模式实例\" class=\"headerlink\" title=\"epoll中触发模式实例\"></a>epoll中触发模式实例</h3><p>比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。<br><strong>如果是水平触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容</li>\n</ul>\n<p><strong>如果是边缘触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）</li>\n<li>系统唤醒我们的应用，此时缓冲区有 6 bytes &#x3D; (4 + 2) bytes</li>\n</ul>\n<p><strong>对此场景下两种触发模式的理解：</strong><br>水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；<br>边缘触发，对应的是<strong>状态的变化</strong>，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。</p>\n<h2 id=\"epoll的局限性\"><a href=\"#epoll的局限性\" class=\"headerlink\" title=\"epoll的局限性\"></a>epoll的局限性</h2><p>epoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。<br>所以在实现异步操作框架时，一般会混合多种非阻塞手段：</p>\n<ul>\n<li>将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）</li>\n<li>对于可以利用系统调用的 IO 操作，优先使用统一后的 API</li>\n<li>对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API</li>\n<li>最后，将上面的细节封装在内部，对外提供统一的 API</li>\n</ul>\n<h1 id=\"框架逻辑结构\"><a href=\"#框架逻辑结构\" class=\"headerlink\" title=\"框架逻辑结构\"></a>框架逻辑结构</h1><h2 id=\"基础代码示例\"><a href=\"#基础代码示例\" class=\"headerlink\" title=\"基础代码示例\"></a>基础代码示例</h2><p>这个是一个异步事件框架的基本骨架，很重要。<br>主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_run</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">  <span class=\"type\">int</span> r;</span><br><span class=\"line\">  <span class=\"type\">int</span> ran_pending;</span><br><span class=\"line\"></span><br><span class=\"line\">  r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!r) <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是循环，没错了</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (r != <span class=\"number\">0</span> &amp;&amp; loop-&gt;stop_flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 timer 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_timers</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 pending 队列</span></span><br><span class=\"line\">    ran_pending = <span class=\"built_in\">uv__run_pending</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 idle 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_idle</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 prepare 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_prepare</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 io_poll</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__io_poll</span>(loop, timeout);</span><br><span class=\"line\">    <span class=\"built_in\">uv__metrics_update_idle_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 check 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_check</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 closing 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_closing_handles</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"抽象的操作概念\"><a href=\"#抽象的操作概念\" class=\"headerlink\" title=\"抽象的操作概念\"></a>抽象的操作概念</h2><p>event-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。</p>\n<h3 id=\"Handle\"><a href=\"#Handle\" class=\"headerlink\" title=\"Handle\"></a>Handle</h3><p>Handle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。<br><strong>handle的API如下：</strong><br>因为是长期存在的操作，所以基本上会拥有三个步骤：初始化&#x2F;开始&#x2F;停止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IO 操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_init_socket</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">uv_os_sock_t</span> socket)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_start</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">int</span> events, uv_poll_cb cb)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_stop</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* poll)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// timer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Requet\"><a href=\"#Requet\" class=\"headerlink\" title=\"Requet\"></a>Requet</h3><p><strong>request的API如下：</strong><br>requst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_getaddrinfo</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_getaddrinfo_t</span>* req, uv_getaddrinfo_cb getaddrinfo_cb, <span class=\"comment\">/* ... */</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><p> Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。</p>\n<h2 id=\"不同的回调队列\"><a href=\"#不同的回调队列\" class=\"headerlink\" title=\"不同的回调队列\"></a>不同的回调队列</h2><h3 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h3><p>timer存在以下三个API：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h4><p>init没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。</p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h4><p>start内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   uv_timer_cb cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> timeout,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> repeat)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> clamped_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// loop-&gt;time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要</span></span><br><span class=\"line\">  <span class=\"comment\">// 计算了，直接从 timers 中取符合条件的即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (clamped_timeout &lt; timeout)</span><br><span class=\"line\">    clamped_timeout = (<span class=\"type\">uint64_t</span>) <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;timer_cb = cb;</span><br><span class=\"line\">  handle-&gt;timeout = clamped_timeout;</span><br><span class=\"line\">  handle-&gt;repeat = repeat;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的</span></span><br><span class=\"line\">  <span class=\"comment\">//自增 start_id 作为比较条件来觉得 handle 的执行先后顺序</span></span><br><span class=\"line\">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 值（或者 start_id）最小的 handle</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_insert</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的开始状态</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_start</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h4><p>stop内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__is_active</span>(handle))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外</span></span><br><span class=\"line\">  <span class=\"comment\">// 还会维护 timer_heap 以保障其始终是 binary min heap</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_remove</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的状态为停止</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_stop</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timers串联分析\"><a href=\"#timers串联分析\" class=\"headerlink\" title=\"timers串联分析\"></a>timers串联分析</h4><p>start 和 stop 其实可以粗略地概括为，往属性 loop-&gt;timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。<br><strong>整个timers的启动：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__run_timers</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个</span></span><br><span class=\"line\">    heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 停止、移出 handle、顺便维护 timer_heap</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_stop</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中</span></span><br><span class=\"line\">    <span class=\"comment\">// 会在下一次事件循环中、由本方法继续执行</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_again</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 执行超时 handle 其对应的回调</span></span><br><span class=\"line\">    handle-&gt;<span class=\"built_in\">timer_cb</span>(handle);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pending\"><a href=\"#pending\" class=\"headerlink\" title=\"pending\"></a>pending</h3><h4 id=\"pending数据结构\"><a href=\"#pending数据结构\" class=\"headerlink\" title=\"pending数据结构\"></a>pending数据结构</h4><p>使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。</p>\n<h4 id=\"pending串联分析\"><a href=\"#pending串联分析\" class=\"headerlink\" title=\"pending串联分析\"></a>pending串联分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">uv__run_pending</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  QUEUE* q;</span><br><span class=\"line\">  QUEUE pq;</span><br><span class=\"line\">  <span class=\"type\">uv__io_t</span>* w;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_MOVE</span>(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不断从队列中弹出元素进行操作</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;pq)) &#123;</span><br><span class=\"line\">    q = <span class=\"built_in\">QUEUE_HEAD</span>(&amp;pq);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_REMOVE</span>(q);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_INIT</span>(q);</span><br><span class=\"line\">    w = <span class=\"built_in\">QUEUE_DATA</span>(q, <span class=\"type\">uv__io_t</span>, pending_queue);</span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, POLLOUT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"idle，check，prepare\"><a href=\"#idle，check，prepare\" class=\"headerlink\" title=\"idle，check，prepare\"></a>idle，check，prepare</h3><p>这部分感觉不重要，思想上和pending大同小异，不重点看了。</p>\n<h3 id=\"io-poll\"><a href=\"#io-poll\" class=\"headerlink\" title=\"io poll\"></a>io poll</h3><p>在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__io_poll</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">int</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// `loop-&gt;backend_fd` 是使用 `epoll_create` 创建的 epoll 实例</span></span><br><span class=\"line\">    <span class=\"built_in\">epoll_ctl</span>(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* ... */</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者</span></span><br><span class=\"line\">      nfds = <span class=\"built_in\">epoll_wait</span>(loop-&gt;backend_fd,</span><br><span class=\"line\">                        events,</span><br><span class=\"line\">                        <span class=\"built_in\">ARRAY_SIZE</span>(events),</span><br><span class=\"line\">                        timeout);</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w = loop-&gt;watchers[fd];</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, pe-&gt;events);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timeout参数\"><a href=\"#timeout参数\" class=\"headerlink\" title=\"timeout参数\"></a>timeout参数</h4><p><strong>在epoll_wait中timeout参数的含义：</strong></p>\n<ul>\n<li>如果是 -1 表示一直等到有事件产生</li>\n<li>如果是 0 则立即返回，包含调用时产生的事件</li>\n<li>如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内</li>\n</ul>\n<p><strong>在epoll_wait中timeout参数的获得：</strong><br>核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。<br> 在uv__next_timeout 实现主要分为三部分：</p>\n<ul>\n<li>只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达</li>\n<li>当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer</li>\n<li>当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_backend_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;stop_flag != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__has_active_handles</span>(loop) &amp;&amp; !<span class=\"built_in\">uv__has_active_reqs</span>(loop))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则会导致 idle 产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;idle_handles))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里是换成了 pending 队列</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;closing_handles)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">uv__next_timeout</span>(loop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv__next_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> diff;</span><br><span class=\"line\"></span><br><span class=\"line\">  heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">/* block indefinitely */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">  <span class=\"comment\">// 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`</span></span><br><span class=\"line\">  <span class=\"comment\">// 尽快返回，以在下一个事件循环迭代内处理超时的 timer</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll 事件</span></span><br><span class=\"line\">  diff = handle-&gt;timeout - loop-&gt;time;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (diff &gt; INT_MAX)</span><br><span class=\"line\">    diff = INT_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) diff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"thread-pool\"><a href=\"#thread-pool\" class=\"headerlink\" title=\"thread pool\"></a>thread pool</h3><p>在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。</p>\n<h4 id=\"init-1\"><a href=\"#init-1\" class=\"headerlink\" title=\"init\"></a>init</h4><p>通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__work_submit</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">struct</span> uv__work* w,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">enum</span> uv__work_kind kind,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*work)(<span class=\"keyword\">struct</span> uv__work* w),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*done)(<span class=\"keyword\">struct</span> uv__work* w, <span class=\"type\">int</span> status))</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_once</span>(&amp;once, init_once);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">post</span>(&amp;w-&gt;wq, kind);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>init_once 内部会调用 init_threads 来完成线程池初始化工作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uv_thread_t</span> default_threads[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">init_threads</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  nthreads = <span class=\"built_in\">ARRAY_SIZE</span>(default_threads);</span><br><span class=\"line\">  val = <span class=\"built_in\">getenv</span>(<span class=\"string\">&quot;UV_THREADPOOL_SIZE&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nthreads; i++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">uv_thread_create</span>(threads + i, worker, &amp;sem))</span><br><span class=\"line\">      <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"post\"></a>post</h4><p>还是uv__work_submit 方法，内部通过post函数完成任务的提交。<br>提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">post</span><span class=\"params\">(QUEUE* q, <span class=\"keyword\">enum</span> uv__work_kind kind)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_lock</span>(&amp;mutex);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 将任务插入到 `wq` 这个线程共享的队列中</span></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_INSERT_TAIL</span>(&amp;wq, q);</span><br><span class=\"line\">  <span class=\"comment\">// 如果有空闲线程，则通知它们开始工作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (idle_threads &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">uv_cond_signal</span>(&amp;cond);</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_unlock</span>(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"更多逻辑\"><a href=\"#更多逻辑\" class=\"headerlink\" title=\"更多逻辑\"></a>更多逻辑</h4><p>线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。</p>\n<h3 id=\"closing\"><a href=\"#closing\" class=\"headerlink\" title=\"closing\"></a>closing</h3><p>通过closing队列来实现对长操作handle的关闭操作。<br>调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv_close</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle, uv_close_cb close_cb)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!<span class=\"built_in\">uv__is_closing</span>(handle));</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;flags |= UV_HANDLE_CLOSING;</span><br><span class=\"line\">  handle-&gt;close_cb = close_cb;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (handle-&gt;type) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据不同的 handle 类型，执行各自的资源回收工作</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_NAMED_PIPE:</span><br><span class=\"line\">    <span class=\"built_in\">uv__pipe_close</span>((<span class=\"type\">uv_pipe_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TTY:</span><br><span class=\"line\">    <span class=\"built_in\">uv__stream_close</span>((<span class=\"type\">uv_stream_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TCP:</span><br><span class=\"line\">    <span class=\"built_in\">uv__tcp_close</span>((<span class=\"type\">uv_tcp_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 添加到 `loop-&gt;closing_handles`</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__make_close_pending</span>(handle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__make_close_pending</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class=\"line\">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class=\"line\">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Socket中的字节序转换","date":"2024-02-05T05:56:32.000Z","_content":"经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。\n# 转换类型相关api\n```cpp\nhtonl()--\"Host to Network Long\"\nntohl()--\"Network to Host Long\"\nhtons()--\"Host to Network Short\"\nntohs()--\"Network to Host Short\"  \n```\n# 两种字节序\n## 网络字节序NBO（Network Byte Order）\n按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。\n## 主机字节序HBO（Host Byte Order）\n不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。 \n如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。\n## 需要进行字节序转换原因\n由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。\n","source":"_posts/Byte-order-conversion.md","raw":"---\ntitle: Socket中的字节序转换\ndate: 2024-02-05 13:56:32\ntags: 随感杂记\n---\n经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。\n# 转换类型相关api\n```cpp\nhtonl()--\"Host to Network Long\"\nntohl()--\"Network to Host Long\"\nhtons()--\"Host to Network Short\"\nntohs()--\"Network to Host Short\"  \n```\n# 两种字节序\n## 网络字节序NBO（Network Byte Order）\n按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。\n## 主机字节序HBO（Host Byte Order）\n不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。 \n如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。\n## 需要进行字节序转换原因\n由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。\n","slug":"Byte-order-conversion","published":1,"updated":"2024-02-05T05:58:06.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8itme40000i2x55kln7r1i","content":"<p>经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。</p>\n<h1 id=\"转换类型相关api\"><a href=\"#转换类型相关api\" class=\"headerlink\" title=\"转换类型相关api\"></a>转换类型相关api</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">htonl</span>()--<span class=\"string\">&quot;Host to Network Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohl</span>()--<span class=\"string\">&quot;Network to Host Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">htons</span>()--<span class=\"string\">&quot;Host to Network Short&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohs</span>()--<span class=\"string\">&quot;Network to Host Short&quot;</span>  </span><br></pre></td></tr></table></figure>\n<h1 id=\"两种字节序\"><a href=\"#两种字节序\" class=\"headerlink\" title=\"两种字节序\"></a>两种字节序</h1><h2 id=\"网络字节序NBO（Network-Byte-Order）\"><a href=\"#网络字节序NBO（Network-Byte-Order）\" class=\"headerlink\" title=\"网络字节序NBO（Network Byte Order）\"></a>网络字节序NBO（Network Byte Order）</h2><p>按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>\n<h2 id=\"主机字节序HBO（Host-Byte-Order）\"><a href=\"#主机字节序HBO（Host-Byte-Order）\" class=\"headerlink\" title=\"主机字节序HBO（Host Byte Order）\"></a>主机字节序HBO（Host Byte Order）</h2><p>不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。<br>如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。</p>\n<h2 id=\"需要进行字节序转换原因\"><a href=\"#需要进行字节序转换原因\" class=\"headerlink\" title=\"需要进行字节序转换原因\"></a>需要进行字节序转换原因</h2><p>由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。</p>\n<h1 id=\"转换类型相关api\"><a href=\"#转换类型相关api\" class=\"headerlink\" title=\"转换类型相关api\"></a>转换类型相关api</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">htonl</span>()--<span class=\"string\">&quot;Host to Network Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohl</span>()--<span class=\"string\">&quot;Network to Host Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">htons</span>()--<span class=\"string\">&quot;Host to Network Short&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohs</span>()--<span class=\"string\">&quot;Network to Host Short&quot;</span>  </span><br></pre></td></tr></table></figure>\n<h1 id=\"两种字节序\"><a href=\"#两种字节序\" class=\"headerlink\" title=\"两种字节序\"></a>两种字节序</h1><h2 id=\"网络字节序NBO（Network-Byte-Order）\"><a href=\"#网络字节序NBO（Network-Byte-Order）\" class=\"headerlink\" title=\"网络字节序NBO（Network Byte Order）\"></a>网络字节序NBO（Network Byte Order）</h2><p>按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>\n<h2 id=\"主机字节序HBO（Host-Byte-Order）\"><a href=\"#主机字节序HBO（Host-Byte-Order）\" class=\"headerlink\" title=\"主机字节序HBO（Host Byte Order）\"></a>主机字节序HBO（Host Byte Order）</h2><p>不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。<br>如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。</p>\n<h2 id=\"需要进行字节序转换原因\"><a href=\"#需要进行字节序转换原因\" class=\"headerlink\" title=\"需要进行字节序转换原因\"></a>需要进行字节序转换原因</h2><p>由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。</p>\n"},{"title":"性能优化（一）：概述","date":"2024-02-02T06:19:15.000Z","_content":"性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。\n# 性能优化的目的\n在计算机硬件/工程师价格和收益之间找一个平衡点。\n# 性能优化流程\n![image.png](/images/preformance-optimize-overview/1.png)\n# 程序性能优化方法\n性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。\n## 针对IO瓶颈的性能优化\n每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：\n\n1. 预先顺序读文件避免随机访问。\n2. 合并多个小文件为单个大文件。\n3. 优化动态库文件的加载。\n4. 交错IO时间和CPU时间。\n## 针对计算密集的性能优化\n计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：\n\n1. 去除冗余代码。\n2. 字符串操作优化。\n3. 减少内存分配、释放操作，例如使用内存池。\n4. 减少不必要的互斥锁操作。\n5. 根据性能需求选择数据结构。\n6. 延迟工作，按需执行。\n7. 减少跨进程的调用。\n8. 使用高性能的函数库。\n## C++特性相关的性能优化\nC++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。\n","source":"_posts/Preformance-optimize-1.md","raw":"---\ntitle: 性能优化（一）：概述\ndate: 2024-02-02 14:19:15\ntags: 性能优化\n---\n性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。\n# 性能优化的目的\n在计算机硬件/工程师价格和收益之间找一个平衡点。\n# 性能优化流程\n![image.png](/images/preformance-optimize-overview/1.png)\n# 程序性能优化方法\n性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。\n## 针对IO瓶颈的性能优化\n每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：\n\n1. 预先顺序读文件避免随机访问。\n2. 合并多个小文件为单个大文件。\n3. 优化动态库文件的加载。\n4. 交错IO时间和CPU时间。\n## 针对计算密集的性能优化\n计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：\n\n1. 去除冗余代码。\n2. 字符串操作优化。\n3. 减少内存分配、释放操作，例如使用内存池。\n4. 减少不必要的互斥锁操作。\n5. 根据性能需求选择数据结构。\n6. 延迟工作，按需执行。\n7. 减少跨进程的调用。\n8. 使用高性能的函数库。\n## C++特性相关的性能优化\nC++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。\n","slug":"Preformance-optimize-1","published":1,"updated":"2024-02-05T06:10:37.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8jg44f0000pxx5c6qtaeda","content":"<p>性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。</p>\n<h1 id=\"性能优化的目的\"><a href=\"#性能优化的目的\" class=\"headerlink\" title=\"性能优化的目的\"></a>性能优化的目的</h1><p>在计算机硬件&#x2F;工程师价格和收益之间找一个平衡点。</p>\n<h1 id=\"性能优化流程\"><a href=\"#性能优化流程\" class=\"headerlink\" title=\"性能优化流程\"></a>性能优化流程</h1><p><img src=\"/images/preformance-optimize-overview/1.png\" alt=\"image.png\"></p>\n<h1 id=\"程序性能优化方法\"><a href=\"#程序性能优化方法\" class=\"headerlink\" title=\"程序性能优化方法\"></a>程序性能优化方法</h1><p>性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。</p>\n<h2 id=\"针对IO瓶颈的性能优化\"><a href=\"#针对IO瓶颈的性能优化\" class=\"headerlink\" title=\"针对IO瓶颈的性能优化\"></a>针对IO瓶颈的性能优化</h2><p>每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：</p>\n<ol>\n<li>预先顺序读文件避免随机访问。</li>\n<li>合并多个小文件为单个大文件。</li>\n<li>优化动态库文件的加载。</li>\n<li>交错IO时间和CPU时间。</li>\n</ol>\n<h2 id=\"针对计算密集的性能优化\"><a href=\"#针对计算密集的性能优化\" class=\"headerlink\" title=\"针对计算密集的性能优化\"></a>针对计算密集的性能优化</h2><p>计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：</p>\n<ol>\n<li>去除冗余代码。</li>\n<li>字符串操作优化。</li>\n<li>减少内存分配、释放操作，例如使用内存池。</li>\n<li>减少不必要的互斥锁操作。</li>\n<li>根据性能需求选择数据结构。</li>\n<li>延迟工作，按需执行。</li>\n<li>减少跨进程的调用。</li>\n<li>使用高性能的函数库。</li>\n</ol>\n<h2 id=\"C-特性相关的性能优化\"><a href=\"#C-特性相关的性能优化\" class=\"headerlink\" title=\"C++特性相关的性能优化\"></a>C++特性相关的性能优化</h2><p>C++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。</p>\n<h1 id=\"性能优化的目的\"><a href=\"#性能优化的目的\" class=\"headerlink\" title=\"性能优化的目的\"></a>性能优化的目的</h1><p>在计算机硬件&#x2F;工程师价格和收益之间找一个平衡点。</p>\n<h1 id=\"性能优化流程\"><a href=\"#性能优化流程\" class=\"headerlink\" title=\"性能优化流程\"></a>性能优化流程</h1><p><img src=\"/images/preformance-optimize-overview/1.png\" alt=\"image.png\"></p>\n<h1 id=\"程序性能优化方法\"><a href=\"#程序性能优化方法\" class=\"headerlink\" title=\"程序性能优化方法\"></a>程序性能优化方法</h1><p>性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。</p>\n<h2 id=\"针对IO瓶颈的性能优化\"><a href=\"#针对IO瓶颈的性能优化\" class=\"headerlink\" title=\"针对IO瓶颈的性能优化\"></a>针对IO瓶颈的性能优化</h2><p>每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：</p>\n<ol>\n<li>预先顺序读文件避免随机访问。</li>\n<li>合并多个小文件为单个大文件。</li>\n<li>优化动态库文件的加载。</li>\n<li>交错IO时间和CPU时间。</li>\n</ol>\n<h2 id=\"针对计算密集的性能优化\"><a href=\"#针对计算密集的性能优化\" class=\"headerlink\" title=\"针对计算密集的性能优化\"></a>针对计算密集的性能优化</h2><p>计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：</p>\n<ol>\n<li>去除冗余代码。</li>\n<li>字符串操作优化。</li>\n<li>减少内存分配、释放操作，例如使用内存池。</li>\n<li>减少不必要的互斥锁操作。</li>\n<li>根据性能需求选择数据结构。</li>\n<li>延迟工作，按需执行。</li>\n<li>减少跨进程的调用。</li>\n<li>使用高性能的函数库。</li>\n</ol>\n<h2 id=\"C-特性相关的性能优化\"><a href=\"#C-特性相关的性能优化\" class=\"headerlink\" title=\"C++特性相关的性能优化\"></a>C++特性相关的性能优化</h2><p>C++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。</p>\n"},{"title":"性能优化（二）：交易系统","date":"2024-02-05T06:11:05.000Z","_content":"> 如果你对性能不敏感的话，你不应该直接写python调库吗？\n\n# 接收数据前网络时延\n和软件提供商，期货公司，交易所之间的连接。\n# 数据进入CPU前时延\n尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果\n# 具体的服务器设置\n\n- disable hyperthreading\n- turn on over clocking\n- disable Nagle's algorithm\n- set cpu affinity and isolation\n# 代码编程注意点\n### 能用单线程，就不要多线程\n如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全\n### 优化剪短关键路径\n### 降低run-time处理数据的复杂度\n能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。\n### 避免run-time的memory allocation\n可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。\n### 允许undefined behavior的存在\n要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。\n### 利用好cache\n尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。\n\n- 尽量让可能被同时使用的数据挨在一起\n- 减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）\n- 尽量节省内存（比如用unique_ptr<Data[]>取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）\n- 指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）\n- 会被多个核同时读写的数据按照缓存行对齐（避免false sharing）\n### 注意struct padding\n### 避免不必要的branch和table lookup\n使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。\n### 确定合适的container\n部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。\n### 用好编译器提供的builtins\n比如__expected，__prefetch之类\n### 了解编译器和连接器在做什么\n最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2/O3的优化，因为各种原因，反而会让代码变慢。比如： https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\n# 参考链接 \n\n- optiver的cppcon17分享：https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\n- DRW前员工Matt Godbolt的分享：https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\n- 如何使用cache friendly代码：https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\n","source":"_posts/Preformance-optimize-2.md","raw":"---\ntitle: 性能优化（二）：交易系统\ndate: 2024-02-05 14:11:05\ntags: 性能优化\n---\n> 如果你对性能不敏感的话，你不应该直接写python调库吗？\n\n# 接收数据前网络时延\n和软件提供商，期货公司，交易所之间的连接。\n# 数据进入CPU前时延\n尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果\n# 具体的服务器设置\n\n- disable hyperthreading\n- turn on over clocking\n- disable Nagle's algorithm\n- set cpu affinity and isolation\n# 代码编程注意点\n### 能用单线程，就不要多线程\n如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全\n### 优化剪短关键路径\n### 降低run-time处理数据的复杂度\n能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。\n### 避免run-time的memory allocation\n可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。\n### 允许undefined behavior的存在\n要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。\n### 利用好cache\n尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。\n\n- 尽量让可能被同时使用的数据挨在一起\n- 减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）\n- 尽量节省内存（比如用unique_ptr<Data[]>取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）\n- 指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）\n- 会被多个核同时读写的数据按照缓存行对齐（避免false sharing）\n### 注意struct padding\n### 避免不必要的branch和table lookup\n使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。\n### 确定合适的container\n部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。\n### 用好编译器提供的builtins\n比如__expected，__prefetch之类\n### 了解编译器和连接器在做什么\n最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2/O3的优化，因为各种原因，反而会让代码变慢。比如： https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\n# 参考链接 \n\n- optiver的cppcon17分享：https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\n- DRW前员工Matt Godbolt的分享：https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\n- 如何使用cache friendly代码：https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\n","slug":"Preformance-optimize-2","published":1,"updated":"2024-02-05T06:14:36.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8jg44j0001pxx5gg823l2o","content":"<blockquote>\n<p>如果你对性能不敏感的话，你不应该直接写python调库吗？</p>\n</blockquote>\n<h1 id=\"接收数据前网络时延\"><a href=\"#接收数据前网络时延\" class=\"headerlink\" title=\"接收数据前网络时延\"></a>接收数据前网络时延</h1><p>和软件提供商，期货公司，交易所之间的连接。</p>\n<h1 id=\"数据进入CPU前时延\"><a href=\"#数据进入CPU前时延\" class=\"headerlink\" title=\"数据进入CPU前时延\"></a>数据进入CPU前时延</h1><p>尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果</p>\n<h1 id=\"具体的服务器设置\"><a href=\"#具体的服务器设置\" class=\"headerlink\" title=\"具体的服务器设置\"></a>具体的服务器设置</h1><ul>\n<li>disable hyperthreading</li>\n<li>turn on over clocking</li>\n<li>disable Nagle’s algorithm</li>\n<li>set cpu affinity and isolation</li>\n</ul>\n<h1 id=\"代码编程注意点\"><a href=\"#代码编程注意点\" class=\"headerlink\" title=\"代码编程注意点\"></a>代码编程注意点</h1><h3 id=\"能用单线程，就不要多线程\"><a href=\"#能用单线程，就不要多线程\" class=\"headerlink\" title=\"能用单线程，就不要多线程\"></a>能用单线程，就不要多线程</h3><p>如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全</p>\n<h3 id=\"优化剪短关键路径\"><a href=\"#优化剪短关键路径\" class=\"headerlink\" title=\"优化剪短关键路径\"></a>优化剪短关键路径</h3><h3 id=\"降低run-time处理数据的复杂度\"><a href=\"#降低run-time处理数据的复杂度\" class=\"headerlink\" title=\"降低run-time处理数据的复杂度\"></a>降低run-time处理数据的复杂度</h3><p>能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。</p>\n<h3 id=\"避免run-time的memory-allocation\"><a href=\"#避免run-time的memory-allocation\" class=\"headerlink\" title=\"避免run-time的memory allocation\"></a>避免run-time的memory allocation</h3><p>可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。</p>\n<h3 id=\"允许undefined-behavior的存在\"><a href=\"#允许undefined-behavior的存在\" class=\"headerlink\" title=\"允许undefined behavior的存在\"></a>允许undefined behavior的存在</h3><p>要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。</p>\n<h3 id=\"利用好cache\"><a href=\"#利用好cache\" class=\"headerlink\" title=\"利用好cache\"></a>利用好cache</h3><p>尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。</p>\n<ul>\n<li>尽量让可能被同时使用的数据挨在一起</li>\n<li>减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）</li>\n<li>尽量节省内存（比如用unique_ptr&lt;Data[]&gt;取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）</li>\n<li>指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）</li>\n<li>会被多个核同时读写的数据按照缓存行对齐（避免false sharing）</li>\n</ul>\n<h3 id=\"注意struct-padding\"><a href=\"#注意struct-padding\" class=\"headerlink\" title=\"注意struct padding\"></a>注意struct padding</h3><h3 id=\"避免不必要的branch和table-lookup\"><a href=\"#避免不必要的branch和table-lookup\" class=\"headerlink\" title=\"避免不必要的branch和table lookup\"></a>避免不必要的branch和table lookup</h3><p>使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。</p>\n<h3 id=\"确定合适的container\"><a href=\"#确定合适的container\" class=\"headerlink\" title=\"确定合适的container\"></a>确定合适的container</h3><p>部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。</p>\n<h3 id=\"用好编译器提供的builtins\"><a href=\"#用好编译器提供的builtins\" class=\"headerlink\" title=\"用好编译器提供的builtins\"></a>用好编译器提供的builtins</h3><p>比如__expected，__prefetch之类</p>\n<h3 id=\"了解编译器和连接器在做什么\"><a href=\"#了解编译器和连接器在做什么\" class=\"headerlink\" title=\"了解编译器和连接器在做什么\"></a>了解编译器和连接器在做什么</h3><p>最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2&#x2F;O3的优化，因为各种原因，反而会让代码变慢。比如： <a href=\"https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\">https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82</a></p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li>optiver的cppcon17分享：<a href=\"https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\">https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82</a></li>\n<li>DRW前员工Matt Godbolt的分享：<a href=\"https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\">https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82</a></li>\n<li>如何使用cache friendly代码：<a href=\"https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\">https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>如果你对性能不敏感的话，你不应该直接写python调库吗？</p>\n</blockquote>\n<h1 id=\"接收数据前网络时延\"><a href=\"#接收数据前网络时延\" class=\"headerlink\" title=\"接收数据前网络时延\"></a>接收数据前网络时延</h1><p>和软件提供商，期货公司，交易所之间的连接。</p>\n<h1 id=\"数据进入CPU前时延\"><a href=\"#数据进入CPU前时延\" class=\"headerlink\" title=\"数据进入CPU前时延\"></a>数据进入CPU前时延</h1><p>尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果</p>\n<h1 id=\"具体的服务器设置\"><a href=\"#具体的服务器设置\" class=\"headerlink\" title=\"具体的服务器设置\"></a>具体的服务器设置</h1><ul>\n<li>disable hyperthreading</li>\n<li>turn on over clocking</li>\n<li>disable Nagle’s algorithm</li>\n<li>set cpu affinity and isolation</li>\n</ul>\n<h1 id=\"代码编程注意点\"><a href=\"#代码编程注意点\" class=\"headerlink\" title=\"代码编程注意点\"></a>代码编程注意点</h1><h3 id=\"能用单线程，就不要多线程\"><a href=\"#能用单线程，就不要多线程\" class=\"headerlink\" title=\"能用单线程，就不要多线程\"></a>能用单线程，就不要多线程</h3><p>如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全</p>\n<h3 id=\"优化剪短关键路径\"><a href=\"#优化剪短关键路径\" class=\"headerlink\" title=\"优化剪短关键路径\"></a>优化剪短关键路径</h3><h3 id=\"降低run-time处理数据的复杂度\"><a href=\"#降低run-time处理数据的复杂度\" class=\"headerlink\" title=\"降低run-time处理数据的复杂度\"></a>降低run-time处理数据的复杂度</h3><p>能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。</p>\n<h3 id=\"避免run-time的memory-allocation\"><a href=\"#避免run-time的memory-allocation\" class=\"headerlink\" title=\"避免run-time的memory allocation\"></a>避免run-time的memory allocation</h3><p>可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。</p>\n<h3 id=\"允许undefined-behavior的存在\"><a href=\"#允许undefined-behavior的存在\" class=\"headerlink\" title=\"允许undefined behavior的存在\"></a>允许undefined behavior的存在</h3><p>要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。</p>\n<h3 id=\"利用好cache\"><a href=\"#利用好cache\" class=\"headerlink\" title=\"利用好cache\"></a>利用好cache</h3><p>尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。</p>\n<ul>\n<li>尽量让可能被同时使用的数据挨在一起</li>\n<li>减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）</li>\n<li>尽量节省内存（比如用unique_ptr&lt;Data[]&gt;取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）</li>\n<li>指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）</li>\n<li>会被多个核同时读写的数据按照缓存行对齐（避免false sharing）</li>\n</ul>\n<h3 id=\"注意struct-padding\"><a href=\"#注意struct-padding\" class=\"headerlink\" title=\"注意struct padding\"></a>注意struct padding</h3><h3 id=\"避免不必要的branch和table-lookup\"><a href=\"#避免不必要的branch和table-lookup\" class=\"headerlink\" title=\"避免不必要的branch和table lookup\"></a>避免不必要的branch和table lookup</h3><p>使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。</p>\n<h3 id=\"确定合适的container\"><a href=\"#确定合适的container\" class=\"headerlink\" title=\"确定合适的container\"></a>确定合适的container</h3><p>部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。</p>\n<h3 id=\"用好编译器提供的builtins\"><a href=\"#用好编译器提供的builtins\" class=\"headerlink\" title=\"用好编译器提供的builtins\"></a>用好编译器提供的builtins</h3><p>比如__expected，__prefetch之类</p>\n<h3 id=\"了解编译器和连接器在做什么\"><a href=\"#了解编译器和连接器在做什么\" class=\"headerlink\" title=\"了解编译器和连接器在做什么\"></a>了解编译器和连接器在做什么</h3><p>最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2&#x2F;O3的优化，因为各种原因，反而会让代码变慢。比如： <a href=\"https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\">https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82</a></p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li>optiver的cppcon17分享：<a href=\"https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\">https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82</a></li>\n<li>DRW前员工Matt Godbolt的分享：<a href=\"https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\">https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82</a></li>\n<li>如何使用cache friendly代码：<a href=\"https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\">https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cls01gnk000001ax57sxn64hc","tag_id":"clrhz6rx4000r0ox56u9g5wdy","_id":"cls01gnk600011ax5b7c61vku"},{"post_id":"cls34916b0000ynx57dh67tl8","tag_id":"cls34916n0001ynx5fvzbhfmb","_id":"cls34916r0002ynx58swjfrp2"},{"post_id":"cls3f5xxq0000r4x54i19cger","tag_id":"cls34916n0001ynx5fvzbhfmb","_id":"cls3f5xxv0001r4x5etvhcynk"},{"post_id":"cls482gg500006lx5024naovq","tag_id":"cls482gga00016lx5c2r4g1oa","_id":"cls482ggd00026lx5g45b54my"},{"post_id":"cls48hpdw0000ecx576pb11hl","tag_id":"cls482gga00016lx5c2r4g1oa","_id":"cls48hpe30001ecx58yuk7frs"},{"post_id":"cls4a5r4h0000pjx585w7f6ng","tag_id":"cls4a5r4o0002pjx5b5bbhnnj","_id":"cls4a5r4s0004pjx5gzer5dsf"},{"post_id":"cls4a5r4m0001pjx5g5thd3g9","tag_id":"cls4a5r4o0002pjx5b5bbhnnj","_id":"cls4a5r4t0005pjx5d2znhkar"},{"post_id":"clrhz6rwf00010ox533q1ciw5","tag_id":"cls4a9oa20000clx59j5v5qhg","_id":"cls4a9oa50001clx527pfcbkv"},{"post_id":"cls8hy75u0000czx5b01l49t8","tag_id":"cls49d61400016lx5329xb3nk","_id":"cls8hy75z0001czx5coqz2y4m"},{"post_id":"cls8ihuyg0000icx5gxv6hdkd","tag_id":"cls8ihuyn0001icx5bwk3deat","_id":"cls8ihuyq0002icx5213hain0"},{"post_id":"cls8itme40000i2x55kln7r1i","tag_id":"cls49d61400016lx5329xb3nk","_id":"cls8itmeg0001i2x50fmrfmyf"},{"post_id":"cls8jg44f0000pxx5c6qtaeda","tag_id":"cls8jg44l0002pxx56cw33hym","_id":"cls8jg44s0004pxx56olz47qk"},{"post_id":"cls8jg44j0001pxx5gg823l2o","tag_id":"cls8jg44l0002pxx56cw33hym","_id":"cls8jg44s0005pxx5h29v6nzh"}],"Tag":[{"name":"design pattern","_id":"clrhz6rwk00030ox5fj28fcof"},{"name":"Cpp","_id":"clrhz6rwp00070ox59wtr7non"},{"name":"Gpt","_id":"clrhz6rx3000o0ox53fm0aedb"},{"name":"Plan","_id":"clrhz6rx4000r0ox56u9g5wdy"},{"name":"学习杂记","_id":"cls34916n0001ynx5fvzbhfmb"},{"name":"工具集合","_id":"cls482gga00016lx5c2r4g1oa"},{"name":"随感杂记","_id":"cls49d61400016lx5329xb3nk"},{"name":"共享内存","_id":"cls4a5r4o0002pjx5b5bbhnnj"},{"name":"设计模式","_id":"cls4a9oa20000clx59j5v5qhg"},{"name":"学习笔记","_id":"cls8ihuyn0001icx5bwk3deat"},{"name":"性能优化","_id":"cls8jg44l0002pxx56cw33hym"}]}}