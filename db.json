{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"source/images/git-note/1.png","path":"images/git-note/1.png","modified":0,"renderable":0},{"_id":"source/images/git-note/2.png","path":"images/git-note/2.png","modified":0,"renderable":0},{"_id":"source/images/git-note/3.png","path":"images/git-note/3.png","modified":0,"renderable":0},{"_id":"source/images/git-note/4.png","path":"images/git-note/4.png","modified":0,"renderable":0},{"_id":"source/images/git-note/5.png","path":"images/git-note/5.png","modified":0,"renderable":0},{"_id":"source/images/git-note/6.png","path":"images/git-note/6.png","modified":0,"renderable":0},{"_id":"source/images/git-note/7.png","path":"images/git-note/7.png","modified":0,"renderable":0},{"_id":"source/images/git-note/8.png","path":"images/git-note/8.png","modified":0,"renderable":0},{"_id":"source/images/git-note/9.png","path":"images/git-note/9.png","modified":0,"renderable":0},{"_id":"source/images/design-pattern/1.png","path":"images/design-pattern/1.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/1.png","path":"images/refactor-project/1.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/2.png","path":"images/refactor-project/2.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/3.png","path":"images/refactor-project/3.png","modified":0,"renderable":0},{"_id":"source/images/refactor-project/4.png","path":"images/refactor-project/4.png","modified":0,"renderable":0},{"_id":"source/images/preformance-optimize-overview/1.png","path":"images/preformance-optimize-overview/1.png","modified":0,"renderable":0},{"_id":"source/images/shared-mem/1.png","path":"images/shared-mem/1.png","modified":0,"renderable":0},{"_id":"source/images/shared-mem/2.png","path":"images/shared-mem/2.png","modified":0,"renderable":0},{"_id":"source/images/shared-mem/3.png","path":"images/shared-mem/3.png","modified":0,"renderable":0},{"_id":"source/images/async-framework/1.png","path":"images/async-framework/1.png","modified":0,"renderable":0},{"_id":"source/images/async-framework/2.png","path":"images/async-framework/2.png","modified":0,"renderable":0},{"_id":"source/images/async-framework/3.png","path":"images/async-framework/3.png","modified":0,"renderable":0},{"_id":"source/images/template-programming/1.png","path":"images/template-programming/1.png","modified":0,"renderable":0},{"_id":"source/images/template-programming/2.png","path":"images/template-programming/2.png","modified":0,"renderable":0},{"_id":"source/images/preformance-optimize-overview/2.png","path":"images/preformance-optimize-overview/2.png","modified":0,"renderable":0},{"_id":"source/images/preformance-optimize-overview/3.png","path":"images/preformance-optimize-overview/3.png","modified":0,"renderable":0},{"_id":"source/images/preformance-optimize-overview/4.png","path":"images/preformance-optimize-overview/4.png","modified":0,"renderable":0},{"_id":"source/images/preformance-optimize-overview/5.png","path":"images/preformance-optimize-overview/5.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/Chain-of-responsibility.md","hash":"b5ffdd8c5117e1df6cdaab2efbca94ab8b6c48f5","modified":1706856454090},{"_id":"source/_posts/Cpp-basics-1.md","hash":"50555c469708548399fe8c4b1ae6a2f9f4cf48cc","modified":1702307543053},{"_id":"source/_posts/Cpp-basics-2.md","hash":"bcf386e8add4df4629dfcc29725fb44483ea4b91","modified":1702307552817},{"_id":"source/_posts/Cpp-basics-3.md","hash":"9bcc295c9921ff50ef4a2f7ba3b79a653abb4400","modified":1702307562049},{"_id":"source/_posts/Cpp-basics-4.md","hash":"0a882acecbc8ac648cde2b5679c28e3c829be067","modified":1702307571509},{"_id":"source/_posts/Cpp-basics-5.md","hash":"23eae02768c2a1c419124ad6af54862ed11598bf","modified":1702307580477},{"_id":"source/_posts/Template-programming-1.md","hash":"88d03f691d7ba902e1f62cd900cf9945306cc6fe","modified":1707413586733},{"_id":"source/_posts/Thread-safe-circular-queue.md","hash":"8770fa533cc7dda2fb9bbbb12c517a77f0380c00","modified":1705627362463},{"_id":"source/_posts/cache-friendly-programming.md","hash":"9310255a4c3479137567e3664f96020e6231922a","modified":1705545911477},{"_id":"source/_posts/lock-free-programming.md","hash":"263578ab2569346f0659518a7fe5bb0f59a1a9de","modified":1702567127854},{"_id":"source/_posts/some-plans.md","hash":"c16282b0a564daefaa6c09f1dc2144370287d664","modified":1701459323498},{"_id":"source/about/index.md","hash":"72588b3354471c29542c06748995cd49249d6a50","modified":1707115585191},{"_id":"source/images/Cpp-Basics-3-1.png","hash":"d37ee7ca1525dccd14fb09b71a8d84dc9f528bff","modified":1701615551509},{"_id":"source/images/cache-friendly-2.png","hash":"2bc8adca12bdfb357ca23c3bac491f3d3a171512","modified":1705505625607},{"_id":"source/images/cache-friendly-1.png","hash":"bc7f3894c0e354738369495b5635c5ad4fba712d","modified":1705505625607},{"_id":"source/images/lock-free-programming-2.png","hash":"f2999eceb49bb569f4b7a5f3eb8732c8a61931a6","modified":1702567025426},{"_id":"source/images/lock-free-programming-1.png","hash":"bba06b112ba07b2d6ceb0cbc2b1a29ad3272ebfa","modified":1702567024942},{"_id":"source/images/pattern-1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1702731607969},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701423241264},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1701423241260},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1701423241260},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1701423241260},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1701423241260},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1701423241260},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1701423241260},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1701423241264},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1701423241264},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1701423241264},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1701423241264},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1701423241264},{"_id":"themes/archer/_config.yml","hash":"b24277f9e750f731a8277d40f127b78bcbffb896","modified":1708107749129},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1701423241264},{"_id":"themes/archer/package.json","hash":"81af75826e854ac80f6337dc4f1ce4b51f066b0b","modified":1701423241272},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1701423241304},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1701423241304},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1701423241304},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1701423241264},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1701423241264},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1701423241264},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1701423241264},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1701423241264},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1701423241264},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1701423241264},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1701423241264},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1701423241264},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1701423241264},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1701423241264},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1701423241264},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1701423241260},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1701423241260},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1701423241260},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1701423241260},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"d8f4236166d058421c2e4ff00660be75a3494704","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"687c08823e7ce43e6ebb44f2fb4b75549abfed29","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1701423241264},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1701423241264},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1701423241264},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1701423241264},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1701423241272},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1701423241272},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1701423241272},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1701423241272},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1701423241272},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1701423241272},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1701423241272},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1701423241272},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1701423241272},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1701423241272},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1701423241272},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1701423241272},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1701423241280},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1701423241280},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1701423241280},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1701423241280},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1701423241280},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1701423241288},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1701423241300},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1701423241304},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1701423241304},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1701423241304},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1701423241304},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1701423241304},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1701423241304},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1701423241304},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1701423241304},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1701423241304},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1701423241304},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1701423241304},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1701423241304},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1701423241304},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1701423241304},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1701423241304},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1701423241304},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1701423241304},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1701423241304},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1701423241304},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1701423241304},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1701423241304},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1701423241304},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1701423241304},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1701423241304},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1701423241264},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1701423241264},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1701423241264},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1701423241264},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1701423241264},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1701423241264},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1701423241304},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1701423241304},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1701423241304},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1701423241304},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1701423241304},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1701423241304},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1701423288848},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1701423241272},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1701423241272},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1701423241276},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1701423241276},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1701423241276},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1701423241280},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1701423241276},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1701423241280},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1701423241296},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1701423241304},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1701423241264},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1701423241280},{"_id":"themes/archer/package-lock.json","hash":"400ab1cc2a2f1380a5e9ab69abe3a5b93f923d8d","modified":1701423241272},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1701423241304},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1701423241288},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1701423241296},{"_id":"public/content.json","hash":"31755072a8e66d0ccb9c8c8f270e740f6bd6c415","modified":1707843037408},{"_id":"public/about/index.html","hash":"b0af3511fccd99910bef278d215cc50defa96bf5","modified":1707843037408},{"_id":"public/2024/01/17/cache-friendly-programming/index.html","hash":"7a9b5d77c7703054d5a09ab733fd7f7d8d333c2c","modified":1706599807639},{"_id":"public/2023/12/28/Thread-safe-circular-queue/index.html","hash":"acbae853185800a93d8fe602e3f0e410d4ad0c82","modified":1706852767249},{"_id":"public/2023/12/16/Chain-of-responsibility/index.html","hash":"59a9a7c4193f7176e2249b8174ca52491954f4fa","modified":1707843037408},{"_id":"public/2023/12/11/lock-free-programming/index.html","hash":"b09b90d2b71357a94fd5717edfcb54d144aea563","modified":1706599807639},{"_id":"public/2023/12/08/Template-programming-1/index.html","hash":"be0ef18001eb2f1d387edf81abd34cdc619d894f","modified":1706853478666},{"_id":"public/2023/12/03/Cpp-basics-5/index.html","hash":"29a39238b176f7a6f2f27363fa9f68e7168a1c43","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-4/index.html","hash":"8fe4553db4ff623725f30887d55d8b6568499484","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-3/index.html","hash":"823876c40a00e4560deea996a1da4a62ba950ded","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-2/index.html","hash":"56388cda5a4f597737b1e76ef6e059204cd18fb1","modified":1705627368853},{"_id":"public/2023/12/03/Cpp-basics-1/index.html","hash":"5abad7369acc176dcd2a669d647c08b7f43a4360","modified":1705627368853},{"_id":"public/2023/12/02/some-plans/index.html","hash":"275d4d6f1ad3cc8fea091c81146cc883baea16a1","modified":1706517605102},{"_id":"public/archives/index.html","hash":"32f9f2d9f7589834ab9e3f0dad82ab118d25b494","modified":1707843037408},{"_id":"public/archives/page/2/index.html","hash":"fbb6b0e08ac285a6f7cdd466700607d9af33cf78","modified":1707843037408},{"_id":"public/archives/2023/index.html","hash":"00f73113d7501bb6faa0a15b83f20845f3428fdf","modified":1707843037408},{"_id":"public/archives/2023/12/index.html","hash":"1ea7b80d71e808d4bce08cc9300dc21706b247b5","modified":1707843037408},{"_id":"public/archives/2024/index.html","hash":"dca45988735d85b3dba9a98ae763f4d419042fdd","modified":1707843037408},{"_id":"public/archives/2024/01/index.html","hash":"d92d8a9429e2e76bdd5e0344a9c1c15b58ed6ae6","modified":1706853478666},{"_id":"public/index.html","hash":"5949a727797c499729a393faf0c8f6c394ac1296","modified":1708107753922},{"_id":"public/page/2/index.html","hash":"1af9e7910f2eb2e0afb028b0912efa65eb3a025b","modified":1708107753922},{"_id":"public/tags/design-pattern/index.html","hash":"7c0e7c4a648fae1ba67b1e3d2d56ddcd7a03d84d","modified":1706856280249},{"_id":"public/tags/Cpp/index.html","hash":"7f73d6978e9ba689a8c7623c7bc14d3a02af6929","modified":1706853478666},{"_id":"public/tags/Gpt/index.html","hash":"a07fe870cf762ca582006510ca8b63ed841557c0","modified":1706852767249},{"_id":"public/tags/Plan/index.html","hash":"153d797c02714754e9834d29d31d9de8781aef16","modified":1707116677978},{"_id":"public/images/Cpp-Basics-3-1.png","hash":"d37ee7ca1525dccd14fb09b71a8d84dc9f528bff","modified":1705507596386},{"_id":"public/images/cache-friendly-2.png","hash":"2bc8adca12bdfb357ca23c3bac491f3d3a171512","modified":1705507596386},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1705507596386},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1705507596386},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1705507596386},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1705507596386},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1705507596386},{"_id":"public/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1705507596386},{"_id":"public/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1705507596386},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1705507596386},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1705507596386},{"_id":"public/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1705507596386},{"_id":"public/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1705507596386},{"_id":"public/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1705507596386},{"_id":"public/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1705507596386},{"_id":"public/images/cache-friendly-1.png","hash":"bc7f3894c0e354738369495b5635c5ad4fba712d","modified":1705507596386},{"_id":"public/images/lock-free-programming-2.png","hash":"f2999eceb49bb569f4b7a5f3eb8732c8a61931a6","modified":1705507596386},{"_id":"public/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1705507596386},{"_id":"public/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1705507596386},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1705507596386},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1705507596386},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1705507596386},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1705507596386},{"_id":"public/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1705507596386},{"_id":"public/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1705507596386},{"_id":"public/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1705507596386},{"_id":"public/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1705507596386},{"_id":"public/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1705507596386},{"_id":"public/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1705507596386},{"_id":"public/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1705507596386},{"_id":"public/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1705507596386},{"_id":"public/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1705507596386},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1705507596386},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1705507596386},{"_id":"public/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1705507596386},{"_id":"public/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1705507596386},{"_id":"public/images/lock-free-programming-1.png","hash":"bba06b112ba07b2d6ceb0cbc2b1a29ad3272ebfa","modified":1705507596386},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1705507596386},{"_id":"public/images/pattern-1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1705507596386},{"_id":"public/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1705507596386},{"_id":"public/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1705507596386},{"_id":"source/_posts/.invisible/Cpp-basics-1.md","hash":"50555c469708548399fe8c4b1ae6a2f9f4cf48cc","modified":1702307543053},{"_id":"source/_posts/.invisible/Cpp-basics-2.md","hash":"bcf386e8add4df4629dfcc29725fb44483ea4b91","modified":1702307552817},{"_id":"source/_posts/.invisible/Cpp-basics-3.md","hash":"9bcc295c9921ff50ef4a2f7ba3b79a653abb4400","modified":1702307562049},{"_id":"source/_posts/.invisible/Cpp-basics-4.md","hash":"0a882acecbc8ac648cde2b5679c28e3c829be067","modified":1702307571509},{"_id":"source/_posts/.invisible/Cpp-basics-5.md","hash":"23eae02768c2a1c419124ad6af54862ed11598bf","modified":1702307580477},{"_id":"source/_posts/Todo-plans.md","hash":"9cb2b67ac0f5405ce0555d3ce785b8adfd3babaf","modified":1707184652441},{"_id":"public/2023/12/02/Todo-plans/index.html","hash":"0facc1c174f7c55fd7b68bf2f4b9320abd5520f5","modified":1707843037408},{"_id":"source/_posts/Cache-friendly-programming.md","hash":"9310255a4c3479137567e3664f96020e6231922a","modified":1705545911477},{"_id":"source/_posts/Lock-free-programming.md","hash":"263578ab2569346f0659518a7fe5bb0f59a1a9de","modified":1702567127854},{"_id":"public/2024/01/17/Cache-friendly-programming/index.html","hash":"fe1541cac3264e0355e59045e3dbbdfd04727767","modified":1706853478666},{"_id":"public/2023/12/11/Lock-free-programming/index.html","hash":"7c96c38f28896cb50c1b21f5b37e1c8c87f081ef","modified":1706853478666},{"_id":"source/_posts/Git-note.md","hash":"5d4f9b7b72f84e2a6eb4a0e8fb5839b020d6ed7d","modified":1707808814275},{"_id":"source/images/git-note/5.png","hash":"aa995b49e93ba6614209c3f6810907cf73b398ba","modified":1706785656526},{"_id":"source/images/git-note/4.png","hash":"92a23cfa36203e81b673c5ab7516b524767a0e58","modified":1706785657090},{"_id":"source/images/git-note/6.png","hash":"cf4190b9514a688bb1911d6a1fda643fe7cf4acc","modified":1706785646386},{"_id":"source/images/git-note/7.png","hash":"1133e055bd5c28ff77a6d2eb3319455fbe292748","modified":1706785646626},{"_id":"source/images/git-note/8.png","hash":"ffd56da0fd93052fe3a33a44913f22b72ae0dc0b","modified":1706785646678},{"_id":"source/images/git-note/9.png","hash":"cfa45589cbf8d072db5c2fbc7f27042d0018ad4f","modified":1706785646554},{"_id":"source/images/git-note/2.png","hash":"c3e332416640e8c3dd2c8c2bf9212b56c27fb442","modified":1706785646666},{"_id":"source/images/git-note/3.png","hash":"5888cca8fd2b2652c33f0f9987ba347459c269d6","modified":1706785656526},{"_id":"source/images/git-note/1.png","hash":"dbcb103a253421f3e1d515c7f4275b4efadef824","modified":1706785657158},{"_id":"public/2024/02/01/Git-note/index.html","hash":"dd81cc9ddde89e80f573f0fa7159d4afc5b5dc04","modified":1707843037408},{"_id":"public/archives/2024/02/index.html","hash":"20b106f74d0d00a271774bc5144be1c7cce8e61e","modified":1707843037408},{"_id":"public/tags/学习杂记/index.html","hash":"2ad943bda5ad1fbd118e0b29f9007413364c7c8b","modified":1707805773942},{"_id":"public/images/git-note/5.png","hash":"aa995b49e93ba6614209c3f6810907cf73b398ba","modified":1706785889352},{"_id":"public/images/git-note/4.png","hash":"92a23cfa36203e81b673c5ab7516b524767a0e58","modified":1706785889352},{"_id":"public/images/git-note/6.png","hash":"cf4190b9514a688bb1911d6a1fda643fe7cf4acc","modified":1706785889352},{"_id":"public/images/git-note/7.png","hash":"1133e055bd5c28ff77a6d2eb3319455fbe292748","modified":1706785889352},{"_id":"public/images/git-note/8.png","hash":"ffd56da0fd93052fe3a33a44913f22b72ae0dc0b","modified":1706785889352},{"_id":"public/images/git-note/9.png","hash":"cfa45589cbf8d072db5c2fbc7f27042d0018ad4f","modified":1706785889352},{"_id":"public/images/git-note/2.png","hash":"c3e332416640e8c3dd2c8c2bf9212b56c27fb442","modified":1706785889352},{"_id":"public/images/git-note/3.png","hash":"5888cca8fd2b2652c33f0f9987ba347459c269d6","modified":1706785889352},{"_id":"public/images/git-note/1.png","hash":"dbcb103a253421f3e1d515c7f4275b4efadef824","modified":1706785889352},{"_id":"source/images/design-pattern/1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1702731607969},{"_id":"public/images/design-pattern/1.png","hash":"74a4573dadbe3a7927a146610cb34230ab439c52","modified":1706803100691},{"_id":"source/_posts/Refactor-project.md","hash":"07b7994dbca19d4fc3546e732d4a631158bc01e8","modified":1707808834419},{"_id":"source/images/refactor-project/1.png","hash":"6ac2914f05e62aa7ac36d1f54729e28959690318","modified":1706803818664},{"_id":"source/images/refactor-project/4.png","hash":"3af8036a7a8768cafcfe00afb300c94a8da5044a","modified":1706803819892},{"_id":"source/images/refactor-project/3.png","hash":"5fe8ee0104869a15d8eb49c23103dbd6cc3b77e0","modified":1706803819696},{"_id":"source/images/refactor-project/2.png","hash":"c02d0819bf2ee5d8ddea0961f9659cf468341b40","modified":1706803819696},{"_id":"public/2024/02/02/Refactor-project/index.html","hash":"5b249fa3dc69c53d880b3ccb4eddf5d1662fe5b6","modified":1707843037408},{"_id":"public/images/refactor-project/1.png","hash":"6ac2914f05e62aa7ac36d1f54729e28959690318","modified":1706804220987},{"_id":"public/images/refactor-project/4.png","hash":"3af8036a7a8768cafcfe00afb300c94a8da5044a","modified":1706804220987},{"_id":"public/images/refactor-project/3.png","hash":"5fe8ee0104869a15d8eb49c23103dbd6cc3b77e0","modified":1706804220987},{"_id":"public/images/refactor-project/2.png","hash":"c02d0819bf2ee5d8ddea0961f9659cf468341b40","modified":1706804220987},{"_id":"source/_posts/Look-free-log.md","hash":"3cee6cc4af9e97723341420d08d417598c2fdad6","modified":1706852910498},{"_id":"public/2024/02/02/Look-free-log/index.html","hash":"6fd86ceb793f5bca1f786ad111392674ce7fface","modified":1707843037408},{"_id":"public/tags/工具集合/index.html","hash":"e1b8f79efc2b91f917b31dee172c7217cf49e18e","modified":1707843037408},{"_id":"source/_posts/Look-free-circular-queue.md","hash":"d3a3d473bdc48f654d88a05d9942621334aabc66","modified":1706853470494},{"_id":"public/2023/12/28/Look-free-circular-queue/index.html","hash":"a5cebd05a697c6d4bf6ca915e3d86cd7abf65bc9","modified":1707843037408},{"_id":"source/_posts/.invisible/Cache-friendly-programming.md","hash":"9310255a4c3479137567e3664f96020e6231922a","modified":1705545911477},{"_id":"source/_posts/.invisible/Lock-free-programming.md","hash":"263578ab2569346f0659518a7fe5bb0f59a1a9de","modified":1702567127854},{"_id":"source/_posts/.invisible/Template-programming-1.md","hash":"6468a228b5e0df210112afa5fa7f192a8a29b62a","modified":1702307589473},{"_id":"source/_posts/Preformance-optimize-overview.md","hash":"2315b54250d81034146160b812e0b567dc580fdc","modified":1706856504442},{"_id":"source/images/preformance-optimize-overview/1.png","hash":"97e3e375181395323437ba0edc8d2e726633c4e5","modified":1706854829734},{"_id":"public/2024/02/02/Preformance-optimize-overview/index.html","hash":"249b106e9f8c43f6e5a03bdaf20d7aba00ff1c19","modified":1707112695513},{"_id":"public/tags/随感杂记/index.html","hash":"1b1c75bbc29e9bbe04045c69f837963be5b8408e","modified":1707843037408},{"_id":"public/images/preformance-optimize-overview/1.png","hash":"97e3e375181395323437ba0edc8d2e726633c4e5","modified":1706854946576},{"_id":"source/_posts/Poxis-api.md","hash":"f36ffca2c5d9264bdb02bdb3286df85f33f89b65","modified":1706856273170},{"_id":"source/_posts/Systemv-api.md","hash":"0ec4bdb9d9ef91f59e5e1ac9d6b50932bb258a57","modified":1706856176294},{"_id":"source/images/shared-mem/2.png","hash":"6d3e96dae2d40b9d5000360e8adccfdfb6c9d4df","modified":1706856037718},{"_id":"source/images/shared-mem/3.png","hash":"87dd8da0055b2eede6dc839537b94d9927533e61","modified":1706856037686},{"_id":"source/images/shared-mem/1.png","hash":"04f97909e7e2d8d0fe0677d930babf15c8c75a26","modified":1706856037786},{"_id":"public/2024/02/02/Poxis-api/index.html","hash":"a1d1df6e9241b2a196d6ae9ca6ea47b648a0ecbe","modified":1707843037408},{"_id":"public/2024/02/02/Systemv-api/index.html","hash":"de8f78e926c85de97c7bb329506a1c6c0398182f","modified":1707843037408},{"_id":"public/tags/共享内存/index.html","hash":"b157b9ac0361a289b4b419c83f724c1f646db8e0","modified":1707843037408},{"_id":"public/images/shared-mem/2.png","hash":"6d3e96dae2d40b9d5000360e8adccfdfb6c9d4df","modified":1706856280249},{"_id":"public/images/shared-mem/3.png","hash":"87dd8da0055b2eede6dc839537b94d9927533e61","modified":1706856280249},{"_id":"public/images/shared-mem/1.png","hash":"04f97909e7e2d8d0fe0677d930babf15c8c75a26","modified":1706856280249},{"_id":"public/tags/设计模式/index.html","hash":"d87b484f55f6ec4934eebcd9d15561723b33b4e6","modified":1707843037408},{"_id":"source/_posts/Sync-and-block.md","hash":"879d12a4c4643c76de6298abbe62f7b74a912b51","modified":1707111197138},{"_id":"public/2024/02/05/Sync-and-block/index.html","hash":"31348cbf86831eaabc0033d2556312eed250efd2","modified":1707843037408},{"_id":"source/_posts/Async-framework.md","hash":"777d505659a6c83ff618c2ecfa77e8eee6e7e831","modified":1707112362390},{"_id":"source/images/async-framework/2.png","hash":"2014342c37c683de7ed335c88ca10f346da92075","modified":1707112074846},{"_id":"source/images/async-framework/3.png","hash":"df099badc0d30fafad99fb60d1a470455d1f9988","modified":1707112074854},{"_id":"source/images/async-framework/1.png","hash":"ca861025f66c735e9f3217d8414834f7a8d0f1f3","modified":1707112074894},{"_id":"public/2024/02/05/Async-framework/index.html","hash":"e720ef147f0ddb7c5c3f6e8c17c5168ab3e52f0a","modified":1707843037408},{"_id":"public/tags/学习笔记/index.html","hash":"a4d111488ef3d0b26e48e52015b73800971d4ddc","modified":1707843037408},{"_id":"public/images/async-framework/2.png","hash":"2014342c37c683de7ed335c88ca10f346da92075","modified":1707112146744},{"_id":"public/images/async-framework/3.png","hash":"df099badc0d30fafad99fb60d1a470455d1f9988","modified":1707112146744},{"_id":"public/images/async-framework/1.png","hash":"ca861025f66c735e9f3217d8414834f7a8d0f1f3","modified":1707112146744},{"_id":"source/_posts/Byte-order-conversion.md","hash":"bddc8f61b8daf4fed49f72728213024d1070e742","modified":1707112686198},{"_id":"public/2024/02/05/Byte-order-conversion/index.html","hash":"414ca932c0271b41ca79eeb3674a3cedcb6dfb86","modified":1707843037408},{"_id":"source/_posts/Preformance-optimize-1.md","hash":"96b44b80fd5d11acebaac05e890f7ae8eac40bfd","modified":1707113437894},{"_id":"source/_posts/Preformance-optimize-2.md","hash":"1b7276ac428f6ac11a1545fd5a47a57a4a954439","modified":1707113676566},{"_id":"public/2024/02/05/Preformance-optimize-2/index.html","hash":"610b96c38556d57f8d99ada7958839d5a16d9765","modified":1707843037408},{"_id":"public/2024/02/02/Preformance-optimize-1/index.html","hash":"250e9cc3d1028c78bbcfd21b756fe4e51aa9e4bb","modified":1707843037408},{"_id":"public/tags/性能优化/index.html","hash":"fac7cec58cdf07505fb9f62360a9513aeb47f058","modified":1707843037408},{"_id":"source/_posts/Measure-time.md","hash":"4a99acaf24631600bb5256e71e8ac02cfb13f0c1","modified":1707116637375},{"_id":"public/2024/02/05/Measure-time/index.html","hash":"1c9a4ab1fffa3b1a9f0be9add271f05040efedc7","modified":1707843037408},{"_id":"public/archives/2024/page/2/index.html","hash":"0e8e5ee891cff5bbeaea5962f922c58bbbe605da","modified":1707843037408},{"_id":"public/archives/2024/02/page/2/index.html","hash":"28f6f9e4b50a3ed18033f6aa44a24acb963ebcec","modified":1707843037408},{"_id":"public/2024/02/09/Template-programming-1/index.html","hash":"c780bfd8df5967f7b6803d45879fa0afdc302e2e","modified":1707843037408},{"_id":"public/tags/模板编程/index.html","hash":"eeef2ad9fdb67616bc259ba8bab55dfd560cba5e","modified":1707843037408},{"_id":"source/_posts/Template-programming-3.md","hash":"4ed47c7704bfb70fd00fa016036e9a807e93bec8","modified":1707741578258},{"_id":"public/2024/02/09/Template-programming-3/index.html","hash":"d4b00ef014d07fc5fa51118192f4bc89b7447fd7","modified":1707413592006},{"_id":"source/_posts/Template-programming-2.md","hash":"082fb2dd978ee50e89f5a73a458066602d8ef626","modified":1707762594499},{"_id":"public/2024/02/12/Template-programming-3/index.html","hash":"e031c858620781622c22338c768a1d93fc22c80c","modified":1707843037408},{"_id":"public/2024/02/12/Template-programming-2/index.html","hash":"ac02aae777478b4bd24bb9554d019e6e738494d1","modified":1707843037408},{"_id":"source/_posts/Template-programming-4.md","hash":"9f7569f2aed497d52a211fe45f4ab6f7fa142fda","modified":1707762890511},{"_id":"source/images/template-programming/1.png","hash":"5c4a4a269c828491a6cdb1de3b33a71e83d8cdd2","modified":1707762844003},{"_id":"source/images/template-programming/2.png","hash":"f3f42832442a62b975f118bae64c97eb7eaeb65d","modified":1707762844003},{"_id":"public/2024/02/13/Template-programming-4/index.html","hash":"1b751b142513156ba687e635f0b24cf0de7994f7","modified":1707843037408},{"_id":"public/images/template-programming/1.png","hash":"5c4a4a269c828491a6cdb1de3b33a71e83d8cdd2","modified":1707762934469},{"_id":"public/images/template-programming/2.png","hash":"f3f42832442a62b975f118bae64c97eb7eaeb65d","modified":1707762934469},{"_id":"source/_posts/Preformance-optimize-3.md","hash":"786ff738f8297a739e08910df31904c5fc5ccde1","modified":1707841355511},{"_id":"source/images/preformance-optimize-overview/3.png","hash":"f2999eceb49bb569f4b7a5f3eb8732c8a61931a6","modified":1702567025426},{"_id":"source/images/preformance-optimize-overview/2.png","hash":"bba06b112ba07b2d6ceb0cbc2b1a29ad3272ebfa","modified":1702567024942},{"_id":"public/2024/02/14/Preformance-optimize-3/index.html","hash":"d28893319f92bc2a69f5b1d7417e4d1f2976470f","modified":1707843037408},{"_id":"public/images/preformance-optimize-overview/3.png","hash":"f2999eceb49bb569f4b7a5f3eb8732c8a61931a6","modified":1707841361023},{"_id":"public/images/preformance-optimize-overview/2.png","hash":"bba06b112ba07b2d6ceb0cbc2b1a29ad3272ebfa","modified":1707841361023},{"_id":"source/_posts/Preformance-optimize-4.md","hash":"3724c70dd763913e59ff74beb31af4dc6a6e2f4b","modified":1707843411463},{"_id":"source/images/preformance-optimize-overview/5.png","hash":"2bc8adca12bdfb357ca23c3bac491f3d3a171512","modified":1705505625607},{"_id":"source/images/preformance-optimize-overview/4.png","hash":"bc7f3894c0e354738369495b5635c5ad4fba712d","modified":1705505625607},{"_id":"public/2024/02/14/Preformance-optimize-4/index.html","hash":"f9b98d3aa1ea2cf331cd1a47e9d94847fb31458a","modified":1707843415848},{"_id":"public/images/preformance-optimize-overview/5.png","hash":"2bc8adca12bdfb357ca23c3bac491f3d3a171512","modified":1707843037408},{"_id":"public/images/preformance-optimize-overview/4.png","hash":"bc7f3894c0e354738369495b5635c5ad4fba712d","modified":1707843037408}],"Category":[],"Data":[],"Page":[{"title":"About Me","layout":"about","date":"2023-12-01T08:44:29.000Z","_content":"\n## 关于我\n最开始我写了一版介绍，介绍了很多关于我的世俗的东西，后来越看越自惭于我灵魂的无趣，终于在某天羞臊地删掉了。\n我觉得，生活已经这么无趣了，就不应该在赛博空间里还蔓延这种无趣，继续追寻这种基于世俗评价下的刻板指标。\n因此，我想简单介绍一下我最近自己在想的事情，关于生活、关于生活的意义。\n## 关于加缪\n加缪说， 自杀是唯一严肃的哲学问题。\n在《西西弗斯神话》中，他写到西西弗斯被罚推一块石头上山，每当他费尽力气把石头推到山顶，石头又会重新滑落。这个神话故事展现了加缪讨论自杀问题的背景：如果人生注定是没有意义的，是荒诞的，我们是否应该选择自杀呢？\n加缪给出的答案是：自杀不是对抗荒诞的方法，自杀意味着荒诞的胜利。\n想象两种人：一种人不知道自己的生活就是荒诞，而生活在荒诞中；另一种知道自己的生活就是荒诞，但仍然推石头上山，哪一种更像悲剧呢？\n加缪认为前一种人更加悲剧。因为他的荒诞甚至不属于他自己！而后一种人，也就是西西弗斯，虽然他的命运也是荒诞，他的处境也没好到哪里去，但他因推石头而存在，他的荒诞属于他自己，他的石头也属于他自己，他支配了他自己的荒诞，因此我们可以认为他是幸福的。\n西西弗斯不断重复的努力，对自己努力终将毫无成果的清晰意识，就是胜利本身。神之所以认为重复地推石头是一项极其严厉的惩罚，就是因为这件事毫无意义，而重复的痛苦比一次性的痛苦更能摧毁一个人的意志。\n但是西西弗斯用他坚持不懈的行动表明，神给他的惩罚没有实现神想要的效果。当西西弗斯看着石头滚落，即使意识到这件事的荒诞，仍然用自己的意志坚定地重新开始推石头，他就证明了自己比那块石头更加强大，比诸神更加强大，比命运更加强大。他战胜了荒诞。\n## 关于生活\n我从一出生开始，就像是站在莫名其妙的赛道上，周围的人都加油呐喊，在喊着要我赢，我也因此背负着视线，奔跑在赛道上。\n一直到某一天，我开始思考，我为什么非得参加比赛呢？我开始环顾其他人：\n有的人为了在比赛中赢而拼搏；有的人自觉生来不需要比赛；有的人认为比赛毫无意义，不知道干什么；有的人认为自己可以赋予任何事物自己想要的意义，可能他们觉得比赛无意义，但是跳舞有意义，于是他们反复练习跳舞；有的人认为其他人都有毛病，比赛只是给一些不需要参加比赛的人看来娱乐他们；有的人认为比赛毫无意义，于是他们可能跑，可能跳，可能游泳，可能飞，可能参加，也可能不参加。\n我忽然意识到，当大家觉悟到“我”这一概念的瞬间，就已经拥有了自己独属的终点了，只要\"我为我\"，任何人都走在通往幸福的路上，其实每一种人都有可能找到自己的幸福。\n但这只是他们的幸福，和我无关，我得先去找到我对幸福的定义，才有资格拥有它，而不是只知道在赛道上狂奔，如果终点处，不是属于我的终点，那么，这场比赛毫无意义。","source":"about/index.md","raw":"---\ntitle: About Me\nlayout: about\ndate: 2023-12-01 16:44:29\n---\n\n## 关于我\n最开始我写了一版介绍，介绍了很多关于我的世俗的东西，后来越看越自惭于我灵魂的无趣，终于在某天羞臊地删掉了。\n我觉得，生活已经这么无趣了，就不应该在赛博空间里还蔓延这种无趣，继续追寻这种基于世俗评价下的刻板指标。\n因此，我想简单介绍一下我最近自己在想的事情，关于生活、关于生活的意义。\n## 关于加缪\n加缪说， 自杀是唯一严肃的哲学问题。\n在《西西弗斯神话》中，他写到西西弗斯被罚推一块石头上山，每当他费尽力气把石头推到山顶，石头又会重新滑落。这个神话故事展现了加缪讨论自杀问题的背景：如果人生注定是没有意义的，是荒诞的，我们是否应该选择自杀呢？\n加缪给出的答案是：自杀不是对抗荒诞的方法，自杀意味着荒诞的胜利。\n想象两种人：一种人不知道自己的生活就是荒诞，而生活在荒诞中；另一种知道自己的生活就是荒诞，但仍然推石头上山，哪一种更像悲剧呢？\n加缪认为前一种人更加悲剧。因为他的荒诞甚至不属于他自己！而后一种人，也就是西西弗斯，虽然他的命运也是荒诞，他的处境也没好到哪里去，但他因推石头而存在，他的荒诞属于他自己，他的石头也属于他自己，他支配了他自己的荒诞，因此我们可以认为他是幸福的。\n西西弗斯不断重复的努力，对自己努力终将毫无成果的清晰意识，就是胜利本身。神之所以认为重复地推石头是一项极其严厉的惩罚，就是因为这件事毫无意义，而重复的痛苦比一次性的痛苦更能摧毁一个人的意志。\n但是西西弗斯用他坚持不懈的行动表明，神给他的惩罚没有实现神想要的效果。当西西弗斯看着石头滚落，即使意识到这件事的荒诞，仍然用自己的意志坚定地重新开始推石头，他就证明了自己比那块石头更加强大，比诸神更加强大，比命运更加强大。他战胜了荒诞。\n## 关于生活\n我从一出生开始，就像是站在莫名其妙的赛道上，周围的人都加油呐喊，在喊着要我赢，我也因此背负着视线，奔跑在赛道上。\n一直到某一天，我开始思考，我为什么非得参加比赛呢？我开始环顾其他人：\n有的人为了在比赛中赢而拼搏；有的人自觉生来不需要比赛；有的人认为比赛毫无意义，不知道干什么；有的人认为自己可以赋予任何事物自己想要的意义，可能他们觉得比赛无意义，但是跳舞有意义，于是他们反复练习跳舞；有的人认为其他人都有毛病，比赛只是给一些不需要参加比赛的人看来娱乐他们；有的人认为比赛毫无意义，于是他们可能跑，可能跳，可能游泳，可能飞，可能参加，也可能不参加。\n我忽然意识到，当大家觉悟到“我”这一概念的瞬间，就已经拥有了自己独属的终点了，只要\"我为我\"，任何人都走在通往幸福的路上，其实每一种人都有可能找到自己的幸福。\n但这只是他们的幸福，和我无关，我得先去找到我对幸福的定义，才有资格拥有它，而不是只知道在赛道上狂奔，如果终点处，不是属于我的终点，那么，这场比赛毫无意义。","updated":"2024-02-05T06:46:25.191Z","path":"about/index.html","_id":"clrhz6rwc00000ox547gvgicj","comments":1,"content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>最开始我写了一版介绍，介绍了很多关于我的世俗的东西，后来越看越自惭于我灵魂的无趣，终于在某天羞臊地删掉了。<br>我觉得，生活已经这么无趣了，就不应该在赛博空间里还蔓延这种无趣，继续追寻这种基于世俗评价下的刻板指标。<br>因此，我想简单介绍一下我最近自己在想的事情，关于生活、关于生活的意义。</p>\n<h2 id=\"关于加缪\"><a href=\"#关于加缪\" class=\"headerlink\" title=\"关于加缪\"></a>关于加缪</h2><p>加缪说， 自杀是唯一严肃的哲学问题。<br>在《西西弗斯神话》中，他写到西西弗斯被罚推一块石头上山，每当他费尽力气把石头推到山顶，石头又会重新滑落。这个神话故事展现了加缪讨论自杀问题的背景：如果人生注定是没有意义的，是荒诞的，我们是否应该选择自杀呢？<br>加缪给出的答案是：自杀不是对抗荒诞的方法，自杀意味着荒诞的胜利。<br>想象两种人：一种人不知道自己的生活就是荒诞，而生活在荒诞中；另一种知道自己的生活就是荒诞，但仍然推石头上山，哪一种更像悲剧呢？<br>加缪认为前一种人更加悲剧。因为他的荒诞甚至不属于他自己！而后一种人，也就是西西弗斯，虽然他的命运也是荒诞，他的处境也没好到哪里去，但他因推石头而存在，他的荒诞属于他自己，他的石头也属于他自己，他支配了他自己的荒诞，因此我们可以认为他是幸福的。<br>西西弗斯不断重复的努力，对自己努力终将毫无成果的清晰意识，就是胜利本身。神之所以认为重复地推石头是一项极其严厉的惩罚，就是因为这件事毫无意义，而重复的痛苦比一次性的痛苦更能摧毁一个人的意志。<br>但是西西弗斯用他坚持不懈的行动表明，神给他的惩罚没有实现神想要的效果。当西西弗斯看着石头滚落，即使意识到这件事的荒诞，仍然用自己的意志坚定地重新开始推石头，他就证明了自己比那块石头更加强大，比诸神更加强大，比命运更加强大。他战胜了荒诞。</p>\n<h2 id=\"关于生活\"><a href=\"#关于生活\" class=\"headerlink\" title=\"关于生活\"></a>关于生活</h2><p>我从一出生开始，就像是站在莫名其妙的赛道上，周围的人都加油呐喊，在喊着要我赢，我也因此背负着视线，奔跑在赛道上。<br>一直到某一天，我开始思考，我为什么非得参加比赛呢？我开始环顾其他人：<br>有的人为了在比赛中赢而拼搏；有的人自觉生来不需要比赛；有的人认为比赛毫无意义，不知道干什么；有的人认为自己可以赋予任何事物自己想要的意义，可能他们觉得比赛无意义，但是跳舞有意义，于是他们反复练习跳舞；有的人认为其他人都有毛病，比赛只是给一些不需要参加比赛的人看来娱乐他们；有的人认为比赛毫无意义，于是他们可能跑，可能跳，可能游泳，可能飞，可能参加，也可能不参加。<br>我忽然意识到，当大家觉悟到“我”这一概念的瞬间，就已经拥有了自己独属的终点了，只要”我为我”，任何人都走在通往幸福的路上，其实每一种人都有可能找到自己的幸福。<br>但这只是他们的幸福，和我无关，我得先去找到我对幸福的定义，才有资格拥有它，而不是只知道在赛道上狂奔，如果终点处，不是属于我的终点，那么，这场比赛毫无意义。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>最开始我写了一版介绍，介绍了很多关于我的世俗的东西，后来越看越自惭于我灵魂的无趣，终于在某天羞臊地删掉了。<br>我觉得，生活已经这么无趣了，就不应该在赛博空间里还蔓延这种无趣，继续追寻这种基于世俗评价下的刻板指标。<br>因此，我想简单介绍一下我最近自己在想的事情，关于生活、关于生活的意义。</p>\n<h2 id=\"关于加缪\"><a href=\"#关于加缪\" class=\"headerlink\" title=\"关于加缪\"></a>关于加缪</h2><p>加缪说， 自杀是唯一严肃的哲学问题。<br>在《西西弗斯神话》中，他写到西西弗斯被罚推一块石头上山，每当他费尽力气把石头推到山顶，石头又会重新滑落。这个神话故事展现了加缪讨论自杀问题的背景：如果人生注定是没有意义的，是荒诞的，我们是否应该选择自杀呢？<br>加缪给出的答案是：自杀不是对抗荒诞的方法，自杀意味着荒诞的胜利。<br>想象两种人：一种人不知道自己的生活就是荒诞，而生活在荒诞中；另一种知道自己的生活就是荒诞，但仍然推石头上山，哪一种更像悲剧呢？<br>加缪认为前一种人更加悲剧。因为他的荒诞甚至不属于他自己！而后一种人，也就是西西弗斯，虽然他的命运也是荒诞，他的处境也没好到哪里去，但他因推石头而存在，他的荒诞属于他自己，他的石头也属于他自己，他支配了他自己的荒诞，因此我们可以认为他是幸福的。<br>西西弗斯不断重复的努力，对自己努力终将毫无成果的清晰意识，就是胜利本身。神之所以认为重复地推石头是一项极其严厉的惩罚，就是因为这件事毫无意义，而重复的痛苦比一次性的痛苦更能摧毁一个人的意志。<br>但是西西弗斯用他坚持不懈的行动表明，神给他的惩罚没有实现神想要的效果。当西西弗斯看着石头滚落，即使意识到这件事的荒诞，仍然用自己的意志坚定地重新开始推石头，他就证明了自己比那块石头更加强大，比诸神更加强大，比命运更加强大。他战胜了荒诞。</p>\n<h2 id=\"关于生活\"><a href=\"#关于生活\" class=\"headerlink\" title=\"关于生活\"></a>关于生活</h2><p>我从一出生开始，就像是站在莫名其妙的赛道上，周围的人都加油呐喊，在喊着要我赢，我也因此背负着视线，奔跑在赛道上。<br>一直到某一天，我开始思考，我为什么非得参加比赛呢？我开始环顾其他人：<br>有的人为了在比赛中赢而拼搏；有的人自觉生来不需要比赛；有的人认为比赛毫无意义，不知道干什么；有的人认为自己可以赋予任何事物自己想要的意义，可能他们觉得比赛无意义，但是跳舞有意义，于是他们反复练习跳舞；有的人认为其他人都有毛病，比赛只是给一些不需要参加比赛的人看来娱乐他们；有的人认为比赛毫无意义，于是他们可能跑，可能跳，可能游泳，可能飞，可能参加，也可能不参加。<br>我忽然意识到，当大家觉悟到“我”这一概念的瞬间，就已经拥有了自己独属的终点了，只要”我为我”，任何人都走在通往幸福的路上，其实每一种人都有可能找到自己的幸福。<br>但这只是他们的幸福，和我无关，我得先去找到我对幸福的定义，才有资格拥有它，而不是只知道在赛道上狂奔，如果终点处，不是属于我的终点，那么，这场比赛毫无意义。</p>\n"}],"Post":[{"title":"设计模式（一）：责任链","date":"2023-12-16T12:55:02.000Z","_content":"责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。\n\n\n# 背景\n在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。\n在设计之初有着足够简单的业务流程：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1\n3. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1\n3. 供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1\n4. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：\n\n1. 在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。\n2. 对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。\n3. 当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。\n# 解决方案\n与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。\n\n- 在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。\n- 请求及其数据则会被作为参数传递给该方法。\n\n责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。\n\n- 除了处理请求外，处理者还负责沿着链传递请求。\n- 请求会在链上移动，直至所有处理者都有机会对请求进行处理。\n\n最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。\n还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。\n\n- 如果自己能够处理，处理者就不再继续传递请求。\n- 在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理\n\n连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。\n\n- 对于第二种方式，感觉有些像观察者模式。\n- 两者具体实现、目的都差不多。主要区别在于：\n   - 观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可\n   - 责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理\n\n![image.png](/images/design-pattern/1.png)\n责任链模式的核心在于将处理对象整理成链路。\n# 适用场景\n\n- 程序需要使用不同方式处理请求\n   - 将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。\n- 当必须按顺序执行多个处理者时，可以使用该模式。\n   - 无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。\n- 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。\n   - 如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。\n# 实现步骤\n\n1. 声明处理者接口并提供请求处理方法的签名。\n   - 确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。\n2. 为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。\n   - 该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。\n   - 还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。\n3. 依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：\n   - 是否自行处理这个请求\n   - 是否将该请求沿着链进行传递\n4. 客户端可以自行组装链，或者从其他对象处获得预先组装好的链。\n   - 在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链\n5. 客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。\n6. 由于链的动态性，客户端需要处理以下情况：\n   - 部分请求可能无法到达链尾\n   - 其他请求可能直到链尾都未被处理\n# 优缺点\n优点：\n\n- 可以控制请求处理的顺序。\n- 单一职责原则。解耦了发起操作和执行操作的类。\n- 开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。\n\n缺点：\n\n- 部分请求最终可能都未被处理。\n# 与其它模式的关系\n\n- 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   - 责任链模式按照顺序将请求动态传递给一系列的潜在接收者。\n   - 命令模式在发送者和请求者之间建立单向连接。\n   - 中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。\n   - 观察者模式允许接收者动态地订阅或取消接收请求。\n- 责任链可以和组合模式结合使用\n   - 叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。\n- 责任链上的处理器可使用命令模式实现\n   - 可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   - 或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。\n- 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同\n   - 责任链上的处理器可以相互独立地执行，还可以随时停止传递请求\n   - 各种装饰可以在遵循基本接口的情况下扩展对象的行为\n   - 装饰无法中断请求的传递\n# 示例\n```cpp\n#include <iostream>\n#include <string>\n\n// 定义处理者接口\nclass Approver {\npublic:\nvirtual void processRequest(const std::string& request) = 0;\nvirtual ~Approver() {}\n};\n\n// 创建抽象处理者基类\nclass BaseApprover : public Approver {\nprivate:\nApprover* nextApprover;\n\npublic:\nBaseApprover() : nextApprover(nullptr) {}\n\n// 设置下一个处理者\nvoid setNextApprover(Approver* next) {\n    nextApprover = next;\n}\n\n// 处理请求的默认行为\nvoid processRequest(const std::string& request) override {\n    if (nextApprover != nullptr) {\n        nextApprover->processRequest(request);\n    } else {\n        std::cout << \"Request not handled by any approver.\" << std::endl;\n    }\n}\n};\n\n// 具体处理者子类：商品品控人员\nclass QualityControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"QualityCheck\") {\n        std::cout << \"QualityControlApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：供应商资质管理员\nclass SupplierQualificationApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"SupplierQualificationCheck\") {\n        std::cout << \"SupplierQualificationApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：上架风控人员\nclass RiskControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"MarketingRuleCheck\") {\n        std::cout << \"RiskControlApprover handles the request and approves the product for shelf.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\nint main() {\n    // 创建责任链\n    QualityControlApprover qualityControlApprover;\n    SupplierQualificationApprover supplierQualificationApprover;\n    RiskControlApprover riskControlApprover;\n\n    // 设置责任链顺序\n    qualityControlApprover.setNextApprover(&supplierQualificationApprover);\n    supplierQualificationApprover.setNextApprover(&riskControlApprover);\n\n    // 模拟商品上架流程\n    std::cout << \"Scenario 1:\" << std::endl;\n    qualityControlApprover.processRequest(\"QualityCheck\");\n\n    std::cout << \"\\nScenario 2:\" << std::endl;\n    qualityControlApprover.processRequest(\"SupplierQualificationCheck\");\n\n    std::cout << \"\\nScenario 3:\" << std::endl;\n    qualityControlApprover.processRequest(\"MarketingRuleCheck\");\n\n    std::cout << \"\\nScenario 4:\" << std::endl;\n    qualityControlApprover.processRequest(\"SomeOtherCheck\");\n\n    return 0;\n}\n\n```\n\n\n","source":"_posts/Chain-of-responsibility.md","raw":"---\ntitle: 设计模式（一）：责任链\ndate: 2023-12-16 20:55:02\ntags: 设计模式\n---\n责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。\n\n\n# 背景\n在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。\n在设计之初有着足够简单的业务流程：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1\n3. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：\n\n1. 供应商发起上架流程审批，成功则进入2，不成功重新发起1\n2. 商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1\n3. 供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1\n4. 上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1\n\n在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：\n\n1. 在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。\n2. 对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。\n3. 当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。\n# 解决方案\n与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。\n\n- 在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。\n- 请求及其数据则会被作为参数传递给该方法。\n\n责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。\n\n- 除了处理请求外，处理者还负责沿着链传递请求。\n- 请求会在链上移动，直至所有处理者都有机会对请求进行处理。\n\n最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。\n还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。\n\n- 如果自己能够处理，处理者就不再继续传递请求。\n- 在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理\n\n连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。\n\n- 对于第二种方式，感觉有些像观察者模式。\n- 两者具体实现、目的都差不多。主要区别在于：\n   - 观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可\n   - 责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理\n\n![image.png](/images/design-pattern/1.png)\n责任链模式的核心在于将处理对象整理成链路。\n# 适用场景\n\n- 程序需要使用不同方式处理请求\n   - 将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。\n- 当必须按顺序执行多个处理者时，可以使用该模式。\n   - 无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。\n- 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。\n   - 如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。\n# 实现步骤\n\n1. 声明处理者接口并提供请求处理方法的签名。\n   - 确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。\n2. 为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。\n   - 该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。\n   - 还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。\n3. 依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：\n   - 是否自行处理这个请求\n   - 是否将该请求沿着链进行传递\n4. 客户端可以自行组装链，或者从其他对象处获得预先组装好的链。\n   - 在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链\n5. 客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。\n6. 由于链的动态性，客户端需要处理以下情况：\n   - 部分请求可能无法到达链尾\n   - 其他请求可能直到链尾都未被处理\n# 优缺点\n优点：\n\n- 可以控制请求处理的顺序。\n- 单一职责原则。解耦了发起操作和执行操作的类。\n- 开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。\n\n缺点：\n\n- 部分请求最终可能都未被处理。\n# 与其它模式的关系\n\n- 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   - 责任链模式按照顺序将请求动态传递给一系列的潜在接收者。\n   - 命令模式在发送者和请求者之间建立单向连接。\n   - 中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。\n   - 观察者模式允许接收者动态地订阅或取消接收请求。\n- 责任链可以和组合模式结合使用\n   - 叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。\n- 责任链上的处理器可使用命令模式实现\n   - 可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   - 或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。\n- 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同\n   - 责任链上的处理器可以相互独立地执行，还可以随时停止传递请求\n   - 各种装饰可以在遵循基本接口的情况下扩展对象的行为\n   - 装饰无法中断请求的传递\n# 示例\n```cpp\n#include <iostream>\n#include <string>\n\n// 定义处理者接口\nclass Approver {\npublic:\nvirtual void processRequest(const std::string& request) = 0;\nvirtual ~Approver() {}\n};\n\n// 创建抽象处理者基类\nclass BaseApprover : public Approver {\nprivate:\nApprover* nextApprover;\n\npublic:\nBaseApprover() : nextApprover(nullptr) {}\n\n// 设置下一个处理者\nvoid setNextApprover(Approver* next) {\n    nextApprover = next;\n}\n\n// 处理请求的默认行为\nvoid processRequest(const std::string& request) override {\n    if (nextApprover != nullptr) {\n        nextApprover->processRequest(request);\n    } else {\n        std::cout << \"Request not handled by any approver.\" << std::endl;\n    }\n}\n};\n\n// 具体处理者子类：商品品控人员\nclass QualityControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"QualityCheck\") {\n        std::cout << \"QualityControlApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：供应商资质管理员\nclass SupplierQualificationApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"SupplierQualificationCheck\") {\n        std::cout << \"SupplierQualificationApprover handles the request.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\n// 具体处理者子类：上架风控人员\nclass RiskControlApprover : public BaseApprover {\npublic:\nvoid processRequest(const std::string& request) override {\n    if (request == \"MarketingRuleCheck\") {\n        std::cout << \"RiskControlApprover handles the request and approves the product for shelf.\" << std::endl;\n    } else {\n        BaseApprover::processRequest(request);\n    }\n}\n};\n\nint main() {\n    // 创建责任链\n    QualityControlApprover qualityControlApprover;\n    SupplierQualificationApprover supplierQualificationApprover;\n    RiskControlApprover riskControlApprover;\n\n    // 设置责任链顺序\n    qualityControlApprover.setNextApprover(&supplierQualificationApprover);\n    supplierQualificationApprover.setNextApprover(&riskControlApprover);\n\n    // 模拟商品上架流程\n    std::cout << \"Scenario 1:\" << std::endl;\n    qualityControlApprover.processRequest(\"QualityCheck\");\n\n    std::cout << \"\\nScenario 2:\" << std::endl;\n    qualityControlApprover.processRequest(\"SupplierQualificationCheck\");\n\n    std::cout << \"\\nScenario 3:\" << std::endl;\n    qualityControlApprover.processRequest(\"MarketingRuleCheck\");\n\n    std::cout << \"\\nScenario 4:\" << std::endl;\n    qualityControlApprover.processRequest(\"SomeOtherCheck\");\n\n    return 0;\n}\n\n```\n\n\n","slug":"Chain-of-responsibility","published":1,"updated":"2024-02-02T06:47:34.090Z","_id":"clrhz6rwf00010ox533q1ciw5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。<br>在设计之初有着足够简单的业务流程：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1</li>\n<li>供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：</p>\n<ol>\n<li>在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。</li>\n<li>对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。</li>\n<li>当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。</li>\n</ol>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。</p>\n<ul>\n<li>在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。</li>\n<li>请求及其数据则会被作为参数传递给该方法。</li>\n</ul>\n<p>责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。</p>\n<ul>\n<li>除了处理请求外，处理者还负责沿着链传递请求。</li>\n<li>请求会在链上移动，直至所有处理者都有机会对请求进行处理。</li>\n</ul>\n<p>最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。<br>还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。</p>\n<ul>\n<li>如果自己能够处理，处理者就不再继续传递请求。</li>\n<li>在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理</li>\n</ul>\n<p>连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。</p>\n<ul>\n<li>对于第二种方式，感觉有些像观察者模式。</li>\n<li>两者具体实现、目的都差不多。主要区别在于：<ul>\n<li>观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可</li>\n<li>责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/design-pattern/1.png\" alt=\"image.png\"><br>责任链模式的核心在于将处理对象整理成链路。</p>\n<h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><ul>\n<li>程序需要使用不同方式处理请求<ul>\n<li>将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。</li>\n</ul>\n</li>\n<li>当必须按顺序执行多个处理者时，可以使用该模式。<ul>\n<li>无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。</li>\n</ul>\n</li>\n<li>如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。<ul>\n<li>如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h1><ol>\n<li>声明处理者接口并提供请求处理方法的签名。<ul>\n<li>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</li>\n</ul>\n</li>\n<li>为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。<ul>\n<li>该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。</li>\n<li>还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。</li>\n</ul>\n</li>\n<li>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：<ul>\n<li>是否自行处理这个请求</li>\n<li>是否将该请求沿着链进行传递</li>\n</ul>\n</li>\n<li>客户端可以自行组装链，或者从其他对象处获得预先组装好的链。<ul>\n<li>在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链</li>\n</ul>\n</li>\n<li>客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。</li>\n<li>由于链的动态性，客户端需要处理以下情况：<ul>\n<li>部分请求可能无法到达链尾</li>\n<li>其他请求可能直到链尾都未被处理</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h1><p>优点：</p>\n<ul>\n<li>可以控制请求处理的顺序。</li>\n<li>单一职责原则。解耦了发起操作和执行操作的类。</li>\n<li>开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>部分请求最终可能都未被处理。</li>\n</ul>\n<h1 id=\"与其它模式的关系\"><a href=\"#与其它模式的关系\" class=\"headerlink\" title=\"与其它模式的关系\"></a>与其它模式的关系</h1><ul>\n<li>责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：<ul>\n<li>责任链模式按照顺序将请求动态传递给一系列的潜在接收者。</li>\n<li>命令模式在发送者和请求者之间建立单向连接。</li>\n<li>中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>\n<li>观察者模式允许接收者动态地订阅或取消接收请求。</li>\n</ul>\n</li>\n<li>责任链可以和组合模式结合使用<ul>\n<li>叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。</li>\n</ul>\n</li>\n<li>责任链上的处理器可使用命令模式实现<ul>\n<li>可以对由请求代表的同一个上下文对象执行许多不同的操作。</li>\n<li>或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。</li>\n</ul>\n</li>\n<li>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同<ul>\n<li>责任链上的处理器可以相互独立地执行，还可以随时停止传递请求</li>\n<li>各种装饰可以在遵循基本接口的情况下扩展对象的行为</li>\n<li>装饰无法中断请求的传递</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义处理者接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Approver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Approver</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建抽象处理者基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseApprover</span> : <span class=\"keyword\">public</span> Approver &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">Approver* nextApprover;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"built_in\">BaseApprover</span>() : <span class=\"built_in\">nextApprover</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置下一个处理者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNextApprover</span><span class=\"params\">(Approver* next)</span> </span>&#123;</span><br><span class=\"line\">    nextApprover = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理请求的默认行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextApprover != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        nextApprover-&gt;<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Request not handled by any approver.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：商品品控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QualityControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;QualityCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;QualityControlApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：供应商资质管理员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SupplierQualificationApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;SupplierQualificationApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：上架风控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RiskControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;MarketingRuleCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;RiskControlApprover handles the request and approves the product for shelf.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建责任链</span></span><br><span class=\"line\">    QualityControlApprover qualityControlApprover;</span><br><span class=\"line\">    SupplierQualificationApprover supplierQualificationApprover;</span><br><span class=\"line\">    RiskControlApprover riskControlApprover;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置责任链顺序</span></span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">setNextApprover</span>(&amp;supplierQualificationApprover);</span><br><span class=\"line\">    supplierQualificationApprover.<span class=\"built_in\">setNextApprover</span>(&amp;riskControlApprover);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟商品上架流程</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Scenario 1:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;QualityCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 2:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 3:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;MarketingRuleCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 4:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SomeOtherCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>责任链模式是一种将请求沿着处理者链依次进行发送的设计模式。系统收到请求后，在链上的每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。每个处理者都作为链上一个可活动的节点，使得责任链模式相较于if-else的分支语句，具有了更好的灵活性和扩展性。</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在商品上架的审批流系统的开发过程中，有着供应商、商品品控人员、上架风控人员等多种角色参与这一流程，并在其中进行着有先后依赖顺序的不同任务。这一流程会与其他系统（角色权限系统、商品库存系统等）具有深度耦合。<br>在设计之初有着足够简单的业务流程：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品品控达标度进行检查，成功进入3，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个业务流程中，因为足够简单，所以可以用简单的if语句完成所有的分支判断。单如果随着业务复杂度的增加，引入新角色，供应商资质管理员，新的流程的分支会变多：</p>\n<ol>\n<li>供应商发起上架流程审批，成功则进入2，不成功重新发起1</li>\n<li>商品品控人员进行商品质量达标度进行检查，成功进入4，部分成功进入3，完全不成功返回1</li>\n<li>供应商资质管理员对供应商的资质进行检查，成功进入4，不成功返回1</li>\n<li>上架风控人员对上架的营销规则进行检查，成功上架，不成功返回1</li>\n</ol>\n<p>在这个流程中，虽然只增加了一个角色和部分简单逻辑，但对原本if语句的冲击是很大的，为了兼容新的角色需要在多处进行改动，于是在迭代的过程中，势必会出现这样一种局面：</p>\n<ol>\n<li>在审批流中的代码本来就已经混乱不堪，之后每次新增功能都会使其更加臃肿。</li>\n<li>对审批流中的某个检查步骤进行修改时会影响其他的检查步骤。</li>\n<li>当希望复用这些审核逻辑来保护其他系统组件时，只需要复制部分逻辑就足够，但会面对所需的部分逻辑与整体审批流耦合得太深而很难剥离出来的问题。</li>\n</ol>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>与许多其他行为设计模式一样，责任链会将特定行为转换为被称作处理者的独立对象。</p>\n<ul>\n<li>在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，提供检查操作。</li>\n<li>请求及其数据则会被作为参数传递给该方法。</li>\n</ul>\n<p>责任链模式将这些处理者连成一条链，链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。</p>\n<ul>\n<li>除了处理请求外，处理者还负责沿着链传递请求。</li>\n<li>请求会在链上移动，直至所有处理者都有机会对请求进行处理。</li>\n</ul>\n<p>最重要的是：处理者可以决定要不要沿着链继续传递请求，这样可以高效地取消所有后续处理步骤。<br>还有一种稍微不同的更经典的方式，处理者接收到请求后自行决定是否能够对其进行处理。</p>\n<ul>\n<li>如果自己能够处理，处理者就不再继续传递请求。</li>\n<li>在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理</li>\n</ul>\n<p>连成链的方式比较多样，可以用UML中展示的那样，一个处理对象使用SetNext()引用下一个处理对象。 也可以使用array或者list存储所有处理对象，使用循环方式遍历。</p>\n<ul>\n<li>对于第二种方式，感觉有些像观察者模式。</li>\n<li>两者具体实现、目的都差不多。主要区别在于：<ul>\n<li>观察者模式中的处理对象功能可能完全无关，观察者模式主要负责将信息传递给处理对象即可</li>\n<li>责任链模式的处理对象功能一般相似，另外责任链模式也关注请求是否正确被处理</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/design-pattern/1.png\" alt=\"image.png\"><br>责任链模式的核心在于将处理对象整理成链路。</p>\n<h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><ul>\n<li>程序需要使用不同方式处理请求<ul>\n<li>将多个处理者连接成一条链。接收到请求后，“询问” 每个处理者是否能对其进行处理。这样所有处理者都有机会来处理请求。</li>\n</ul>\n</li>\n<li>当必须按顺序执行多个处理者时，可以使用该模式。<ul>\n<li>无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。</li>\n</ul>\n</li>\n<li>如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。<ul>\n<li>如果在处理者类中有对引用成员变量的设定方法，能动态地插入和移除处理者，或者改变其顺序。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h1><ol>\n<li>声明处理者接口并提供请求处理方法的签名。<ul>\n<li>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</li>\n</ul>\n</li>\n<li>为了消除具体处理者中的重复代码，可以根据处理者接口创建抽象处理者基类。<ul>\n<li>该类需要有一个成员变量来存储指向链上下一个处理者的引用。如果需要在运行时对链进行改变，需要定义一个设定方法来修改引用成员变量的值。</li>\n<li>还可以提供处理方法的默认行为。如果还有剩余对象，默认行为直接将请求传递给下个对象。具体处理者可以通过调用父对象的方法来使用这一行为。</li>\n</ul>\n</li>\n<li>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：<ul>\n<li>是否自行处理这个请求</li>\n<li>是否将该请求沿着链进行传递</li>\n</ul>\n</li>\n<li>客户端可以自行组装链，或者从其他对象处获得预先组装好的链。<ul>\n<li>在后一种情况下，需要实现工厂类来根据配置或环境设置来创建链</li>\n</ul>\n</li>\n<li>客户端可以触发链中的任一处理者，不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾。</li>\n<li>由于链的动态性，客户端需要处理以下情况：<ul>\n<li>部分请求可能无法到达链尾</li>\n<li>其他请求可能直到链尾都未被处理</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h1><p>优点：</p>\n<ul>\n<li>可以控制请求处理的顺序。</li>\n<li>单一职责原则。解耦了发起操作和执行操作的类。</li>\n<li>开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>部分请求最终可能都未被处理。</li>\n</ul>\n<h1 id=\"与其它模式的关系\"><a href=\"#与其它模式的关系\" class=\"headerlink\" title=\"与其它模式的关系\"></a>与其它模式的关系</h1><ul>\n<li>责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：<ul>\n<li>责任链模式按照顺序将请求动态传递给一系列的潜在接收者。</li>\n<li>命令模式在发送者和请求者之间建立单向连接。</li>\n<li>中介者模式清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>\n<li>观察者模式允许接收者动态地订阅或取消接收请求。</li>\n</ul>\n</li>\n<li>责任链可以和组合模式结合使用<ul>\n<li>叶组件接收到请求后，将请求沿包含全体父组件的链一直传递至对象树的底部。</li>\n</ul>\n</li>\n<li>责任链上的处理器可使用命令模式实现<ul>\n<li>可以对由请求代表的同一个上下文对象执行许多不同的操作。</li>\n<li>或者，请求自身就是一个命令对象。可以对一系列不同对象组成的链执行相同的操作。</li>\n</ul>\n</li>\n<li>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给对象。两者也有几点不同<ul>\n<li>责任链上的处理器可以相互独立地执行，还可以随时停止传递请求</li>\n<li>各种装饰可以在遵循基本接口的情况下扩展对象的行为</li>\n<li>装饰无法中断请求的传递</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义处理者接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Approver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Approver</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建抽象处理者基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseApprover</span> : <span class=\"keyword\">public</span> Approver &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">Approver* nextApprover;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"built_in\">BaseApprover</span>() : <span class=\"built_in\">nextApprover</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置下一个处理者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNextApprover</span><span class=\"params\">(Approver* next)</span> </span>&#123;</span><br><span class=\"line\">    nextApprover = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理请求的默认行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextApprover != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        nextApprover-&gt;<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Request not handled by any approver.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：商品品控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">QualityControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;QualityCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;QualityControlApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：供应商资质管理员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SupplierQualificationApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;SupplierQualificationApprover handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体处理者子类：上架风控人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RiskControlApprover</span> : <span class=\"keyword\">public</span> BaseApprover &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; request)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request == <span class=\"string\">&quot;MarketingRuleCheck&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;RiskControlApprover handles the request and approves the product for shelf.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        BaseApprover::<span class=\"built_in\">processRequest</span>(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建责任链</span></span><br><span class=\"line\">    QualityControlApprover qualityControlApprover;</span><br><span class=\"line\">    SupplierQualificationApprover supplierQualificationApprover;</span><br><span class=\"line\">    RiskControlApprover riskControlApprover;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置责任链顺序</span></span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">setNextApprover</span>(&amp;supplierQualificationApprover);</span><br><span class=\"line\">    supplierQualificationApprover.<span class=\"built_in\">setNextApprover</span>(&amp;riskControlApprover);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟商品上架流程</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Scenario 1:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;QualityCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 2:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SupplierQualificationCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 3:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;MarketingRuleCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\nScenario 4:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    qualityControlApprover.<span class=\"built_in\">processRequest</span>(<span class=\"string\">&quot;SomeOtherCheck&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"迁移计划","date":"2023-12-01T18:45:20.000Z","_content":"\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n\n#### C++语法方面的一些个人笔记\n- ✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）\n- C++ 20以上的新特性\n\n#### 计算机体系结构下的读书笔记\n- 共享内存整理\n- 异步事件框架\n- ~~分布式一致性协议（挪到工作中的问题部分）~~\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n\n#### 探索过的编程模式\n\n- ✔无锁编程（存在一个版本的草稿，但是还需要优化）\n- 并发编程\n- ✔模版编程（存在一个版本的草稿，但是还需要优化）\n- 无分支编程\n- ✔缓存友好编程（存在一个版本的草稿，但是还需要优化）\n- 向量化编程\n\n#### 工作中遇到过的问题\n- linux下的高精度测时问题\n- 超线程导致的效率降低问题\n- grafana大量close_wait拖垮数据库\n- 分布式系统的一致性等级造成的异常\n\n#### 工作中部分项目的总结\n- ~~项目的稳定性治理~~\n- ~~重构项目的技巧与总结~~\n- ✔基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n\n#### 一些常用工具的学习和了解\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","source":"_posts/Todo-plans.md","raw":"---\ntitle: 迁移计划\ndate: 2023-12-02 02:45:20\ntags: 随感杂记\n---\n\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n\n#### C++语法方面的一些个人笔记\n- ✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）\n- C++ 20以上的新特性\n\n#### 计算机体系结构下的读书笔记\n- 共享内存整理\n- 异步事件框架\n- ~~分布式一致性协议（挪到工作中的问题部分）~~\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n\n#### 探索过的编程模式\n\n- ✔无锁编程（存在一个版本的草稿，但是还需要优化）\n- 并发编程\n- ✔模版编程（存在一个版本的草稿，但是还需要优化）\n- 无分支编程\n- ✔缓存友好编程（存在一个版本的草稿，但是还需要优化）\n- 向量化编程\n\n#### 工作中遇到过的问题\n- linux下的高精度测时问题\n- 超线程导致的效率降低问题\n- grafana大量close_wait拖垮数据库\n- 分布式系统的一致性等级造成的异常\n\n#### 工作中部分项目的总结\n- ~~项目的稳定性治理~~\n- ~~重构项目的技巧与总结~~\n- ✔基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n\n#### 一些常用工具的学习和了解\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","slug":"Todo-plans","published":1,"updated":"2024-02-06T01:57:32.441Z","_id":"cls01gnk000001ax57sxn64hc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li><del>分布式一致性协议（挪到工作中的问题部分）</del></li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>✔无锁编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>并发编程</li>\n<li>✔模版编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>无分支编程</li>\n<li>✔缓存友好编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>向量化编程</li>\n</ul>\n<h4 id=\"工作中遇到过的问题\"><a href=\"#工作中遇到过的问题\" class=\"headerlink\" title=\"工作中遇到过的问题\"></a>工作中遇到过的问题</h4><ul>\n<li>linux下的高精度测时问题</li>\n<li>超线程导致的效率降低问题</li>\n<li>grafana大量close_wait拖垮数据库</li>\n<li>分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li><del>项目的稳定性治理</del></li>\n<li><del>重构项目的技巧与总结</del></li>\n<li>✔基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>✔C++的一些基础知识回顾（经过整理觉得太过于浅显，有沦为工具手册的嫌疑，遂放弃）</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li><del>分布式一致性协议（挪到工作中的问题部分）</del></li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>✔无锁编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>并发编程</li>\n<li>✔模版编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>无分支编程</li>\n<li>✔缓存友好编程（存在一个版本的草稿，但是还需要优化）</li>\n<li>向量化编程</li>\n</ul>\n<h4 id=\"工作中遇到过的问题\"><a href=\"#工作中遇到过的问题\" class=\"headerlink\" title=\"工作中遇到过的问题\"></a>工作中遇到过的问题</h4><ul>\n<li>linux下的高精度测时问题</li>\n<li>超线程导致的效率降低问题</li>\n<li>grafana大量close_wait拖垮数据库</li>\n<li>分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li><del>项目的稳定性治理</del></li>\n<li><del>重构项目的技巧与总结</del></li>\n<li>✔基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n"},{"title":"Git多路Merge原理","date":"2024-02-01T11:02:57.000Z","_content":"这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。\n# Git的组成\n## 工作区(workspace)\n就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。\n## 暂存区(index)\n老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。\n## 本地仓库(local repository)\ngit 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。\n## 远程仓库(remote repository)\n中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。\n# 状态模型\n## 状态流转![image.png](/images/git-note/1.png)\n## 文件变化\n![image.png](/images/git-note/2.png)\n# 存储模型\ngit 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。\nSvn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。\nGit 对文件版本的管理理念却是以每次提交为一次快照，提交时对**所有文件**做一次**全量快照**，然后**存储快照引用**。\nGit 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。\n如下图所示：\n![image.png](/images/git-note/3.png)\n# Merge算法\n## Q&A\n\n- Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?\n- A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。\n\n- git merge 只要两行不相同就一定会报冲突，叫人工解决?\n- 答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。\n\n## 合并算法\n### 二路合并\n二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n\n假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。\n### 三路合并\n三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。\n\n- Base 代表上一个版本，即公共祖先\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n- Merge 代表git进行merge后的结果\n#### 自动merge场景\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\nconsole.log(\"World Hello\");\n```\n这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA\n#### 手动merge场景\n需要手动merge的场景就是Mine和Theis都对相同的\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"World Flynn\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\n<<<<<<<Mine\nconsole.log(\"World Flynn\");\n=======\nconsole.log(\"World Hello\");\n>>>>>>>Theirs\n```\n在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。\n#### 三路合并示例\n![image.png](/images/git-note/4.png)\n\n1. 上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。\n2. ①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，**分支本质是一个快照。**\n3. 同样dev分支也是由一个个commit组成\n\n现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用**DAG(有向无环图)**相关算法找到我们**公共的祖先** ②（Base）然后进行**三方合并**，最后合并生成 ⑨\n```java\n//找出公共祖先的commitId(Base)\ngit merge-base --all commit_id1(Yours/Theirs) commit_id2(Yours/Theirs) \n```\n在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。\n![image.png](/images/git-note/5.png)\n### 递归三路合并\n#### 公共祖先不唯一问题\n**抽象化**\n```java\n       ---1---o---A\n           \\ /\n            X\n           / \\\n       ---2---o---o---B\n```\n**具体化**\n![image.png](/images/git-note/6.png)\n> （这部分图有点问题，阅读理解困难，可跳过直接看问题）\n> 简短描述下 如何会出现上面的图：\n> 1. 在master分支上新建文件foo.c ,写入数据\"A\"到文件里面\n> 2. 新建分支task2 **git checkout -b task2 0**,0 代表commit Id\n> 3. 新建并提交commit ① 和 ③\n> 4. 切换分支到master，新建并提交commit ②\n> 5. 新建并修改foo.c文件中数据为\"B\",并提交commit ④\n> 6. merge commit ③ **git merge task2**,生成commit ⑥\n> 7. 新建分支task1 **git chekcout -b ④**\n> 8. 在task1 merge ③ **git merge task2** 生成commit ⑤\n> 9. 新建commit ⑦，并修改foo.c文件内容为\"C\"\n> 10. 切换分支到master上，并准备merge task1 分支(merge ⑦-> ⑥)\n\n\n我们如果要合并 ⑦(source) -> ⑥(destination)\n会发现有⑥和⑦有两个最佳公共祖先③和④\n以③为公共祖先时需要手动解决冲突 /foo.c = BC???\n![image.png](/images/git-note/7.png)\n以④作为公共祖先将得到 /foo.c=C\n![image.png](/images/git-note/8.png)\n#### git解法\ngit 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X /foo.c = B。因为③ 和 ④ 公共祖先是 0/foo.c = A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X /foo.c = B。\n![image.png](/images/git-note/9.png)\n","source":"_posts/Git-note.md","raw":"---\ntitle: Git多路Merge原理\ndate: 2024-02-01 19:02:57\ntags: 随感杂记\n---\n这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。\n# Git的组成\n## 工作区(workspace)\n就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。\n## 暂存区(index)\n老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。\n## 本地仓库(local repository)\ngit 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。\n## 远程仓库(remote repository)\n中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。\n# 状态模型\n## 状态流转![image.png](/images/git-note/1.png)\n## 文件变化\n![image.png](/images/git-note/2.png)\n# 存储模型\ngit 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。\nSvn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。\nGit 对文件版本的管理理念却是以每次提交为一次快照，提交时对**所有文件**做一次**全量快照**，然后**存储快照引用**。\nGit 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。\n如下图所示：\n![image.png](/images/git-note/3.png)\n# Merge算法\n## Q&A\n\n- Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?\n- A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。\n\n- git merge 只要两行不相同就一定会报冲突，叫人工解决?\n- 答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。\n\n## 合并算法\n### 二路合并\n二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n\n假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。\n### 三路合并\n三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。\n\n- Base 代表上一个版本，即公共祖先\n- Mine 代表你本地修改\n- Theirs 代表其他人修改\n- Merge 代表git进行merge后的结果\n#### 自动merge场景\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"Hello World\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\nconsole.log(\"World Hello\");\n```\n这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA\n#### 手动merge场景\n需要手动merge的场景就是Mine和Theis都对相同的\n```cpp\n//Base\nconsole.log(\"Hello World\");\n```\n```cpp\n//Mine\nconsole.log(\"World Flynn\");\n```\n```cpp\n//Theirs\nconsole.log(\"World Hello\");\n```\n```cpp\n//Merge\n<<<<<<<Mine\nconsole.log(\"World Flynn\");\n=======\nconsole.log(\"World Hello\");\n>>>>>>>Theirs\n```\n在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。\n#### 三路合并示例\n![image.png](/images/git-note/4.png)\n\n1. 上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。\n2. ①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，**分支本质是一个快照。**\n3. 同样dev分支也是由一个个commit组成\n\n现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用**DAG(有向无环图)**相关算法找到我们**公共的祖先** ②（Base）然后进行**三方合并**，最后合并生成 ⑨\n```java\n//找出公共祖先的commitId(Base)\ngit merge-base --all commit_id1(Yours/Theirs) commit_id2(Yours/Theirs) \n```\n在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。\n![image.png](/images/git-note/5.png)\n### 递归三路合并\n#### 公共祖先不唯一问题\n**抽象化**\n```java\n       ---1---o---A\n           \\ /\n            X\n           / \\\n       ---2---o---o---B\n```\n**具体化**\n![image.png](/images/git-note/6.png)\n> （这部分图有点问题，阅读理解困难，可跳过直接看问题）\n> 简短描述下 如何会出现上面的图：\n> 1. 在master分支上新建文件foo.c ,写入数据\"A\"到文件里面\n> 2. 新建分支task2 **git checkout -b task2 0**,0 代表commit Id\n> 3. 新建并提交commit ① 和 ③\n> 4. 切换分支到master，新建并提交commit ②\n> 5. 新建并修改foo.c文件中数据为\"B\",并提交commit ④\n> 6. merge commit ③ **git merge task2**,生成commit ⑥\n> 7. 新建分支task1 **git chekcout -b ④**\n> 8. 在task1 merge ③ **git merge task2** 生成commit ⑤\n> 9. 新建commit ⑦，并修改foo.c文件内容为\"C\"\n> 10. 切换分支到master上，并准备merge task1 分支(merge ⑦-> ⑥)\n\n\n我们如果要合并 ⑦(source) -> ⑥(destination)\n会发现有⑥和⑦有两个最佳公共祖先③和④\n以③为公共祖先时需要手动解决冲突 /foo.c = BC???\n![image.png](/images/git-note/7.png)\n以④作为公共祖先将得到 /foo.c=C\n![image.png](/images/git-note/8.png)\n#### git解法\ngit 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X /foo.c = B。因为③ 和 ④ 公共祖先是 0/foo.c = A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X /foo.c = B。\n![image.png](/images/git-note/9.png)\n","slug":"Git-note","published":1,"updated":"2024-02-13T07:20:14.275Z","_id":"cls34916b0000ynx57dh67tl8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。</p>\n<h1 id=\"Git的组成\"><a href=\"#Git的组成\" class=\"headerlink\" title=\"Git的组成\"></a>Git的组成</h1><h2 id=\"工作区-workspace\"><a href=\"#工作区-workspace\" class=\"headerlink\" title=\"工作区(workspace)\"></a>工作区(workspace)</h2><p>就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。</p>\n<h2 id=\"暂存区-index\"><a href=\"#暂存区-index\" class=\"headerlink\" title=\"暂存区(index)\"></a>暂存区(index)</h2><p>老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。</p>\n<h2 id=\"本地仓库-local-repository\"><a href=\"#本地仓库-local-repository\" class=\"headerlink\" title=\"本地仓库(local repository)\"></a>本地仓库(local repository)</h2><p>git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p>\n<h2 id=\"远程仓库-remote-repository\"><a href=\"#远程仓库-remote-repository\" class=\"headerlink\" title=\"远程仓库(remote repository)\"></a>远程仓库(remote repository)</h2><p>中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p>\n<h1 id=\"状态模型\"><a href=\"#状态模型\" class=\"headerlink\" title=\"状态模型\"></a>状态模型</h1><h2 id=\"状态流转\"><a href=\"#状态流转\" class=\"headerlink\" title=\"状态流转\"></a>状态流转<img src=\"/images/git-note/1.png\" alt=\"image.png\"></h2><h2 id=\"文件变化\"><a href=\"#文件变化\" class=\"headerlink\" title=\"文件变化\"></a>文件变化</h2><p><img src=\"/images/git-note/2.png\" alt=\"image.png\"></p>\n<h1 id=\"存储模型\"><a href=\"#存储模型\" class=\"headerlink\" title=\"存储模型\"></a>存储模型</h1><p>git 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。<br>Svn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。<br>Git 对文件版本的管理理念却是以每次提交为一次快照，提交时对<strong>所有文件</strong>做一次<strong>全量快照</strong>，然后<strong>存储快照引用</strong>。<br>Git 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。<br>如下图所示：<br><img src=\"/images/git-note/3.png\" alt=\"image.png\"></p>\n<h1 id=\"Merge算法\"><a href=\"#Merge算法\" class=\"headerlink\" title=\"Merge算法\"></a>Merge算法</h1><h2 id=\"Q-A\"><a href=\"#Q-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li><p>Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?</p>\n</li>\n<li><p>A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。</p>\n</li>\n<li><p>git merge 只要两行不相同就一定会报冲突，叫人工解决?</p>\n</li>\n<li><p>答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。</p>\n</li>\n</ul>\n<h2 id=\"合并算法\"><a href=\"#合并算法\" class=\"headerlink\" title=\"合并算法\"></a>合并算法</h2><h3 id=\"二路合并\"><a href=\"#二路合并\" class=\"headerlink\" title=\"二路合并\"></a>二路合并</h3><p>二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n</ul>\n<p>假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。</p>\n<h3 id=\"三路合并\"><a href=\"#三路合并\" class=\"headerlink\" title=\"三路合并\"></a>三路合并</h3><p>三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。</p>\n<ul>\n<li>Base 代表上一个版本，即公共祖先</li>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n<li>Merge 代表git进行merge后的结果</li>\n</ul>\n<h4 id=\"自动merge场景\"><a href=\"#自动merge场景\" class=\"headerlink\" title=\"自动merge场景\"></a>自动merge场景</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA</p>\n<h4 id=\"手动merge场景\"><a href=\"#手动merge场景\" class=\"headerlink\" title=\"手动merge场景\"></a>手动merge场景</h4><p>需要手动merge的场景就是Mine和Theis都对相同的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;Mine</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br><span class=\"line\">=======</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;Theirs</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。</p>\n<h4 id=\"三路合并示例\"><a href=\"#三路合并示例\" class=\"headerlink\" title=\"三路合并示例\"></a>三路合并示例</h4><p><img src=\"/images/git-note/4.png\" alt=\"image.png\"></p>\n<ol>\n<li>上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。</li>\n<li>①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，<strong>分支本质是一个快照。</strong></li>\n<li>同样dev分支也是由一个个commit组成</li>\n</ol>\n<p>现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用<strong>DAG(有向无环图)<strong>相关算法找到我们</strong>公共的祖先</strong> ②（Base）然后进行<strong>三方合并</strong>，最后合并生成 ⑨</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找出公共祖先的commitId(Base)</span></span><br><span class=\"line\">git merge-base --all <span class=\"title function_\">commit_id1</span><span class=\"params\">(Yours/Theirs)</span> commit_id2(Yours/Theirs) </span><br></pre></td></tr></table></figure>\n<p>在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。<br><img src=\"/images/git-note/5.png\" alt=\"image.png\"></p>\n<h3 id=\"递归三路合并\"><a href=\"#递归三路合并\" class=\"headerlink\" title=\"递归三路合并\"></a>递归三路合并</h3><h4 id=\"公共祖先不唯一问题\"><a href=\"#公共祖先不唯一问题\" class=\"headerlink\" title=\"公共祖先不唯一问题\"></a>公共祖先不唯一问题</h4><p><strong>抽象化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---<span class=\"number\">1</span>---o---A</span><br><span class=\"line\">    \\ /</span><br><span class=\"line\">     X</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">---<span class=\"number\">2</span>---o---o---B</span><br></pre></td></tr></table></figure>\n<p><strong>具体化</strong><br><img src=\"/images/git-note/6.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>（这部分图有点问题，阅读理解困难，可跳过直接看问题）<br>简短描述下 如何会出现上面的图：</p>\n<ol>\n<li>在master分支上新建文件foo.c ,写入数据”A”到文件里面</li>\n<li>新建分支task2 <strong>git checkout -b task2 0</strong>,0 代表commit Id</li>\n<li>新建并提交commit ① 和 ③</li>\n<li>切换分支到master，新建并提交commit ②</li>\n<li>新建并修改foo.c文件中数据为”B”,并提交commit ④</li>\n<li>merge commit ③ <strong>git merge task2</strong>,生成commit ⑥</li>\n<li>新建分支task1 <strong>git chekcout -b ④</strong></li>\n<li>在task1 merge ③ <strong>git merge task2</strong> 生成commit ⑤</li>\n<li>新建commit ⑦，并修改foo.c文件内容为”C”</li>\n<li>切换分支到master上，并准备merge task1 分支(merge ⑦-&gt; ⑥)</li>\n</ol>\n</blockquote>\n<p>我们如果要合并 ⑦(source) -&gt; ⑥(destination)<br>会发现有⑥和⑦有两个最佳公共祖先③和④<br>以③为公共祖先时需要手动解决冲突 &#x2F;foo.c &#x3D; BC???<br><img src=\"/images/git-note/7.png\" alt=\"image.png\"><br>以④作为公共祖先将得到 &#x2F;foo.c&#x3D;C<br><img src=\"/images/git-note/8.png\" alt=\"image.png\"></p>\n<h4 id=\"git解法\"><a href=\"#git解法\" class=\"headerlink\" title=\"git解法\"></a>git解法</h4><p>git 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X &#x2F;foo.c &#x3D; B。因为③ 和 ④ 公共祖先是 0&#x2F;foo.c &#x3D; A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X &#x2F;foo.c &#x3D; B。<br><img src=\"/images/git-note/9.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇笔记是对git使用中自动merge算法的好奇，查找了一些资料，简单做了个总结，留以存档。</p>\n<h1 id=\"Git的组成\"><a href=\"#Git的组成\" class=\"headerlink\" title=\"Git的组成\"></a>Git的组成</h1><h2 id=\"工作区-workspace\"><a href=\"#工作区-workspace\" class=\"headerlink\" title=\"工作区(workspace)\"></a>工作区(workspace)</h2><p>就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间clean的时候，文件内容和index暂存区是一致的，随着修改，工作区文件在没有add到暂存区时候，工作区将和暂存区是不一致的。</p>\n<h2 id=\"暂存区-index\"><a href=\"#暂存区-index\" class=\"headerlink\" title=\"暂存区(index)\"></a>暂存区(index)</h2><p>老版本概念也叫Cache区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个commit一起提交到local repository 此时 local repository里面文件将完全被暂存区所取代。暂存区是git架构设计中非常重要和难理解的一部分。后续会有专门的文章研究暂存区。</p>\n<h2 id=\"本地仓库-local-repository\"><a href=\"#本地仓库-local-repository\" class=\"headerlink\" title=\"本地仓库(local repository)\"></a>本地仓库(local repository)</h2><p>git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器(remote server)进行通信，在本地即可进行全部离线操作，包括log，history，commit，diff等等。 完成离线操作最核心是因为git有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p>\n<h2 id=\"远程仓库-remote-repository\"><a href=\"#远程仓库-remote-repository\" class=\"headerlink\" title=\"远程仓库(remote repository)\"></a>远程仓库(remote repository)</h2><p>中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p>\n<h1 id=\"状态模型\"><a href=\"#状态模型\" class=\"headerlink\" title=\"状态模型\"></a>状态模型</h1><h2 id=\"状态流转\"><a href=\"#状态流转\" class=\"headerlink\" title=\"状态流转\"></a>状态流转<img src=\"/images/git-note/1.png\" alt=\"image.png\"></h2><h2 id=\"文件变化\"><a href=\"#文件变化\" class=\"headerlink\" title=\"文件变化\"></a>文件变化</h2><p><img src=\"/images/git-note/2.png\" alt=\"image.png\"></p>\n<h1 id=\"存储模型\"><a href=\"#存储模型\" class=\"headerlink\" title=\"存储模型\"></a>存储模型</h1><p>git 区别与其他 vcs 系统的一个最主要原因之一是：git 对文件版本管理和其他vcs系统对文件版本的实现理念完成不一样。这也就是git 版本管理为什么如此强大的最核心的地方。<br>Svn 等其他的VCS对文件版本的理念是以文件为水平维度，记录每个文件在每个版本下的delta改变。<br>Git 对文件版本的管理理念却是以每次提交为一次快照，提交时对<strong>所有文件</strong>做一次<strong>全量快照</strong>，然后<strong>存储快照引用</strong>。<br>Git 在存储层，如果文件数据没有改变的文件，Git只是存储指向源文件的一个引用，并不会直接多次存储文件，这一点可以在pack 文件中看见。<br>如下图所示：<br><img src=\"/images/git-note/3.png\" alt=\"image.png\"></p>\n<h1 id=\"Merge算法\"><a href=\"#Merge算法\" class=\"headerlink\" title=\"Merge算法\"></a>Merge算法</h1><h2 id=\"Q-A\"><a href=\"#Q-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li><p>Q: git merge 是用时间先后决定merge结果的，后面会覆盖前面的?</p>\n</li>\n<li><p>A: git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠三路合并算法进行合并的。</p>\n</li>\n<li><p>git merge 只要两行不相同就一定会报冲突，叫人工解决?</p>\n</li>\n<li><p>答：git 尽管两行内容不一样，smart git 会进行取舍，当git无法进行取舍的时候才会进行人工解决冲突。</p>\n</li>\n</ul>\n<h2 id=\"合并算法\"><a href=\"#合并算法\" class=\"headerlink\" title=\"合并算法\"></a>合并算法</h2><h3 id=\"二路合并\"><a href=\"#二路合并\" class=\"headerlink\" title=\"二路合并\"></a>二路合并</h3><p>二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n</ul>\n<p>假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) ，无理无据，git只能让你自己搞了，但是这种情况太多了而且其实也没有必要。</p>\n<h3 id=\"三路合并\"><a href=\"#三路合并\" class=\"headerlink\" title=\"三路合并\"></a>三路合并</h3><p>三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。</p>\n<ul>\n<li>Base 代表上一个版本，即公共祖先</li>\n<li>Mine 代表你本地修改</li>\n<li>Theirs 代表其他人修改</li>\n<li>Merge 代表git进行merge后的结果</li>\n</ul>\n<h4 id=\"自动merge场景\"><a href=\"#自动merge场景\" class=\"headerlink\" title=\"自动merge场景\"></a>自动merge场景</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下，这个结构也是大多merge工具的常见布局，比如IDEA</p>\n<h4 id=\"手动merge场景\"><a href=\"#手动merge场景\" class=\"headerlink\" title=\"手动merge场景\"></a>手动merge场景</h4><p>需要手动merge的场景就是Mine和Theis都对相同的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Base</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Mine</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Theirs</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Merge</span></span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;Mine</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Flynn&quot;</span>);</span><br><span class=\"line\">=======</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">&quot;World Hello&quot;</span>);</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;Theirs</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，Mine和Theirs都对分支进行了修改，git重新遇到了二路合并的问题，需要手动解决冲突。</p>\n<h4 id=\"三路合并示例\"><a href=\"#三路合并示例\" class=\"headerlink\" title=\"三路合并示例\"></a>三路合并示例</h4><p><img src=\"/images/git-note/4.png\" alt=\"image.png\"></p>\n<ol>\n<li>上面①~⑨代表一个个修改集合(commit)，每个commit都有一个唯一7位SHA-1唯一表示。</li>\n<li>①，②，④，⑦修改集串联起来就是一个链，此时用master指向这个集合就代表master分支，<strong>分支本质是一个快照。</strong></li>\n<li>同样dev分支也是由一个个commit组成</li>\n</ol>\n<p>现在在dev分支上由于各种原因要运行git merge master需要把master分支的更新合并到dev分支上，本质上就是合并修改集 ⑦(Mine) 和 ⑧(Theirs) ，此时我们要利用<strong>DAG(有向无环图)<strong>相关算法找到我们</strong>公共的祖先</strong> ②（Base）然后进行<strong>三方合并</strong>，最后合并生成 ⑨</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找出公共祖先的commitId(Base)</span></span><br><span class=\"line\">git merge-base --all <span class=\"title function_\">commit_id1</span><span class=\"params\">(Yours/Theirs)</span> commit_id2(Yours/Theirs) </span><br></pre></td></tr></table></figure>\n<p>在实际开发环境中，分支的Graph更为复杂，但基本的算法原理不变。<br><img src=\"/images/git-note/5.png\" alt=\"image.png\"></p>\n<h3 id=\"递归三路合并\"><a href=\"#递归三路合并\" class=\"headerlink\" title=\"递归三路合并\"></a>递归三路合并</h3><h4 id=\"公共祖先不唯一问题\"><a href=\"#公共祖先不唯一问题\" class=\"headerlink\" title=\"公共祖先不唯一问题\"></a>公共祖先不唯一问题</h4><p><strong>抽象化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---<span class=\"number\">1</span>---o---A</span><br><span class=\"line\">    \\ /</span><br><span class=\"line\">     X</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">---<span class=\"number\">2</span>---o---o---B</span><br></pre></td></tr></table></figure>\n<p><strong>具体化</strong><br><img src=\"/images/git-note/6.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>（这部分图有点问题，阅读理解困难，可跳过直接看问题）<br>简短描述下 如何会出现上面的图：</p>\n<ol>\n<li>在master分支上新建文件foo.c ,写入数据”A”到文件里面</li>\n<li>新建分支task2 <strong>git checkout -b task2 0</strong>,0 代表commit Id</li>\n<li>新建并提交commit ① 和 ③</li>\n<li>切换分支到master，新建并提交commit ②</li>\n<li>新建并修改foo.c文件中数据为”B”,并提交commit ④</li>\n<li>merge commit ③ <strong>git merge task2</strong>,生成commit ⑥</li>\n<li>新建分支task1 <strong>git chekcout -b ④</strong></li>\n<li>在task1 merge ③ <strong>git merge task2</strong> 生成commit ⑤</li>\n<li>新建commit ⑦，并修改foo.c文件内容为”C”</li>\n<li>切换分支到master上，并准备merge task1 分支(merge ⑦-&gt; ⑥)</li>\n</ol>\n</blockquote>\n<p>我们如果要合并 ⑦(source) -&gt; ⑥(destination)<br>会发现有⑥和⑦有两个最佳公共祖先③和④<br>以③为公共祖先时需要手动解决冲突 &#x2F;foo.c &#x3D; BC???<br><img src=\"/images/git-note/7.png\" alt=\"image.png\"><br>以④作为公共祖先将得到 &#x2F;foo.c&#x3D;C<br><img src=\"/images/git-note/8.png\" alt=\"image.png\"></p>\n<h4 id=\"git解法\"><a href=\"#git解法\" class=\"headerlink\" title=\"git解法\"></a>git解法</h4><p>git 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X &#x2F;foo.c &#x3D; B。因为③ 和 ④ 公共祖先是 0&#x2F;foo.c &#x3D; A，根据③和④以及他们的公共祖先进行递归三路归并进行合成的到虚拟的 X &#x2F;foo.c &#x3D; B。<br><img src=\"/images/git-note/9.png\" alt=\"image.png\"></p>\n"},{"title":"如何重构一个项目","date":"2024-02-01T16:14:01.000Z","_content":"任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。\n# 什么是重构\n> 重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。\n\n\n根据重构的规模程度、时间长短，我们可以将代码重构分为**小型重构**和**大型重构**。\n\n**小型重构**：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。\n\n**大型重构**：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行**服务分层、业务模块化、组件化、代码抽象复用**等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。\n\n其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：\n\n- 不知道怎么重构、缺乏重构的经验和方法论。\n- 很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。\n- 重构可能会破坏现有程序，带来意想不到的bug。\n- 重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。\n\n# 为什么要重构\n程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： \n\n- **让软件架构始终保持良好的设计。**改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。\n- **增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。**无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。\n- **提高研发速度、缩短人力成本。**大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。\n\n![image.png](/images/refactor-project/1.png)\n# 怎么进行重构\n## 小型重构\n小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。\n### 业务语义显性化\n优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。\n如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。\n**原代码**\n```java\nif(!PvgContext.getCrmUserId().equals(NIL_VALUE) && icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)\n {\n     //业务逻辑        \n }\n```\n**重构后**\n```java\nif(canPickUpToPrivateSea())\n {\n     //业务逻辑        \n }\n\n //判断客户能否捡私入海\n private boolean canPickUpToPrivateSea(){\n     if(StringUtil.isBlank(PvgContext.getCrmUserId())){\n         return false;\n     }\n     if(this.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP){\n         return false;\n     }\n     return true;\n }\n```\n### 泛型问题\n```java\n//为了大家理解方便，增加了一些注释\n\n//msg是从MQ消费到消息\nMap ps = JSON.parseObject(msg); //\nString mobile = \"xxx\"；\nps.put(\"driverNumber\", mobile);\n……\n// 对ps进行操作\nSet<String> keySet = (Set<String>)ps.keySet();\nif (keySet.contains(\"driverPrice\") && ps.get(\"driverPrice\") != null) {\n\tObject factPrice = ps.get(\"driverPrice\");\n  if (factPrice instanceof BigDecimal) { 【1】\n  \tps.put(\"driverPrice\", String.format(\"%.2f\",((BigDecimal)factPrice).doubleValue()));\n  } else if (factPrice instanceof String) { 【2】\n  \tBigDecimal refund = new BigDecimal((String)factPrice);\n    ps.put(\"refundPrice\", refund.stripTrailingZeros().toPlainString());\n  }\n}\nif (keySet.contains(ORDER_TIP_PRICE) && ps.get(ORDER_TIP_PRICE) != null) {\n\tif (ps.get(ORDER_TIP_PRICE) instanceof BigDecimal) { 【3】\n  \tBigDecimal tipPrice = (BigDecimal)ps.get(ORDER_TIP_PRICE);\n    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));\n  }\n}\n……\n// 将ps作为传输传递给服务内部底层接口\nmsgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);\n\n//看一下底层接口定义\nvoid innerOrderTempMessage(String msg, Map<String, String> ps, PushOrderTotalVO vo);\n```\n这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map<String, String>限定的接口中就是有很大的问题的，未来底层接口使用String value = ps.get(XXX)获取一个非String类型时就会出现类型转换异常。\n### 无病呻吟\n```java\nConfig config = new Config();\n// 设置name和md5\nconfig.setName(item.getName());\nconfig.setMd5(item.getMd5());\n// 设置值\nconfig.setTypeMap(map);\n// 打印日志\nLOGGER.info(\"update done ({},{}), start replace\", getName(), getMd5());\n\n\n......\n\nExpiredConfig expireConfig = ConfigManager.getExpiredConfig();\n// 为空初始化\nif (Objects.isNull(expireConfig)) {\n  expireConfig = new ExpiredConfig();\n}\n\n......\nMap<String, List<TypeItem>> typeMap = ……;   \nMap<String, Map<String, Map<String, List<Map<String, Object>>>>> jsonMap = new HashMap<>();\n\n// 循环一级map\njsonMap.forEach((k1, v1) -> {\n    // 循环里面的二级map\n    v1.forEach((k2, v2) -> {\n        // 循环里面的三级map\n        v2.forEach((k3, v3) -> {\n            // 循环最里面的list,哎！\n            v3.forEach(e -> {\n                // 生成key\n                String ck = getKey(k1, k2, k3);\n                // 为空处理\n                List<TypeItem> types = typeMap.get(ck);\n                if (CollectionUtils.isEmpty(types)) {\n                    types = new ArrayList<>();\n                    typeMap.put(ck, types);\n                }\n                // 设置类型\n            }\n       }\n  }\n}\n```\n代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。\n### if-else过多\n```java\n// 下面截取的get25000OrderState的部分代码\nprivate static List<String> get25000OrderState(OrderTotalVO orderTotalVO) {\n    String mainState = String.valueOf(orderTotalVO.getOrderState());\n    String state = String.valueOf(orderTotalVO.getOrderState());\n    List<String> stateList = Lists.newArrayList();\n\n    ……\n\n    DispatchType dispatchType = DispatchType.getEnum(orderTotalVO.getDispatchType());\n    ServiceType serviceType = ServiceType.typeOf(orderTotalVO.getServiceType());\n    if (serviceType == ServiceType.CHARTERED_CAR) {\n        state = state + \"_\" + serviceType;\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = state + \"_dispatch\";\n        } else if(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties())){\t\tstate = state + \"_\" + dispatchType.getCode() + \"_phoneCall\";                                                                                   } else {\n            state = state + \"_\" + dispatchType.getCode() + \"_\" + pastOrderId;\n            if(isHighQuality(orderTotalVO.getHighQualityFlag()) && DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode()){\n                state += \"_highQuality\";\n            }\n        }\n    }\n    stateList.add(state);\n    if (isOtherPassengerOrder(orderTotalVO)) {\n        state = mainState + \"_\" + \"forOther_aly\";\n        stateList.add(state);\n    }\n    BigDecimal tickOtherPrice = orderTotalVO.getTicketOtherPrice();\n    if (tickOtherPrice != null && BigDecimal.ZERO.compareTo(tickOtherPrice) < 0) {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketOtherPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketOtherPrice\";\n        }\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketPrice\";\n        }\n    }\n    stateList.add(state);\n\t……\n    return stateList;\n}\n```\n这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。\n\n### 重复代码\n代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。\n\n最常见的一种重复场景就是在“**同一个类的两个函数含有相同的表达式**”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。\n还有一种和这类场景相似，就是在“**两个互为兄弟的子类含有相同的表达式**”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。\n\n### 单一功能职责\n```java\n@Data\npublic class BuyerInfoParam {\n    // Required Param\n    private Long buyerCompanyId;\n    private Long buyerAccountId;\n    private Long callerCompanyId;\n    private Long callerAccountId;\n\n    private String tenantId;\n    private String bizCode;\n    private String channel; //这个Channel在查询中不起任何作用，不应该放在这里\n}\n```\n功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。\n可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。\n那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。\nTips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。\n### 其他问题\n#### 函数过长\n一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。\n#### 命名规范\n一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。\n#### 不合理的注释\n注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。\n#### 无用代码\n无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。\n#### 过大的类\n一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。\n\n## 大型重构\n![image.png](/images/refactor-project/2.png)\n### 事前准备\n事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。\n在这个阶段大致可分为三步：\n\n- **明确重构的内容、目的以及方向、目标**\n\n在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。\n\n- **整理数据**\n\n这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。\n附上整个系统的架构和此次重点重构的部分（深色标记部分）\n![image.png](/images/refactor-project/3.png)\n\n- **项目立项**\n\n项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。\n注意：会议结束后需要进行会议纪要邮件周知。\n### 事中执行\n事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。\n\n- **架构设计与评审**\n\n架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。\n该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。\n\n- **详细落地设计方案与评审**\n\n这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。\n在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：\n![image.png](/images/refactor-project/4.png)\n在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。\n在AB程序中，会涉及到两个开关。**灰度开关**（只有它开启了，请求才会被发送到新的流程中进行代码执行）。**执行开关**（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。\n\n- **代码的编写、测试、线下实施**\n\n这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。\n### \n### 事后观测与复盘\n这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。\n\n- **灰度开关流程**\n\n逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。\n\n- **业务执行开关流程**\n\n在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。\n放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。\n\n# 总结\n## 代码技巧\n\n- 写代码的时候遵循一些基本原则，比如单一原则、依赖接口/抽象而不是依赖具体实现。\n- 严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。\n- 单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。\n- 我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。\n- 不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。\n## 重构技巧\n\n- 从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。\n- 提炼类，复用函数，下沉核心能力，让模块职责清晰明了。\n- 依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。\n- 类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。\n- 大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。\n\n代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：\n1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力\n2、代码洁癖、工匠精神\n3、产品思维\n\n","source":"_posts/Refactor-project.md","raw":"---\ntitle: 如何重构一个项目\ndate: 2024-02-02 00:14:01\ntags: 随感杂记\n---\n任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。\n# 什么是重构\n> 重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。\n\n\n根据重构的规模程度、时间长短，我们可以将代码重构分为**小型重构**和**大型重构**。\n\n**小型重构**：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。\n\n**大型重构**：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行**服务分层、业务模块化、组件化、代码抽象复用**等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。\n\n其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：\n\n- 不知道怎么重构、缺乏重构的经验和方法论。\n- 很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。\n- 重构可能会破坏现有程序，带来意想不到的bug。\n- 重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。\n\n# 为什么要重构\n程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： \n\n- **让软件架构始终保持良好的设计。**改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。\n- **增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。**无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。\n- **提高研发速度、缩短人力成本。**大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。\n\n![image.png](/images/refactor-project/1.png)\n# 怎么进行重构\n## 小型重构\n小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。\n### 业务语义显性化\n优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。\n如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。\n**原代码**\n```java\nif(!PvgContext.getCrmUserId().equals(NIL_VALUE) && icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)\n {\n     //业务逻辑        \n }\n```\n**重构后**\n```java\nif(canPickUpToPrivateSea())\n {\n     //业务逻辑        \n }\n\n //判断客户能否捡私入海\n private boolean canPickUpToPrivateSea(){\n     if(StringUtil.isBlank(PvgContext.getCrmUserId())){\n         return false;\n     }\n     if(this.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP){\n         return false;\n     }\n     return true;\n }\n```\n### 泛型问题\n```java\n//为了大家理解方便，增加了一些注释\n\n//msg是从MQ消费到消息\nMap ps = JSON.parseObject(msg); //\nString mobile = \"xxx\"；\nps.put(\"driverNumber\", mobile);\n……\n// 对ps进行操作\nSet<String> keySet = (Set<String>)ps.keySet();\nif (keySet.contains(\"driverPrice\") && ps.get(\"driverPrice\") != null) {\n\tObject factPrice = ps.get(\"driverPrice\");\n  if (factPrice instanceof BigDecimal) { 【1】\n  \tps.put(\"driverPrice\", String.format(\"%.2f\",((BigDecimal)factPrice).doubleValue()));\n  } else if (factPrice instanceof String) { 【2】\n  \tBigDecimal refund = new BigDecimal((String)factPrice);\n    ps.put(\"refundPrice\", refund.stripTrailingZeros().toPlainString());\n  }\n}\nif (keySet.contains(ORDER_TIP_PRICE) && ps.get(ORDER_TIP_PRICE) != null) {\n\tif (ps.get(ORDER_TIP_PRICE) instanceof BigDecimal) { 【3】\n  \tBigDecimal tipPrice = (BigDecimal)ps.get(ORDER_TIP_PRICE);\n    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));\n  }\n}\n……\n// 将ps作为传输传递给服务内部底层接口\nmsgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);\n\n//看一下底层接口定义\nvoid innerOrderTempMessage(String msg, Map<String, String> ps, PushOrderTotalVO vo);\n```\n这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map<String, String>限定的接口中就是有很大的问题的，未来底层接口使用String value = ps.get(XXX)获取一个非String类型时就会出现类型转换异常。\n### 无病呻吟\n```java\nConfig config = new Config();\n// 设置name和md5\nconfig.setName(item.getName());\nconfig.setMd5(item.getMd5());\n// 设置值\nconfig.setTypeMap(map);\n// 打印日志\nLOGGER.info(\"update done ({},{}), start replace\", getName(), getMd5());\n\n\n......\n\nExpiredConfig expireConfig = ConfigManager.getExpiredConfig();\n// 为空初始化\nif (Objects.isNull(expireConfig)) {\n  expireConfig = new ExpiredConfig();\n}\n\n......\nMap<String, List<TypeItem>> typeMap = ……;   \nMap<String, Map<String, Map<String, List<Map<String, Object>>>>> jsonMap = new HashMap<>();\n\n// 循环一级map\njsonMap.forEach((k1, v1) -> {\n    // 循环里面的二级map\n    v1.forEach((k2, v2) -> {\n        // 循环里面的三级map\n        v2.forEach((k3, v3) -> {\n            // 循环最里面的list,哎！\n            v3.forEach(e -> {\n                // 生成key\n                String ck = getKey(k1, k2, k3);\n                // 为空处理\n                List<TypeItem> types = typeMap.get(ck);\n                if (CollectionUtils.isEmpty(types)) {\n                    types = new ArrayList<>();\n                    typeMap.put(ck, types);\n                }\n                // 设置类型\n            }\n       }\n  }\n}\n```\n代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。\n### if-else过多\n```java\n// 下面截取的get25000OrderState的部分代码\nprivate static List<String> get25000OrderState(OrderTotalVO orderTotalVO) {\n    String mainState = String.valueOf(orderTotalVO.getOrderState());\n    String state = String.valueOf(orderTotalVO.getOrderState());\n    List<String> stateList = Lists.newArrayList();\n\n    ……\n\n    DispatchType dispatchType = DispatchType.getEnum(orderTotalVO.getDispatchType());\n    ServiceType serviceType = ServiceType.typeOf(orderTotalVO.getServiceType());\n    if (serviceType == ServiceType.CHARTERED_CAR) {\n        state = state + \"_\" + serviceType;\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = state + \"_dispatch\";\n        } else if(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties())){\t\tstate = state + \"_\" + dispatchType.getCode() + \"_phoneCall\";                                                                                   } else {\n            state = state + \"_\" + dispatchType.getCode() + \"_\" + pastOrderId;\n            if(isHighQuality(orderTotalVO.getHighQualityFlag()) && DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode()){\n                state += \"_highQuality\";\n            }\n        }\n    }\n    stateList.add(state);\n    if (isOtherPassengerOrder(orderTotalVO)) {\n        state = mainState + \"_\" + \"forOther_aly\";\n        stateList.add(state);\n    }\n    BigDecimal tickOtherPrice = orderTotalVO.getTicketOtherPrice();\n    if (tickOtherPrice != null && BigDecimal.ZERO.compareTo(tickOtherPrice) < 0) {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketOtherPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketOtherPrice\";\n        }\n    } else {\n        if (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) {\n            state = mainState + \"_\" + \"driverTicketPrice_dispatch\";\n        } else {\n            state = state + \"_\" + \"driverTicketPrice\";\n        }\n    }\n    stateList.add(state);\n\t……\n    return stateList;\n}\n```\n这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。\n\n### 重复代码\n代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。\n\n最常见的一种重复场景就是在“**同一个类的两个函数含有相同的表达式**”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。\n还有一种和这类场景相似，就是在“**两个互为兄弟的子类含有相同的表达式**”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。\n\n### 单一功能职责\n```java\n@Data\npublic class BuyerInfoParam {\n    // Required Param\n    private Long buyerCompanyId;\n    private Long buyerAccountId;\n    private Long callerCompanyId;\n    private Long callerAccountId;\n\n    private String tenantId;\n    private String bizCode;\n    private String channel; //这个Channel在查询中不起任何作用，不应该放在这里\n}\n```\n功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。\n可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。\n那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。\nTips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。\n### 其他问题\n#### 函数过长\n一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。\n#### 命名规范\n一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。\n#### 不合理的注释\n注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。\n#### 无用代码\n无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。\n#### 过大的类\n一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。\n\n## 大型重构\n![image.png](/images/refactor-project/2.png)\n### 事前准备\n事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。\n在这个阶段大致可分为三步：\n\n- **明确重构的内容、目的以及方向、目标**\n\n在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。\n\n- **整理数据**\n\n这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。\n附上整个系统的架构和此次重点重构的部分（深色标记部分）\n![image.png](/images/refactor-project/3.png)\n\n- **项目立项**\n\n项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。\n注意：会议结束后需要进行会议纪要邮件周知。\n### 事中执行\n事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。\n\n- **架构设计与评审**\n\n架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。\n该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。\n\n- **详细落地设计方案与评审**\n\n这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。\n在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：\n![image.png](/images/refactor-project/4.png)\n在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。\n在AB程序中，会涉及到两个开关。**灰度开关**（只有它开启了，请求才会被发送到新的流程中进行代码执行）。**执行开关**（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。\n\n- **代码的编写、测试、线下实施**\n\n这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。\n### \n### 事后观测与复盘\n这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。\n\n- **灰度开关流程**\n\n逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。\n\n- **业务执行开关流程**\n\n在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。\n放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。\n\n# 总结\n## 代码技巧\n\n- 写代码的时候遵循一些基本原则，比如单一原则、依赖接口/抽象而不是依赖具体实现。\n- 严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。\n- 单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。\n- 我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。\n- 不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。\n## 重构技巧\n\n- 从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。\n- 提炼类，复用函数，下沉核心能力，让模块职责清晰明了。\n- 依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。\n- 类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。\n- 大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。\n\n代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：\n1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力\n2、代码洁癖、工匠精神\n3、产品思维\n\n","slug":"Refactor-project","published":1,"updated":"2024-02-13T07:20:34.419Z","_id":"cls3f5xxq0000r4x54i19cger","comments":1,"layout":"post","photos":[],"link":"","content":"<p>任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。</p>\n<h1 id=\"什么是重构\"><a href=\"#什么是重构\" class=\"headerlink\" title=\"什么是重构\"></a>什么是重构</h1><blockquote>\n<p>重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。</p>\n</blockquote>\n<p>根据重构的规模程度、时间长短，我们可以将代码重构分为<strong>小型重构</strong>和<strong>大型重构</strong>。</p>\n<p><strong>小型重构</strong>：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。</p>\n<p><strong>大型重构</strong>：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行<strong>服务分层、业务模块化、组件化、代码抽象复用</strong>等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。</p>\n<p>其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：</p>\n<ul>\n<li>不知道怎么重构、缺乏重构的经验和方法论。</li>\n<li>很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。</li>\n<li>重构可能会破坏现有程序，带来意想不到的bug。</li>\n<li>重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。</li>\n</ul>\n<h1 id=\"为什么要重构\"><a href=\"#为什么要重构\" class=\"headerlink\" title=\"为什么要重构\"></a>为什么要重构</h1><p>程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： </p>\n<ul>\n<li><strong>让软件架构始终保持良好的设计。</strong>改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。</li>\n<li><strong>增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。</strong>无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。</li>\n<li><strong>提高研发速度、缩短人力成本。</strong>大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。</li>\n</ul>\n<p><img src=\"/images/refactor-project/1.png\" alt=\"image.png\"></p>\n<h1 id=\"怎么进行重构\"><a href=\"#怎么进行重构\" class=\"headerlink\" title=\"怎么进行重构\"></a>怎么进行重构</h1><h2 id=\"小型重构\"><a href=\"#小型重构\" class=\"headerlink\" title=\"小型重构\"></a>小型重构</h2><p>小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。</p>\n<h3 id=\"业务语义显性化\"><a href=\"#业务语义显性化\" class=\"headerlink\" title=\"业务语义显性化\"></a>业务语义显性化</h3><p>优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。<br>如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。<br><strong>原代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!PvgContext.getCrmUserId().equals(NIL_VALUE) &amp;&amp; icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>重构后</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(canPickUpToPrivateSea())</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//判断客户能否捡私入海</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPickUpToPrivateSea</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(StringUtil.isBlank(PvgContext.getCrmUserId()))&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型问题\"><a href=\"#泛型问题\" class=\"headerlink\" title=\"泛型问题\"></a>泛型问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了大家理解方便，增加了一些注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//msg是从MQ消费到消息</span></span><br><span class=\"line\"><span class=\"type\">Map</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> JSON.parseObject(msg); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">mobile</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xxx&quot;</span>；</span><br><span class=\"line\">ps.put(<span class=\"string\">&quot;driverNumber&quot;</span>, mobile);</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 对ps进行操作</span></span><br><span class=\"line\">Set&lt;String&gt; keySet = (Set&lt;String&gt;)ps.keySet();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(<span class=\"string\">&quot;driverPrice&quot;</span>) &amp;&amp; ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"type\">Object</span> <span class=\"variable\">factPrice</span> <span class=\"operator\">=</span> ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">1</span>】</span><br><span class=\"line\">  \tps.put(<span class=\"string\">&quot;driverPrice&quot;</span>, String.format(<span class=\"string\">&quot;%.2f&quot;</span>,((BigDecimal)factPrice).doubleValue()));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> String) &#123; 【<span class=\"number\">2</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">refund</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>((String)factPrice);</span><br><span class=\"line\">    ps.put(<span class=\"string\">&quot;refundPrice&quot;</span>, refund.stripTrailingZeros().toPlainString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(ORDER_TIP_PRICE) &amp;&amp; ps.get(ORDER_TIP_PRICE) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ps.get(ORDER_TIP_PRICE) <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">3</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">tipPrice</span> <span class=\"operator\">=</span> (BigDecimal)ps.get(ORDER_TIP_PRICE);</span><br><span class=\"line\">    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 将ps作为传输传递给服务内部底层接口</span></span><br><span class=\"line\">msgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//看一下底层接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">innerOrderTempMessage</span><span class=\"params\">(String msg, Map&lt;String, String&gt; ps, PushOrderTotalVO vo)</span>;</span><br></pre></td></tr></table></figure>\n<p>这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map&lt;String, String&gt;限定的接口中就是有很大的问题的，未来底层接口使用String value &#x3D; ps.get(XXX)获取一个非String类型时就会出现类型转换异常。</p>\n<h3 id=\"无病呻吟\"><a href=\"#无病呻吟\" class=\"headerlink\" title=\"无病呻吟\"></a>无病呻吟</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\"><span class=\"comment\">// 设置name和md5</span></span><br><span class=\"line\">config.setName(item.getName());</span><br><span class=\"line\">config.setMd5(item.getMd5());</span><br><span class=\"line\"><span class=\"comment\">// 设置值</span></span><br><span class=\"line\">config.setTypeMap(map);</span><br><span class=\"line\"><span class=\"comment\">// 打印日志</span></span><br><span class=\"line\">LOGGER.info(<span class=\"string\">&quot;update done (&#123;&#125;,&#123;&#125;), start replace&quot;</span>, getName(), getMd5());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ExpiredConfig</span> <span class=\"variable\">expireConfig</span> <span class=\"operator\">=</span> ConfigManager.getExpiredConfig();</span><br><span class=\"line\"><span class=\"comment\">// 为空初始化</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Objects.isNull(expireConfig)) &#123;</span><br><span class=\"line\">  expireConfig = <span class=\"keyword\">new</span> <span class=\"title class_\">ExpiredConfig</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">Map&lt;String, List&lt;TypeItem&gt;&gt; typeMap = ……;   </span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt;&gt; jsonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 循环一级map</span></span><br><span class=\"line\">jsonMap.forEach((k1, v1) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环里面的二级map</span></span><br><span class=\"line\">    v1.forEach((k2, v2) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环里面的三级map</span></span><br><span class=\"line\">        v2.forEach((k3, v3) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 循环最里面的list,哎！</span></span><br><span class=\"line\">            v3.forEach(e -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生成key</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">ck</span> <span class=\"operator\">=</span> getKey(k1, k2, k3);</span><br><span class=\"line\">                <span class=\"comment\">// 为空处理</span></span><br><span class=\"line\">                List&lt;TypeItem&gt; types = typeMap.get(ck);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(types)) &#123;</span><br><span class=\"line\">                    types = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                    typeMap.put(ck, types);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 设置类型</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。</p>\n<h3 id=\"if-else过多\"><a href=\"#if-else过多\" class=\"headerlink\" title=\"if-else过多\"></a>if-else过多</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面截取的get25000OrderState的部分代码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">get25000OrderState</span><span class=\"params\">(OrderTotalVO orderTotalVO)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">mainState</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    List&lt;String&gt; stateList = Lists.newArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    ……</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DispatchType</span> <span class=\"variable\">dispatchType</span> <span class=\"operator\">=</span> DispatchType.getEnum(orderTotalVO.getDispatchType());</span><br><span class=\"line\">    <span class=\"type\">ServiceType</span> <span class=\"variable\">serviceType</span> <span class=\"operator\">=</span> ServiceType.typeOf(orderTotalVO.getServiceType());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (serviceType == ServiceType.CHARTERED_CAR) &#123;</span><br><span class=\"line\">        state = state + <span class=\"string\">&quot;_&quot;</span> + serviceType;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties()))&#123;\t\tstate = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_phoneCall&quot;</span>;                                                                                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_&quot;</span> + pastOrderId;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isHighQuality(orderTotalVO.getHighQualityFlag()) &amp;&amp; DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode())&#123;</span><br><span class=\"line\">                state += <span class=\"string\">&quot;_highQuality&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isOtherPassengerOrder(orderTotalVO)) &#123;</span><br><span class=\"line\">        state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;forOther_aly&quot;</span>;</span><br><span class=\"line\">        stateList.add(state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">BigDecimal</span> <span class=\"variable\">tickOtherPrice</span> <span class=\"operator\">=</span> orderTotalVO.getTicketOtherPrice();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tickOtherPrice != <span class=\"literal\">null</span> &amp;&amp; BigDecimal.ZERO.compareTo(tickOtherPrice) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">\t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stateList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。</p>\n<h3 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a>重复代码</h3><p>代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。</p>\n<p>最常见的一种重复场景就是在“<strong>同一个类的两个函数含有相同的表达式</strong>”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。<br>还有一种和这类场景相似，就是在“<strong>两个互为兄弟的子类含有相同的表达式</strong>”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。</p>\n<h3 id=\"单一功能职责\"><a href=\"#单一功能职责\" class=\"headerlink\" title=\"单一功能职责\"></a>单一功能职责</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BuyerInfoParam</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Required Param</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerAccountId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerAccountId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String tenantId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String bizCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String channel; <span class=\"comment\">//这个Channel在查询中不起任何作用，不应该放在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。<br>可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。<br>那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。<br>Tips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。</p>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><h4 id=\"函数过长\"><a href=\"#函数过长\" class=\"headerlink\" title=\"函数过长\"></a>函数过长</h4><p>一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。</p>\n<h4 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h4><p>一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。</p>\n<h4 id=\"不合理的注释\"><a href=\"#不合理的注释\" class=\"headerlink\" title=\"不合理的注释\"></a>不合理的注释</h4><p>注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。</p>\n<h4 id=\"无用代码\"><a href=\"#无用代码\" class=\"headerlink\" title=\"无用代码\"></a>无用代码</h4><p>无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。</p>\n<h4 id=\"过大的类\"><a href=\"#过大的类\" class=\"headerlink\" title=\"过大的类\"></a>过大的类</h4><p>一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。</p>\n<h2 id=\"大型重构\"><a href=\"#大型重构\" class=\"headerlink\" title=\"大型重构\"></a>大型重构</h2><p><img src=\"/images/refactor-project/2.png\" alt=\"image.png\"></p>\n<h3 id=\"事前准备\"><a href=\"#事前准备\" class=\"headerlink\" title=\"事前准备\"></a>事前准备</h3><p>事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。<br>在这个阶段大致可分为三步：</p>\n<ul>\n<li><strong>明确重构的内容、目的以及方向、目标</strong></li>\n</ul>\n<p>在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。</p>\n<ul>\n<li><strong>整理数据</strong></li>\n</ul>\n<p>这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。<br>附上整个系统的架构和此次重点重构的部分（深色标记部分）<br><img src=\"/images/refactor-project/3.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>项目立项</strong></li>\n</ul>\n<p>项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。<br>注意：会议结束后需要进行会议纪要邮件周知。</p>\n<h3 id=\"事中执行\"><a href=\"#事中执行\" class=\"headerlink\" title=\"事中执行\"></a>事中执行</h3><p>事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。</p>\n<ul>\n<li><strong>架构设计与评审</strong></li>\n</ul>\n<p>架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。<br>该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。</p>\n<ul>\n<li><strong>详细落地设计方案与评审</strong></li>\n</ul>\n<p>这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。<br>在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：<br><img src=\"/images/refactor-project/4.png\" alt=\"image.png\"><br>在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。<br>在AB程序中，会涉及到两个开关。<strong>灰度开关</strong>（只有它开启了，请求才会被发送到新的流程中进行代码执行）。<strong>执行开关</strong>（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。</p>\n<ul>\n<li><strong>代码的编写、测试、线下实施</strong></li>\n</ul>\n<p>这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"事后观测与复盘\"><a href=\"#事后观测与复盘\" class=\"headerlink\" title=\"事后观测与复盘\"></a>事后观测与复盘</h3><p>这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。</p>\n<ul>\n<li><strong>灰度开关流程</strong></li>\n</ul>\n<p>逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。</p>\n<ul>\n<li><strong>业务执行开关流程</strong></li>\n</ul>\n<p>在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。<br>放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"代码技巧\"><a href=\"#代码技巧\" class=\"headerlink\" title=\"代码技巧\"></a>代码技巧</h2><ul>\n<li>写代码的时候遵循一些基本原则，比如单一原则、依赖接口&#x2F;抽象而不是依赖具体实现。</li>\n<li>严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。</li>\n<li>单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。</li>\n<li>我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。</li>\n<li>不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。</li>\n</ul>\n<h2 id=\"重构技巧\"><a href=\"#重构技巧\" class=\"headerlink\" title=\"重构技巧\"></a>重构技巧</h2><ul>\n<li>从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。</li>\n<li>提炼类，复用函数，下沉核心能力，让模块职责清晰明了。</li>\n<li>依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。</li>\n<li>类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。</li>\n<li>大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。</li>\n</ul>\n<p>代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：<br>1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力<br>2、代码洁癖、工匠精神<br>3、产品思维</p>\n","site":{"data":{}},"excerpt":"","more":"<p>任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。</p>\n<h1 id=\"什么是重构\"><a href=\"#什么是重构\" class=\"headerlink\" title=\"什么是重构\"></a>什么是重构</h1><blockquote>\n<p>重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为前提下，提高其可理解性，降低其修改成本。</p>\n</blockquote>\n<p>根据重构的规模程度、时间长短，我们可以将代码重构分为<strong>小型重构</strong>和<strong>大型重构</strong>。</p>\n<p><strong>小型重构</strong>：是对代码的细节进行重构，主要是针对类、函数、变量等代码级别的重构。比如常见的规范命名，消除超大函数，消除重复代码等。一般这类重构修改的地方比较集中，相对简单，影响比较小、时间较短。所以难度相对要低一些，我们完全可以在日常的随版开发中进行。</p>\n<p><strong>大型重构</strong>：是对代码顶层进行重构，包括对系统结构、模块结构、代码结构、类关系的重构。一般采取的手段是进行<strong>服务分层、业务模块化、组件化、代码抽象复用</strong>等。这类重构可能需要进行原则再定义、模式再定义甚至业务再定义。涉及到的代码调整和修改多，所以影响比较大、耗时较长、带来的风险比较大（项目叫停风险、代码Bug风险、业务漏洞风险）。这就需要我们具备大型项目重构的经验，否则很容易犯错，最后得不偿失。所以大型重构其实是一个“无奈”之举。</p>\n<p>其实大多数人都是不喜欢重构工作的，主要可能有以下几个方面的担忧：</p>\n<ul>\n<li>不知道怎么重构、缺乏重构的经验和方法论。</li>\n<li>很难看到短期收益，如果这些利益是长远的，何必现在就付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不负责这块工作了。</li>\n<li>重构可能会破坏现有程序，带来意想不到的bug。</li>\n<li>重构可能需要你付出额外的工作，何况可能待重构的代码并不是你编写的。</li>\n</ul>\n<h1 id=\"为什么要重构\"><a href=\"#为什么要重构\" class=\"headerlink\" title=\"为什么要重构\"></a>为什么要重构</h1><p>程序有两面价值：“今天可以为你做什么” 和 “明天可以为你做什么”。大多数时候，我们都只关注自己今天想要程序做什么。不论是修复错误或是添加特性，都是为了让程序力更强，让它在今天更有价值。但是我为什么还是提倡大家要在合适的时机做代码重构，原因主要有以下几点： </p>\n<ul>\n<li><strong>让软件架构始终保持良好的设计。</strong>改进我们的软件设计，让软件架构向有利的方向发展，能够始终对外提供稳定的服务、从容的面对各种突发的问题。</li>\n<li><strong>增加可维护性，降低维护成本，对团队和个人都是正向的良性循环，让软件更容易理解。</strong>无论是后人阅读前人写的代码，还是事后回顾自己的代码，都能够快速了解整个逻辑，明确业务，轻松的对系统进行维护。</li>\n<li><strong>提高研发速度、缩短人力成本。</strong>大家可能深有体会，一个系统在上线初期，向系统中增加功能时，完成速度非常快，但是如果不注重代码质量，后期向系统中添加一个很小的功能可能就需要花上一周或更长的时间。而代码重构是一种有效的保证代码质量的手段，良好的设计是维护软件开发速度的根本。重构可以帮助你更快速的开发软件，因为它阻止系统腐烂变质，甚至还可以提高设计质量。</li>\n</ul>\n<p><img src=\"/images/refactor-project/1.png\" alt=\"image.png\"></p>\n<h1 id=\"怎么进行重构\"><a href=\"#怎么进行重构\" class=\"headerlink\" title=\"怎么进行重构\"></a>怎么进行重构</h1><h2 id=\"小型重构\"><a href=\"#小型重构\" class=\"headerlink\" title=\"小型重构\"></a>小型重构</h2><p>小型重构一般都是在日常开发中进行，参考的标准即是我们的开发规范和准则，这里就不再详述具体怎么操作。这里罗列一下常见的代码坏味道，因为这类是我们日常小型重构涉及最多的一类场景。来看几种常见的坏味道场景，这些都是基于真实场景列出来的。</p>\n<h3 id=\"业务语义显性化\"><a href=\"#业务语义显性化\" class=\"headerlink\" title=\"业务语义显性化\"></a>业务语义显性化</h3><p>优秀的代码，配合着命名和注释，应该是一首极容易读懂的诗歌，而不是一个需要推敲的字谜。<br>如下图中通过把判断条件封装成函数，通过函数名进行语义显化，可以立竿见影的提升代码的可读性。<br><strong>原代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!PvgContext.getCrmUserId().equals(NIL_VALUE) &amp;&amp; icbuCustomer.getCustomerGroup() != CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>重构后</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(canPickUpToPrivateSea())</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//业务逻辑        </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//判断客户能否捡私入海</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPickUpToPrivateSea</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(StringUtil.isBlank(PvgContext.getCrmUserId()))&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.getCustomerGroup() == CustomerGroup.AliCrmCustomerGroup.CANCEL_GROUP)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型问题\"><a href=\"#泛型问题\" class=\"headerlink\" title=\"泛型问题\"></a>泛型问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了大家理解方便，增加了一些注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//msg是从MQ消费到消息</span></span><br><span class=\"line\"><span class=\"type\">Map</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> JSON.parseObject(msg); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">mobile</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xxx&quot;</span>；</span><br><span class=\"line\">ps.put(<span class=\"string\">&quot;driverNumber&quot;</span>, mobile);</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 对ps进行操作</span></span><br><span class=\"line\">Set&lt;String&gt; keySet = (Set&lt;String&gt;)ps.keySet();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(<span class=\"string\">&quot;driverPrice&quot;</span>) &amp;&amp; ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"type\">Object</span> <span class=\"variable\">factPrice</span> <span class=\"operator\">=</span> ps.get(<span class=\"string\">&quot;driverPrice&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">1</span>】</span><br><span class=\"line\">  \tps.put(<span class=\"string\">&quot;driverPrice&quot;</span>, String.format(<span class=\"string\">&quot;%.2f&quot;</span>,((BigDecimal)factPrice).doubleValue()));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (factPrice <span class=\"keyword\">instanceof</span> String) &#123; 【<span class=\"number\">2</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">refund</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>((String)factPrice);</span><br><span class=\"line\">    ps.put(<span class=\"string\">&quot;refundPrice&quot;</span>, refund.stripTrailingZeros().toPlainString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (keySet.contains(ORDER_TIP_PRICE) &amp;&amp; ps.get(ORDER_TIP_PRICE) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ps.get(ORDER_TIP_PRICE) <span class=\"keyword\">instanceof</span> BigDecimal) &#123; 【<span class=\"number\">3</span>】</span><br><span class=\"line\">  \t<span class=\"type\">BigDecimal</span> <span class=\"variable\">tipPrice</span> <span class=\"operator\">=</span> (BigDecimal)ps.get(ORDER_TIP_PRICE);</span><br><span class=\"line\">    ps.put(ORDER_TIP_PRICE, String.format(PRECISION_ZERO, tipPrice.doubleValue()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// 将ps作为传输传递给服务内部底层接口</span></span><br><span class=\"line\">msgSendService.innerOrderTempMessage(msg, ps, orderTotalVO);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//看一下底层接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">innerOrderTempMessage</span><span class=\"params\">(String msg, Map&lt;String, String&gt; ps, PushOrderTotalVO vo)</span>;</span><br></pre></td></tr></table></figure>\n<p>这段真实的代码先不说依靠value类型的不同做不同的业务(【1】【2】【3】)，单看最后一行将泛型已经擦除的map传递给底层的Map&lt;String, String&gt;限定的接口中就是有很大的问题的，未来底层接口使用String value &#x3D; ps.get(XXX)获取一个非String类型时就会出现类型转换异常。</p>\n<h3 id=\"无病呻吟\"><a href=\"#无病呻吟\" class=\"headerlink\" title=\"无病呻吟\"></a>无病呻吟</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\"><span class=\"comment\">// 设置name和md5</span></span><br><span class=\"line\">config.setName(item.getName());</span><br><span class=\"line\">config.setMd5(item.getMd5());</span><br><span class=\"line\"><span class=\"comment\">// 设置值</span></span><br><span class=\"line\">config.setTypeMap(map);</span><br><span class=\"line\"><span class=\"comment\">// 打印日志</span></span><br><span class=\"line\">LOGGER.info(<span class=\"string\">&quot;update done (&#123;&#125;,&#123;&#125;), start replace&quot;</span>, getName(), getMd5());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ExpiredConfig</span> <span class=\"variable\">expireConfig</span> <span class=\"operator\">=</span> ConfigManager.getExpiredConfig();</span><br><span class=\"line\"><span class=\"comment\">// 为空初始化</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Objects.isNull(expireConfig)) &#123;</span><br><span class=\"line\">  expireConfig = <span class=\"keyword\">new</span> <span class=\"title class_\">ExpiredConfig</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">Map&lt;String, List&lt;TypeItem&gt;&gt; typeMap = ……;   </span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt;&gt; jsonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 循环一级map</span></span><br><span class=\"line\">jsonMap.forEach((k1, v1) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环里面的二级map</span></span><br><span class=\"line\">    v1.forEach((k2, v2) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环里面的三级map</span></span><br><span class=\"line\">        v2.forEach((k3, v3) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 循环最里面的list,哎！</span></span><br><span class=\"line\">            v3.forEach(e -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 生成key</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">ck</span> <span class=\"operator\">=</span> getKey(k1, k2, k3);</span><br><span class=\"line\">                <span class=\"comment\">// 为空处理</span></span><br><span class=\"line\">                List&lt;TypeItem&gt; types = typeMap.get(ck);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(types)) &#123;</span><br><span class=\"line\">                    types = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">                    typeMap.put(ck, types);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 设置类型</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码本身一眼就能看明白是在干什么，写代码的人非要在这个地方加一个不关痛痒的注释，这个注释完全是口水话，毫无价值可言。</p>\n<h3 id=\"if-else过多\"><a href=\"#if-else过多\" class=\"headerlink\" title=\"if-else过多\"></a>if-else过多</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面截取的get25000OrderState的部分代码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">get25000OrderState</span><span class=\"params\">(OrderTotalVO orderTotalVO)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">mainState</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> String.valueOf(orderTotalVO.getOrderState());</span><br><span class=\"line\">    List&lt;String&gt; stateList = Lists.newArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    ……</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DispatchType</span> <span class=\"variable\">dispatchType</span> <span class=\"operator\">=</span> DispatchType.getEnum(orderTotalVO.getDispatchType());</span><br><span class=\"line\">    <span class=\"type\">ServiceType</span> <span class=\"variable\">serviceType</span> <span class=\"operator\">=</span> ServiceType.typeOf(orderTotalVO.getServiceType());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (serviceType == ServiceType.CHARTERED_CAR) &#123;</span><br><span class=\"line\">        state = state + <span class=\"string\">&quot;_&quot;</span> + serviceType;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(OrderPropertiesEnum.ORDER_MARK_CALL_ORDER.valid(orderTotalVO.getOrderProperties()))&#123;\t\tstate = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_phoneCall&quot;</span>;                                                                                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + dispatchType.getCode() + <span class=\"string\">&quot;_&quot;</span> + pastOrderId;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isHighQuality(orderTotalVO.getHighQualityFlag()) &amp;&amp; DispatchType.DRIVER_GRAB.getCode() == dispatchType.getCode())&#123;</span><br><span class=\"line\">                state += <span class=\"string\">&quot;_highQuality&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isOtherPassengerOrder(orderTotalVO)) &#123;</span><br><span class=\"line\">        state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;forOther_aly&quot;</span>;</span><br><span class=\"line\">        stateList.add(state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">BigDecimal</span> <span class=\"variable\">tickOtherPrice</span> <span class=\"operator\">=</span> orderTotalVO.getTicketOtherPrice();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tickOtherPrice != <span class=\"literal\">null</span> &amp;&amp; BigDecimal.ZERO.compareTo(tickOtherPrice) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketOtherPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OrderPropertiesEnum.DISPATCH_ORDER.valid(orderTotalVO.getOrderProperties())) &#123;</span><br><span class=\"line\">            state = mainState + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice_dispatch&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = state + <span class=\"string\">&quot;_&quot;</span> + <span class=\"string\">&quot;driverTicketPrice&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stateList.add(state);</span><br><span class=\"line\">\t……</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stateList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种在if-else内外都关联业务逻辑的场景，比单纯if-else代码还要复杂，让代码阅读性大大降低，让很多人望而却步。被逼到迫不得已估计开发人员是不会动这样的代码的，因为你不知道你动的一小点，可能会让整个业务系统瘫痪。</p>\n<h3 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a>重复代码</h3><p>代码坏味道最多的恐怕就是重复代码，如果你在一个以上的地方看到相同的代码结构，那么可以肯定：遗漏了抽象。重复的代码可能成为一个单独的方法或干脆是另一个类。将重复代码放进类似的抽象，增加了你的设计语言的词汇量。其它程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。</p>\n<p>最常见的一种重复场景就是在“<strong>同一个类的两个函数含有相同的表达式</strong>”，这种形式的重复代码可以在当前类提取公用方法，以便在两处复用。<br>还有一种和这类场景相似，就是在“<strong>两个互为兄弟的子类含有相同的表达式</strong>”，这种形式可以将相同的代码提取到共同父类中，针对有差异化的部分，使用抽象方法延迟到子类实现，这就是常见的模板方法设计模式。如果两个毫不相干的类出现了重复代码，这个时候应该考虑将重复代码提炼到一个新类中，然后在这两个类中调用这个新类的方法。</p>\n<h3 id=\"单一功能职责\"><a href=\"#单一功能职责\" class=\"headerlink\" title=\"单一功能职责\"></a>单一功能职责</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BuyerInfoParam</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Required Param</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long buyerAccountId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerCompanyId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long callerAccountId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String tenantId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String bizCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String channel; <span class=\"comment\">//这个Channel在查询中不起任何作用，不应该放在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能单一是SRP最基本要求，也就是你一个类的功能职责要单一，这样内聚性才高。比如这个参数类，是用来查询网站Buyer信息的，按照SRP，里面就应该放置查询相关的Field就好了。<br>可是呢事实中下面的三个参数其实查询时根本用不到，而是在组装查询结果的时候用到，这给我阅读代码带来了很大的困惑，因为我一直以为这个channel（客户来源渠道）是一个查询需要的一个重要信息。<br>那么如果和查询无关，为什么要把它放到查询param里面呢，问了才知道，只是为了组装查询结果时拿到数据而已。重构时，果断删掉。<br>Tips：不要为了图方便，而破坏SOLID原则，方便的后果就是代码腐化，看不懂，往后要付出的代价更高。</p>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><h4 id=\"函数过长\"><a href=\"#函数过长\" class=\"headerlink\" title=\"函数过长\"></a>函数过长</h4><p>一个好的函数必须满足单一职责原则，短小精悍，只做一件事。过长的函数体和身兼数职的方法都不利于阅读，也不利于进行代码复用。</p>\n<h4 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h4><p>一个好的命名需要能做到“名副其实、见名知意”，直接了当，不存在歧义。</p>\n<h4 id=\"不合理的注释\"><a href=\"#不合理的注释\" class=\"headerlink\" title=\"不合理的注释\"></a>不合理的注释</h4><p>注释是一把双刃剑，好的注释能够给我们好的指导，不好的注释只会将人误导。针对注释，我们需要做到在整合代码时，也把注释一并进行修改，否则就会出现注释和逻辑不一致。另外，如果代码已清晰的表达了自己的意图，那么注释反而是多余的。</p>\n<h4 id=\"无用代码\"><a href=\"#无用代码\" class=\"headerlink\" title=\"无用代码\"></a>无用代码</h4><p>无用代码有两种方式，一种是没有使用场景，如果这类代码不是工具方法或工具类，而是一些无用的业务代码，那么就需要及时的删除清理。另外一种是用注释符包裹的代码块，这些代码在被打上注释符号的时候就应该被删除。</p>\n<h4 id=\"过大的类\"><a href=\"#过大的类\" class=\"headerlink\" title=\"过大的类\"></a>过大的类</h4><p>一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面……试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用不同的类把代码划分开。</p>\n<h2 id=\"大型重构\"><a href=\"#大型重构\" class=\"headerlink\" title=\"大型重构\"></a>大型重构</h2><p><img src=\"/images/refactor-project/2.png\" alt=\"image.png\"></p>\n<h3 id=\"事前准备\"><a href=\"#事前准备\" class=\"headerlink\" title=\"事前准备\"></a>事前准备</h3><p>事前准备作为重构的第一步，这一部分涉及到的事情比较杂，也是最重要的，如果之前准备不充分，很有可能导致在事中执行或重构上线后产生的结果和预期不一致的现象。<br>在这个阶段大致可分为三步：</p>\n<ul>\n<li><strong>明确重构的内容、目的以及方向、目标</strong></li>\n</ul>\n<p>在这一步里面，最重要的是把方向明确清楚，而且这个方向是经得起大家的质疑，能够至少满足未来三到五年的方向。另外一个就是这次重构的目标，由于技术限制、历史包袱等原因，这个目标可能不是最终的目标，那么需要明确最终目标是怎么样的，从这次重构的这个目标到最终的目标还有哪些事情要做，最好都能够明确下来。</p>\n<ul>\n<li><strong>整理数据</strong></li>\n</ul>\n<p>这一步需要对涉及重构部分的现有业务、架构进行梳理，明确重构的内容在系统的哪个服务层级、属于哪个业务模块，依赖方和被依赖方有哪些，有哪些业务场景，每个场景的数据输入输出是怎样的。这个阶段就会有产出物了，一般会沉淀项目部署、业务架构、技术架构、服务上下游依赖、强弱依赖、项目内部服务分层模型、内容功能依赖模型、输入输出数据流等相关的设计图和文档。<br>附上整个系统的架构和此次重点重构的部分（深色标记部分）<br><img src=\"/images/refactor-project/3.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>项目立项</strong></li>\n</ul>\n<p>项目立项一般是通过会议进行，对所有参与重构的部门或小组进行重构工作的宣讲，周知大概的时间计划表（粗略的大致时间），明确各组主要负责的人。另外还需要周知重构涉及到哪些业务和场景、大概的重构方式、业务影响可能有哪些，难点及可能在哪些步骤出现瓶颈。<br>注意：会议结束后需要进行会议纪要邮件周知。</p>\n<h3 id=\"事中执行\"><a href=\"#事中执行\" class=\"headerlink\" title=\"事中执行\"></a>事中执行</h3><p>事中执行这一步骤的事情和任务相对来说比较繁重一些，时间付出会相对来说比较多。</p>\n<ul>\n<li><strong>架构设计与评审</strong></li>\n</ul>\n<p>架构设计评审主要是对标准的业务架构、技术架构、数据架构进行设计与评审。通过评审去发现架构和业务上的问题，这个评审一般是团队内评审，如果在一次评审后，发现架构设计并不能被确定，那就需要再调整，直到团队内对方案架构设计都达成一致，才可以进行下一步，评审结果也需要在评审通过后进行邮件周知参与人。<br>该阶段产出物：重构后的服务部署、系统架构、业务架构、标准数据流、服务分层模式、功能模块UML图等。</p>\n<ul>\n<li><strong>详细落地设计方案与评审</strong></li>\n</ul>\n<p>这个落地的设计方案是事中执行最重要的一个方案，关系到后面的研发编码、自测与联调、依赖方对接、QA测试、线下发布与实施预案、线上发布与实施预案、具体工作量、难度、工作瓶颈等。这个详细落地方案需要深入到整个研发、线下测试、上线过程、灰度场景细节处包括AB灰度程序、AB验证程序。<br>在方案设计中最重要的一环是AB验证程序和AB验证开关，这是评估和检验我们是否重构完成的标准依据。一般的AB验证程序大致如下：<br><img src=\"/images/refactor-project/4.png\" alt=\"image.png\"><br>在数据入口处，使用相同的数据，分别向新老流程都发起处理请求。处理结束之后，将处理结果分别打印到日志中。最后通过离线程序比较新老流程处理的结果是否一致。遵循的原则就是在相同入参的情况下，响应的结果也应该一致。<br>在AB程序中，会涉及到两个开关。<strong>灰度开关</strong>（只有它开启了，请求才会被发送到新的流程中进行代码执行）。<strong>执行开关</strong>（如果新流程中涉及到写操作，这里需要用开关控制在新流程写还是在老流程中写）。转发之前需要将灰度开关和执行开关（一般配置到配置中心，能随时调整）写入到线程上下文中，以免出现在修改配置中心开关时，多处获取开关结果不一致。</p>\n<ul>\n<li><strong>代码的编写、测试、线下实施</strong></li>\n</ul>\n<p>这一步就是按照详细设计的方案，进行编码、单测、联调、功能测试、业务测试、QA测试。通过后，在线下模拟上线流程和线上开关实施过程，校验AB程序，检查是否符合预期，新流程代码覆盖度是否达到上线要求。如果线下数据样本比较少，不能覆盖全部场景，需要通过构造流量覆盖所有的场景，保证所有的场景都能符合预期。当线下覆盖度达到预期，并且AB验证程序没有校验出任何异常时，才能执行上线操作。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"事后观测与复盘\"><a href=\"#事后观测与复盘\" class=\"headerlink\" title=\"事后观测与复盘\"></a>事后观测与复盘</h3><p>这个阶段需要在线上按照线下模拟的实施流程进行线上实施，分为上线、放量、修复、下线老逻辑、复盘这样几个阶段。其中最重要最耗费精力的就是放量流程了。</p>\n<ul>\n<li><strong>灰度开关流程</strong></li>\n</ul>\n<p>逐步放量到新的流程中进行观察，可以按照1%、5%、10%、20%、40%、80%、100%的进度进行放量，让新流程逐步的进行代码逻辑覆盖，注意这个阶段不会打开真实执行写操作的开关。当新流程逻辑覆盖度达到要求、并且AB验证的结果都符合预期后，才可以逐步打开执行写操作开关，进行真实业务的执行操作。</p>\n<ul>\n<li><strong>业务执行开关流程</strong></li>\n</ul>\n<p>在灰度新流程的过程中符合预期后，可以逐步打开业务执行写操作开关流程，仍然可以按照一定的比例进行逐步放量，打开写操作后，只有新逻辑执行写操作，老逻辑将关闭写操作。这个阶段需要观察线上错误、指标异常、用户反馈等问题，确保新流程没有任何问题。<br>放量工作结束后，在稳定一定版本后，就可以将老逻辑和AB验证程序进行下线，重构工作结束。如果有条件可以开一个重构复盘会，检查每个参与方是否都达到了重构要求的标准，复盘重构期间遇到的问题、以及解决方案是什么样的，沉淀方法论避免后续的工作出现类似的问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"代码技巧\"><a href=\"#代码技巧\" class=\"headerlink\" title=\"代码技巧\"></a>代码技巧</h2><ul>\n<li>写代码的时候遵循一些基本原则，比如单一原则、依赖接口&#x2F;抽象而不是依赖具体实现。</li>\n<li>严格遵循编码规范、特殊注释使用 TODO、FIXME、XXX 进行注释。</li>\n<li>单元测试、功能测试、接口测试、集成测试是写代码必不可少的工具。</li>\n<li>我们是代码的作者，后人是代码的读者。写代码要时刻审视，做前人栽树后人乘凉、不做前人挖坑后人陪葬的事情。</li>\n<li>不做破窗效应的第一人，不要觉得现在代码已经很烂了，没有必要再改，直接继续堆代码。如果是这样，总有一天自己会被别人的代码恶心到，“出来混迟早是要还的”。</li>\n</ul>\n<h2 id=\"重构技巧\"><a href=\"#重构技巧\" class=\"headerlink\" title=\"重构技巧\"></a>重构技巧</h2><ul>\n<li>从上至下，由外到内进行建模分析，理清各种关系，是重构的重中之重。</li>\n<li>提炼类，复用函数，下沉核心能力，让模块职责清晰明了。</li>\n<li>依赖接口优于依赖抽象，依赖抽象优于依赖实现，类关系能用组合就不要继承。</li>\n<li>类、接口、抽象接口设计时考虑范围限定符，哪些可以重写、哪些不能重写，泛型限定是否准确。</li>\n<li>大型重构做好各种设计和计划，线下模拟好各种场景，上线一定需要AB验证程序，能够随时进行新老切换。</li>\n</ul>\n<p>代码重构的技巧是可以通过学习去掌握，大型项目的重构也可以按照方法论来参考执行。但是有些方法之外的还是需要我们自己去琢磨，有所思、有所想：<br>1、抽象的分析问题能力、结构化思维能力、复杂问题分解能力<br>2、代码洁癖、工匠精神<br>3、产品思维</p>\n"},{"title":"线程安全的无锁日志","date":"2024-02-02T05:40:24.000Z","_content":"因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。\n具体源码可见：[Fly-Log](https://github.com/LiaoYuanF/Fly-Log)\n# 日志系统应该满足的要求\n\n1. 高效，作为一个日志系统，不应该占据太多资源\n2. 简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度\n3. 线程安全，服务端的各个线程都能同时读写日志\n4. 轮替问题，如果半年到一年的日志放到一个文件会导致文件过大\n5. 及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失\n# 难点问题及其解决\n当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。\n### 线程安全\n解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。\n\n1. 使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程/多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。\n2. 每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。\n### 轮替问题\n#### 有锁方案\n轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。\n#### 无锁方案\n可以使用posix中的dup2来实现无锁轮替文件。\n```cpp\n//轮替时，首先重命名已打开的日志文件，保持打开状态，\nrename(filename, newname);\n//然后创建新的日志文件\nfd = open(filename,...);\n//使用dup2系统函数把fd（新）复制到fd_（旧）上\ndup2(fd, fd_);\n//关闭fd（新）\nclose(fd);\n```\n其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, ...)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。\n","source":"_posts/Look-free-log.md","raw":"---\ntitle: 线程安全的无锁日志\ndate: 2024-02-02 13:40:24\ntags: 工具集合\n---\n因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。\n具体源码可见：[Fly-Log](https://github.com/LiaoYuanF/Fly-Log)\n# 日志系统应该满足的要求\n\n1. 高效，作为一个日志系统，不应该占据太多资源\n2. 简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度\n3. 线程安全，服务端的各个线程都能同时读写日志\n4. 轮替问题，如果半年到一年的日志放到一个文件会导致文件过大\n5. 及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失\n# 难点问题及其解决\n当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。\n### 线程安全\n解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。\n\n1. 使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程/多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。\n2. 每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。\n### 轮替问题\n#### 有锁方案\n轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。\n#### 无锁方案\n可以使用posix中的dup2来实现无锁轮替文件。\n```cpp\n//轮替时，首先重命名已打开的日志文件，保持打开状态，\nrename(filename, newname);\n//然后创建新的日志文件\nfd = open(filename,...);\n//使用dup2系统函数把fd（新）复制到fd_（旧）上\ndup2(fd, fd_);\n//关闭fd（新）\nclose(fd);\n```\n其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, ...)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。\n","slug":"Look-free-log","published":1,"updated":"2024-02-02T05:48:30.498Z","_id":"cls482gg500006lx5024naovq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。<br>具体源码可见：<a href=\"https://github.com/LiaoYuanF/Fly-Log\">Fly-Log</a></p>\n<h1 id=\"日志系统应该满足的要求\"><a href=\"#日志系统应该满足的要求\" class=\"headerlink\" title=\"日志系统应该满足的要求\"></a>日志系统应该满足的要求</h1><ol>\n<li>高效，作为一个日志系统，不应该占据太多资源</li>\n<li>简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度</li>\n<li>线程安全，服务端的各个线程都能同时读写日志</li>\n<li>轮替问题，如果半年到一年的日志放到一个文件会导致文件过大</li>\n<li>及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失</li>\n</ol>\n<h1 id=\"难点问题及其解决\"><a href=\"#难点问题及其解决\" class=\"headerlink\" title=\"难点问题及其解决\"></a>难点问题及其解决</h1><p>当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。</p>\n<ol>\n<li>使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程&#x2F;多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。</li>\n<li>每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。</li>\n</ol>\n<h3 id=\"轮替问题\"><a href=\"#轮替问题\" class=\"headerlink\" title=\"轮替问题\"></a>轮替问题</h3><h4 id=\"有锁方案\"><a href=\"#有锁方案\" class=\"headerlink\" title=\"有锁方案\"></a>有锁方案</h4><p>轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。</p>\n<h4 id=\"无锁方案\"><a href=\"#无锁方案\" class=\"headerlink\" title=\"无锁方案\"></a>无锁方案</h4><p>可以使用posix中的dup2来实现无锁轮替文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//轮替时，首先重命名已打开的日志文件，保持打开状态，</span></span><br><span class=\"line\"><span class=\"built_in\">rename</span>(filename, newname);</span><br><span class=\"line\"><span class=\"comment\">//然后创建新的日志文件</span></span><br><span class=\"line\">fd = <span class=\"built_in\">open</span>(filename,...);</span><br><span class=\"line\"><span class=\"comment\">//使用dup2系统函数把fd（新）复制到fd_（旧）上</span></span><br><span class=\"line\"><span class=\"built_in\">dup2</span>(fd, fd_);</span><br><span class=\"line\"><span class=\"comment\">//关闭fd（新）</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(fd);</span><br></pre></td></tr></table></figure>\n<p>其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, …)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>因为是同步写入，所以不具有在生产环境中的实际应用价值，只是基于对无锁写入方案的一个探讨。<br>具体源码可见：<a href=\"https://github.com/LiaoYuanF/Fly-Log\">Fly-Log</a></p>\n<h1 id=\"日志系统应该满足的要求\"><a href=\"#日志系统应该满足的要求\" class=\"headerlink\" title=\"日志系统应该满足的要求\"></a>日志系统应该满足的要求</h1><ol>\n<li>高效，作为一个日志系统，不应该占据太多资源</li>\n<li>简洁，尽量不要引入太复杂的依赖（log4cpp库），给系统开发带来难度</li>\n<li>线程安全，服务端的各个线程都能同时读写日志</li>\n<li>轮替问题，如果半年到一年的日志放到一个文件会导致文件过大</li>\n<li>及时保存，程序故障导致异常退出，如果日志还留在缓冲区就会导致丢失</li>\n</ol>\n<h1 id=\"难点问题及其解决\"><a href=\"#难点问题及其解决\" class=\"headerlink\" title=\"难点问题及其解决\"></a>难点问题及其解决</h1><p>当我选择弃用log4cpp等庞大的库的时候，就意味着需要自己去解决3-5等问题。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>解决线程安全应当考虑不引入锁，因为加锁会带来复杂性和性能问题，所以应当考虑更高效的解决方案。</p>\n<ol>\n<li>使用O_APPEND方式打开文件，这个标记让write写出的内容添加到文件末尾，移动文件指针与输出内容是原子的，由操作系统来保证原子性。因此这个标记保证在多线程&#x2F;多进程调用write也能够保持输出的内容不会相互覆盖错乱，nginx的日志也利用了这个标记来达到多进程不干扰。</li>\n<li>每一次log，都会生成包括了时间的最终输出字符串，调用write，写出到日志系统的文件描述符fd。当write返回时，日志已经写到操作系统，不管程序是否崩溃，只要操作系统不崩溃，那么输出的内容就会保存到日志文件中。</li>\n</ol>\n<h3 id=\"轮替问题\"><a href=\"#轮替问题\" class=\"headerlink\" title=\"轮替问题\"></a>轮替问题</h3><h4 id=\"有锁方案\"><a href=\"#有锁方案\" class=\"headerlink\" title=\"有锁方案\"></a>有锁方案</h4><p>轮替的过程中，需要关闭当前文件并打开新文件，让新的内容写到新文件中，在多线程环境下就需要锁来同步所有线程的日志输出操作，避免写入到不合法的文件描述符中。</p>\n<h4 id=\"无锁方案\"><a href=\"#无锁方案\" class=\"headerlink\" title=\"无锁方案\"></a>无锁方案</h4><p>可以使用posix中的dup2来实现无锁轮替文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//轮替时，首先重命名已打开的日志文件，保持打开状态，</span></span><br><span class=\"line\"><span class=\"built_in\">rename</span>(filename, newname);</span><br><span class=\"line\"><span class=\"comment\">//然后创建新的日志文件</span></span><br><span class=\"line\">fd = <span class=\"built_in\">open</span>(filename,...);</span><br><span class=\"line\"><span class=\"comment\">//使用dup2系统函数把fd（新）复制到fd_（旧）上</span></span><br><span class=\"line\"><span class=\"built_in\">dup2</span>(fd, fd_);</span><br><span class=\"line\"><span class=\"comment\">//关闭fd（新）</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(fd);</span><br></pre></td></tr></table></figure>\n<p>其中dup2是原子操作，它会关闭fd_并且把fd_也指向fd打开的文件。因此fd_这个文件描述符总是保持打开状态，并且值不变，但是前后指向了不同的文件，完全不会影响其他线程调用write(fd_, …)等操作。另一边write也是个原子操作，它与dup2不会交叉进行，因此保证了日志系统的正确性。</p>\n"},{"title":"线程安全的无锁循环队列","date":"2023-12-28T05:30:34.000Z","_content":"想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。\n# 需求的自然语言描述\n用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释\n具体要求如下：\n\n1. 环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写\n2. 支持模板，存放的数据类型可以自定义\n3. 代码风格使用google C++风格\n4. 在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由\n# Gpt第一轮尝试\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n\n// 线程安全的循环队列模板\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity) {}\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不满\n        notFull_.wait(lock, [this] { return queue_.size() < capacity_; });\n        queue_.push(item);\n        lock.unlock();\n        // 通知等待的线程队列不为空\n        notEmpty_.notify_one();\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (queue_.size() < capacity_) {\n            queue_.push(item);\n            // 通知等待的线程队列不为空\n            notEmpty_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不空\n        notEmpty_.wait(lock, [this] { return !queue_.empty(); });\n        T item = queue_.front();\n        queue_.pop();\n        lock.unlock();\n        // 通知等待的线程队列不满\n        notFull_.notify_one();\n        return item;\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (!queue_.empty()) {\n            item = queue_.front();\n            queue_.pop();\n            // 通知等待的线程队列不满\n            notFull_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::queue<T> queue_;\n    std::mutex mutex_;\n    std::condition_variable notFull_;\n    std::condition_variable notEmpty_;\n};\n```\n## 对代码的分析\n代码最低限度地实现了我们提出的需求，比如阻塞/非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。\n\n1. 可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。\n2. gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。\n#  Gpt的第二轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 由于采用deque的数据结构，导致存在动态分配内存的开销\n2. mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        while (true) {\n            size_t currentTail = tail_.load(std::memory_order_relaxed);\n            size_t nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail != head_.load(std::memory_order_acquire)) {\n                data_[currentTail] = item;\n                tail_.store(nextTail, std::memory_order_release);\n                return;\n            }\n            // 队列已满，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        while (true) {\n            size_t currentHead = head_.load(std::memory_order_relaxed);\n            size_t currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead != currentTail) {\n                T item = data_[currentHead];\n                head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n                return item;\n            }\n            // 队列为空，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead != currentTail) {\n            item = data_[currentHead];\n            head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n```\n## 对代码的分析\n从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。\n可以简单分析一下，这轮优化过程中使用到的一些知识点：\n### 为什么舍弃条件变量\n**std::condition_variable** 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用**condition_variable** 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。\n但是**condition_variable** 必须搭配mutex使用，在我们限定无锁编程的情况下，**condition_variable** 显然是无法被采用的，所以被舍弃了。\n### 阻塞写时安全性论证\n```cpp\nvoid Enqueue(const T& item) {\n    while (true) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return;\n        }\n        // 队列已满，等待\n        std::this_thread::yield();\n    }\n}\n```\n这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。\n**错误一：**\n下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。\n```cpp\nsize_t currentTail = tail_.load(std::memory_order_relaxed);\nsize_t nextTail = (currentTail + 1) % capacity_;\n```\n**错误二：**\n虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。\n```cpp\nif (nextTail != head_.load(std::memory_order_acquire)) {\n    data_[currentTail] = item;\n    // something else\n}\n```\n所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。\n# Gpt的第三轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                // 队列已满，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = item;\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail == head_.load(std::memory_order_acquire))\n            return false;\n\n        if (tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行写入操作\n            data_[currentTail] = item;\n            return true;\n        }\n\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                // 队列为空，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        return data_[currentHead];\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead == currentTail)\n            return false;\n\n        if (head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行读取操作\n            item = data_[currentHead];\n            return true;\n        }\n\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n## 对代码的分析\n我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：\n```cpp\nvoid Enqueue(const T& item) {\n    size_t currentTail;\n    size_t nextTail;\n    do {\n        currentTail = tail_.load(std::memory_order_relaxed);\n        nextTail = (currentTail + 1) % capacity_;\n        if (nextTail == head_.load(std::memory_order_acquire)) {\n            // 队列已满，等待\n            std::this_thread::yield();\n            continue;\n        }\n        // 尝试使用CAS进行原子操作\n    } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n    // CAS成功，可以进行写入操作\n    data_[currentTail] = item;\n}\n```\n在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。\n# 一些更远的优化点\n此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。\n\n1. 阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。\n2. 该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。\n\n改良后的代码如下：\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 通用的入队操作\n    template <typename U>\n    bool Enqueue(U&& item, bool blocking = true) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = std::forward<U>(item);\n        return true;\n    }\n\n    // 通用的出队操作\n    template <typename U>\n    bool Dequeue(U& item, bool blocking = true) {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        item = std::move(data_[currentHead]);\n        return true;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n\n","source":"_posts/Look-free-circular-queue.md","raw":"---\ntitle: 线程安全的无锁循环队列\ndate: 2023-12-28 13:30:34\ntags: 工具集合\n---\n想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。\n# 需求的自然语言描述\n用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释\n具体要求如下：\n\n1. 环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写\n2. 支持模板，存放的数据类型可以自定义\n3. 代码风格使用google C++风格\n4. 在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由\n# Gpt第一轮尝试\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n\n// 线程安全的循环队列模板\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity) {}\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不满\n        notFull_.wait(lock, [this] { return queue_.size() < capacity_; });\n        queue_.push(item);\n        lock.unlock();\n        // 通知等待的线程队列不为空\n        notEmpty_.notify_one();\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (queue_.size() < capacity_) {\n            queue_.push(item);\n            // 通知等待的线程队列不为空\n            notEmpty_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // 使用条件变量等待队列不空\n        notEmpty_.wait(lock, [this] { return !queue_.empty(); });\n        T item = queue_.front();\n        queue_.pop();\n        lock.unlock();\n        // 通知等待的线程队列不满\n        notFull_.notify_one();\n        return item;\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (!queue_.empty()) {\n            item = queue_.front();\n            queue_.pop();\n            // 通知等待的线程队列不满\n            notFull_.notify_one();\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::queue<T> queue_;\n    std::mutex mutex_;\n    std::condition_variable notFull_;\n    std::condition_variable notEmpty_;\n};\n```\n## 对代码的分析\n代码最低限度地实现了我们提出的需求，比如阻塞/非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。\n\n1. 可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。\n2. gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。\n#  Gpt的第二轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 由于采用deque的数据结构，导致存在动态分配内存的开销\n2. mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        while (true) {\n            size_t currentTail = tail_.load(std::memory_order_relaxed);\n            size_t nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail != head_.load(std::memory_order_acquire)) {\n                data_[currentTail] = item;\n                tail_.store(nextTail, std::memory_order_release);\n                return;\n            }\n            // 队列已满，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        while (true) {\n            size_t currentHead = head_.load(std::memory_order_relaxed);\n            size_t currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead != currentTail) {\n                T item = data_[currentHead];\n                head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n                return item;\n            }\n            // 队列为空，等待\n            std::this_thread::yield();\n        }\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead != currentTail) {\n            item = data_[currentHead];\n            head_.store((currentHead + 1) % capacity_, std::memory_order_release);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n```\n## 对代码的分析\n从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。\n可以简单分析一下，这轮优化过程中使用到的一些知识点：\n### 为什么舍弃条件变量\n**std::condition_variable** 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用**condition_variable** 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。\n但是**condition_variable** 必须搭配mutex使用，在我们限定无锁编程的情况下，**condition_variable** 显然是无法被采用的，所以被舍弃了。\n### 阻塞写时安全性论证\n```cpp\nvoid Enqueue(const T& item) {\n    while (true) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n        if (nextTail != head_.load(std::memory_order_acquire)) {\n            data_[currentTail] = item;\n            tail_.store(nextTail, std::memory_order_release);\n            return;\n        }\n        // 队列已满，等待\n        std::this_thread::yield();\n    }\n}\n```\n这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。\n**错误一：**\n下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。\n```cpp\nsize_t currentTail = tail_.load(std::memory_order_relaxed);\nsize_t nextTail = (currentTail + 1) % capacity_;\n```\n**错误二：**\n虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。\n```cpp\nif (nextTail != head_.load(std::memory_order_acquire)) {\n    data_[currentTail] = item;\n    // something else\n}\n```\n所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。\n# Gpt的第三轮尝试\n## 对功能修改的描述\n目前代码存在一些问题，考虑针对以下点进行优化：\n\n1. 目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化\n## Gpt给出的结果\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 阻塞写入队列\n    void Enqueue(const T& item) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                // 队列已满，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = item;\n    }\n\n    // 非阻塞写入队列\n    bool TryEnqueue(const T& item) {\n        size_t currentTail = tail_.load(std::memory_order_relaxed);\n        size_t nextTail = (currentTail + 1) % capacity_;\n\n        if (nextTail == head_.load(std::memory_order_acquire))\n            return false;\n\n        if (tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行写入操作\n            data_[currentTail] = item;\n            return true;\n        }\n\n        return false;\n    }\n\n    // 阻塞读取队列\n    T Dequeue() {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                // 队列为空，等待\n                std::this_thread::yield();\n                continue;\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        return data_[currentHead];\n    }\n\n    // 非阻塞读取队列\n    bool TryDequeue(T& item) {\n        size_t currentHead = head_.load(std::memory_order_relaxed);\n        size_t currentTail = tail_.load(std::memory_order_acquire);\n\n        if (currentHead == currentTail)\n            return false;\n\n        if (head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel)) {\n            // CAS成功，可以进行读取操作\n            item = data_[currentHead];\n            return true;\n        }\n\n        return false;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n## 对代码的分析\n我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：\n```cpp\nvoid Enqueue(const T& item) {\n    size_t currentTail;\n    size_t nextTail;\n    do {\n        currentTail = tail_.load(std::memory_order_relaxed);\n        nextTail = (currentTail + 1) % capacity_;\n        if (nextTail == head_.load(std::memory_order_acquire)) {\n            // 队列已满，等待\n            std::this_thread::yield();\n            continue;\n        }\n        // 尝试使用CAS进行原子操作\n    } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n    // CAS成功，可以进行写入操作\n    data_[currentTail] = item;\n}\n```\n在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。\n# 一些更远的优化点\n此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。\n\n1. 阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。\n2. 该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。\n\n改良后的代码如下：\n```cpp\n#include <iostream>\n#include <vector>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n\ntemplate <typename T>\nclass ThreadSafeQueue {\npublic:\n    explicit ThreadSafeQueue(size_t capacity) : capacity_(capacity), head_(0), tail_(0) {\n        data_.resize(capacity);\n    }\n\n    // 通用的入队操作\n    template <typename U>\n    bool Enqueue(U&& item, bool blocking = true) {\n        size_t currentTail;\n        size_t nextTail;\n\n        do {\n            currentTail = tail_.load(std::memory_order_relaxed);\n            nextTail = (currentTail + 1) % capacity_;\n\n            if (nextTail == head_.load(std::memory_order_acquire)) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!tail_.compare_exchange_weak(currentTail, nextTail, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行写入操作\n        data_[currentTail] = std::forward<U>(item);\n        return true;\n    }\n\n    // 通用的出队操作\n    template <typename U>\n    bool Dequeue(U& item, bool blocking = true) {\n        size_t currentHead;\n        size_t currentTail;\n\n        do {\n            currentHead = head_.load(std::memory_order_relaxed);\n            currentTail = tail_.load(std::memory_order_acquire);\n\n            if (currentHead == currentTail) {\n                if (blocking) {\n                    std::this_thread::yield();\n                    continue;\n                } else {\n                    return false;  // 如果是非阻塞模式，直接返回失败\n                }\n            }\n\n            // 尝试使用CAS进行原子操作\n        } while (!head_.compare_exchange_weak(currentHead, (currentHead + 1) % capacity_, std::memory_order_acq_rel));\n\n        // CAS成功，可以进行读取操作\n        item = std::move(data_[currentHead]);\n        return true;\n    }\n\nprivate:\n    size_t capacity_;\n    std::vector<T> data_;\n    std::atomic<size_t> head_;\n    std::atomic<size_t> tail_;\n};\n\n```\n\n","slug":"Look-free-circular-queue","published":1,"updated":"2024-02-02T05:57:50.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls48hpdw0000ecx576pb11hl","content":"<p>想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。</p>\n<h1 id=\"需求的自然语言描述\"><a href=\"#需求的自然语言描述\" class=\"headerlink\" title=\"需求的自然语言描述\"></a>需求的自然语言描述</h1><p>用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释<br>具体要求如下：</p>\n<ol>\n<li>环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写</li>\n<li>支持模板，存放的数据类型可以自定义</li>\n<li>代码风格使用google C++风格</li>\n<li>在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由</li>\n</ol>\n<h1 id=\"Gpt第一轮尝试\"><a href=\"#Gpt第一轮尝试\" class=\"headerlink\" title=\"Gpt第一轮尝试\"></a>Gpt第一轮尝试</h1><h2 id=\"Gpt给出的结果\"><a href=\"#Gpt给出的结果\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的循环队列模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>() &lt; capacity_; &#125;);</span><br><span class=\"line\">        queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue_.<span class=\"built_in\">size</span>() &lt; capacity_) &#123;</span><br><span class=\"line\">            queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">            notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> !queue_.<span class=\"built_in\">empty</span>(); &#125;);</span><br><span class=\"line\">        T item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::queue&lt;T&gt; queue_;</span><br><span class=\"line\">    std::mutex mutex_;</span><br><span class=\"line\">    std::condition_variable notFull_;</span><br><span class=\"line\">    std::condition_variable notEmpty_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析\"><a href=\"#对代码的分析\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>代码最低限度地实现了我们提出的需求，比如阻塞&#x2F;非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。</p>\n<ol>\n<li>可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。</li>\n<li>gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。</li>\n</ol>\n<h1 id=\"Gpt的第二轮尝试\"><a href=\"#Gpt的第二轮尝试\" class=\"headerlink\" title=\"Gpt的第二轮尝试\"></a>Gpt的第二轮尝试</h1><h2 id=\"对功能修改的描述\"><a href=\"#对功能修改的描述\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>由于采用deque的数据结构，导致存在动态分配内存的开销</li>\n<li>mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作</li>\n</ol>\n<h2 id=\"Gpt给出的结果-1\"><a href=\"#Gpt给出的结果-1\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                data_[currentTail] = item;</span><br><span class=\"line\">                tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">                T item = data_[currentHead];</span><br><span class=\"line\">                head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-1\"><a href=\"#对代码的分析-1\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。<br>可以简单分析一下，这轮优化过程中使用到的一些知识点：</p>\n<h3 id=\"为什么舍弃条件变量\"><a href=\"#为什么舍弃条件变量\" class=\"headerlink\" title=\"为什么舍弃条件变量\"></a>为什么舍弃条件变量</h3><p><strong>std::condition_variable</strong> 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用<strong>condition_variable</strong> 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。<br>但是<strong>condition_variable</strong> 必须搭配mutex使用，在我们限定无锁编程的情况下，<strong>condition_variable</strong> 显然是无法被采用的，所以被舍弃了。</p>\n<h3 id=\"阻塞写时安全性论证\"><a href=\"#阻塞写时安全性论证\" class=\"headerlink\" title=\"阻塞写时安全性论证\"></a>阻塞写时安全性论证</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。<br><strong>错误一：</strong><br>下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\"><span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br></pre></td></tr></table></figure>\n<p><strong>错误二：</strong><br>虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">    <span class=\"comment\">// something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。</p>\n<h1 id=\"Gpt的第三轮尝试\"><a href=\"#Gpt的第三轮尝试\" class=\"headerlink\" title=\"Gpt的第三轮尝试\"></a>Gpt的第三轮尝试</h1><h2 id=\"对功能修改的描述-1\"><a href=\"#对功能修改的描述-1\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化</li>\n</ol>\n<h2 id=\"Gpt给出的结果-2\"><a href=\"#Gpt给出的结果-2\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data_[currentHead];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead == currentTail)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-2\"><a href=\"#对代码的分析-2\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\">    <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。</p>\n<h1 id=\"一些更远的优化点\"><a href=\"#一些更远的优化点\" class=\"headerlink\" title=\"一些更远的优化点\"></a>一些更远的优化点</h1><p>此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。</p>\n<ol>\n<li>阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。</li>\n<li>该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。</li>\n</ol>\n<p>改良后的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的入队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Enqueue</span><span class=\"params\">(U&amp;&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = std::forward&lt;U&gt;(item);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的出队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Dequeue</span><span class=\"params\">(U&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        item = std::<span class=\"built_in\">move</span>(data_[currentHead]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>想要探寻一下和ChatGpt的合作开发模式，因此尝试能否单纯依靠prompt进行修正，由Gpt来实现一个具有一定复杂度的循环队列。</p>\n<h1 id=\"需求的自然语言描述\"><a href=\"#需求的自然语言描述\" class=\"headerlink\" title=\"需求的自然语言描述\"></a>需求的自然语言描述</h1><p>用C++ 20的语言标准，实现线程安全的循环队列，提供详细注释<br>具体要求如下：</p>\n<ol>\n<li>环形队列要支持阻塞读和非阻塞读，阻塞写和非阻塞写</li>\n<li>支持模板，存放的数据类型可以自定义</li>\n<li>代码风格使用google C++风格</li>\n<li>在开发中尽可能提高队列的性能，并说明采取了哪些手段提高性能，说明理由</li>\n</ol>\n<h1 id=\"Gpt第一轮尝试\"><a href=\"#Gpt第一轮尝试\" class=\"headerlink\" title=\"Gpt第一轮尝试\"></a>Gpt第一轮尝试</h1><h2 id=\"Gpt给出的结果\"><a href=\"#Gpt给出的结果\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的循环队列模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> queue_.<span class=\"built_in\">size</span>() &lt; capacity_; &#125;);</span><br><span class=\"line\">        queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue_.<span class=\"built_in\">size</span>() &lt; capacity_) &#123;</span><br><span class=\"line\">            queue_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不为空</span></span><br><span class=\"line\">            notEmpty_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用条件变量等待队列不空</span></span><br><span class=\"line\">        notEmpty_.<span class=\"built_in\">wait</span>(lock, [<span class=\"keyword\">this</span>] &#123; <span class=\"keyword\">return</span> !queue_.<span class=\"built_in\">empty</span>(); &#125;);</span><br><span class=\"line\">        T item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        lock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">        notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!queue_.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            item = queue_.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            queue_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待的线程队列不满</span></span><br><span class=\"line\">            notFull_.<span class=\"built_in\">notify_one</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::queue&lt;T&gt; queue_;</span><br><span class=\"line\">    std::mutex mutex_;</span><br><span class=\"line\">    std::condition_variable notFull_;</span><br><span class=\"line\">    std::condition_variable notEmpty_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析\"><a href=\"#对代码的分析\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>代码最低限度地实现了我们提出的需求，比如阻塞&#x2F;非阻塞读写、支持模板、代码风格等。但是代码中存在着许多显而易见的问题。</p>\n<ol>\n<li>可能是我使用的“队列”一词对gpt造成了先入为主的印象，导致它在数据结构上采用了deque的结构，当deque需要增长时，它会分配一个新的内存块，并将其链接到现有的块，这样一个动态的结构天生会对内存的分配存在开销，偏离了我们提出的高性能的目的。</li>\n<li>gpt在代码设计中，为了保障线程安全的要求，使用了互斥锁，这一块是可以优化的，可以通过原子变量的CAS操作来规避掉锁的开销。</li>\n</ol>\n<h1 id=\"Gpt的第二轮尝试\"><a href=\"#Gpt的第二轮尝试\" class=\"headerlink\" title=\"Gpt的第二轮尝试\"></a>Gpt的第二轮尝试</h1><h2 id=\"对功能修改的描述\"><a href=\"#对功能修改的描述\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>由于采用deque的数据结构，导致存在动态分配内存的开销</li>\n<li>mutex互斥锁的存在降低了效率，能否通过原子变量实现无锁操作</li>\n</ol>\n<h2 id=\"Gpt给出的结果-1\"><a href=\"#Gpt给出的结果-1\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                data_[currentTail] = item;</span><br><span class=\"line\">                tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">                T item = data_[currentHead];</span><br><span class=\"line\">                head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead != currentTail) &#123;</span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            head_.<span class=\"built_in\">store</span>((currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-1\"><a href=\"#对代码的分析-1\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>从这轮优化中粗看，gpt已经修复了上文中提到的两个问题，使用了std::atomic来管理head_和tail_，并通过原子操作实现队列的无锁操作。在阻塞写入和读取的过程中，移除了两个条件变量，使用std::this_thread::yield()来让出CPU。<br>可以简单分析一下，这轮优化过程中使用到的一些知识点：</p>\n<h3 id=\"为什么舍弃条件变量\"><a href=\"#为什么舍弃条件变量\" class=\"headerlink\" title=\"为什么舍弃条件变量\"></a>为什么舍弃条件变量</h3><p><strong>std::condition_variable</strong> 是 C++ 标准库中的一个多线程同步工具，用于在多个线程之间进行条件同步。采用<strong>condition_variable</strong> 主动来实现线程的等待和唤醒机制显然比盲目地std::this_thread::yield()让出时间片更为合理，如果在阻塞写或者阻塞读的情况下，有可能造成频繁的线程切换，造成开销。<br>但是<strong>condition_variable</strong> 必须搭配mutex使用，在我们限定无锁编程的情况下，<strong>condition_variable</strong> 显然是无法被采用的，所以被舍弃了。</p>\n<h3 id=\"阻塞写时安全性论证\"><a href=\"#阻塞写时安全性论证\" class=\"headerlink\" title=\"阻塞写时安全性论证\"></a>阻塞写时安全性论证</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            tail_.<span class=\"built_in\">store</span>(nextTail, std::memory_order_release);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是gpt给出的代码，如我们提示的那样使用上了原子变量，试图通过内存序来保障读写之间的安全性。但是很明显，这段代码是在多写情况下是线程不安全的。<br><strong>错误一：</strong><br>下面的两行代码之间不是原子的，多个线程在同一时刻可能读取相同的 tail_ 值，然后计算出相同的 nextTail，这可能导致它们尝试在相同的位置写入数据，从而导致数据覆盖。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\"><span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br></pre></td></tr></table></figure>\n<p><strong>错误二：</strong><br>虽然 head_ 的加载使用了 memory_order_acquire，但是在实际的操作中，其他线程可能在这段时间内修改了 head_ 的值，导致脏读的出现，从而导致判断错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nextTail != head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">    <span class=\"comment\">// something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以从上面指出的这两个错误来看，这部分代码存在着比较致命的问题。</p>\n<h1 id=\"Gpt的第三轮尝试\"><a href=\"#Gpt的第三轮尝试\" class=\"headerlink\" title=\"Gpt的第三轮尝试\"></a>Gpt的第三轮尝试</h1><h2 id=\"对功能修改的描述-1\"><a href=\"#对功能修改的描述-1\" class=\"headerlink\" title=\"对功能修改的描述\"></a>对功能修改的描述</h2><p>目前代码存在一些问题，考虑针对以下点进行优化：</p>\n<ol>\n<li>目前代码面对多线程写入的场景时，因为临界区的存在，存在不安全的问题，考虑用CAS操作进行优化</li>\n</ol>\n<h2 id=\"Gpt给出的结果-2\"><a href=\"#Gpt给出的结果-2\" class=\"headerlink\" title=\"Gpt给出的结果\"></a>Gpt给出的结果</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞写入队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryEnqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">            data_[currentTail] = item;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">Dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列为空，等待</span></span><br><span class=\"line\">                std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data_[currentHead];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非阻塞读取队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryDequeue</span><span class=\"params\">(T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentHead == currentTail)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">            item = data_[currentHead];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"对代码的分析-2\"><a href=\"#对代码的分析-2\" class=\"headerlink\" title=\"对代码的分析\"></a>对代码的分析</h2><p>我们回到上文中有问题的函数，经过更新之后的代码片段如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列已满，等待</span></span><br><span class=\"line\">            std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\">    <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">    data_[currentTail] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数内部，如我们提示的那样，将尾指针移动的逻辑包裹在了一个compare_exchange_weak操作的内部，如果当前内存中的tail_变量与我们预期的currentTail不一样，则重新load，重新计算nextTail，如果和预期的一致，则更新tail_为nextTail。</p>\n<h1 id=\"一些更远的优化点\"><a href=\"#一些更远的优化点\" class=\"headerlink\" title=\"一些更远的优化点\"></a>一些更远的优化点</h1><p>此时，这份代码基本已经成型，但是gpt的自由发挥距离我想要的代码还有一定差距。</p>\n<ol>\n<li>阻塞接口和非阻塞接口的代码重复度其实很高，可以通过加一个参数来合并两个接口。</li>\n<li>该模板完全的左值传入，有一定的性能的开销，可以修改一下同时左值和右值传入。</li>\n</ol>\n<p>改良后的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadSafeQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">ThreadSafeQueue</span><span class=\"params\">(<span class=\"type\">size_t</span> capacity)</span> : capacity_(capacity), head_(<span class=\"number\">0</span>), tail_(<span class=\"number\">0</span>) &#123;</span></span><br><span class=\"line\">        data_.<span class=\"built_in\">resize</span>(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的入队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Enqueue</span><span class=\"params\">(U&amp;&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> nextTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            nextTail = (currentTail + <span class=\"number\">1</span>) % capacity_;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextTail == head_.<span class=\"built_in\">load</span>(std::memory_order_acquire)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!tail_.<span class=\"built_in\">compare_exchange_weak</span>(currentTail, nextTail, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行写入操作</span></span><br><span class=\"line\">        data_[currentTail] = std::forward&lt;U&gt;(item);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通用的出队操作</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Dequeue</span><span class=\"params\">(U&amp; item, <span class=\"type\">bool</span> blocking = <span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentHead;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> currentTail;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            currentHead = head_.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">            currentTail = tail_.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentHead == currentTail) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (blocking) &#123;</span><br><span class=\"line\">                    std::this_thread::<span class=\"built_in\">yield</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">// 如果是非阻塞模式，直接返回失败</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 尝试使用CAS进行原子操作</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!head_.<span class=\"built_in\">compare_exchange_weak</span>(currentHead, (currentHead + <span class=\"number\">1</span>) % capacity_, std::memory_order_acq_rel));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// CAS成功，可以进行读取操作</span></span><br><span class=\"line\">        item = std::<span class=\"built_in\">move</span>(data_[currentHead]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::vector&lt;T&gt; data_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; head_;</span><br><span class=\"line\">    std::atomic&lt;<span class=\"type\">size_t</span>&gt; tail_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"共享内存（二）：POSIX Api","date":"2024-02-02T06:31:42.000Z","_content":"POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。\n# POSIX Api简介\nPOSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在/dev/shm下创建一个文件，并将其mmap之后映射其内存地址即可。\n# mmap系列函数简介\nmmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。\n## mmap函数主要的作用\n\n- 对普通文件提供内存映射I/O，可以提供无亲缘进程间的通信；\n- 提供匿名内存映射，以供亲缘进程间进行通信。\n-  对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。\n## mmap函数主要的API\n### mmap 映射内存\nmmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。\n```cpp\n/**\n* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址\n* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0\n* prot：内存映射区的保护由该参数来设定\n* \tPROT_READ：数据可读\n* \tPROT_WRITE：数据可写\n* \tPROT_EXEC：数据可执行\n* \tPROT_NONE：数据不可访问\n* flags：设置内存映射区的类型标志\n* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象\n* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象\n*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志\n*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制\n* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1\n* offset：相对文件的起始偏移\n*/\nvoid *mmap(void *start, \n           size_t len, \n           int prot, \n           int flags, \n           int fd, \n           off_t offset);\n```\n\n![image.png](/images/shared-mem/2.png)\n### munmap删除映射\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n*/\nint munmap(void *start, size_t len);\n```\n### msync实时同步\n对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n* flags：同步标志\n*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；\n*\tMS_SYNC：同步写，要等到写操作完成后才返回。\n*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。\n*/\nint msync(void *start, size_t len, int flags);\n```\n## mmap实现线程中通信\n### 通过匿名内存映射提供亲缘进程间的通信\n我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。\n在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。\n简化测试代码：\n```cpp\nint main(int argc, char **argv)\n{\n    int *memPtr;\n    memPtr = (int *) mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, 0, 0);\n    if (memPtr == MAP_FAILED)\treturn -1;\n    *memPtr = 0;\n    if (fork() == 0)\n    {\n        *memPtr = 1;\n        cout<<\"child:set memory \"<<*memPtr<<endl;\n        exit(0);\n    }\n    sleep(1);\n    cout<<\"parent:memory value \"<<*memPtr<<endl;\n    return 0;\n}\n```\n### 通过内存映射文件提供无亲缘进程间的通信\n通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。\n简化测试代码：\n```cpp\n//process 1\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(int));\n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    *memPtr = 111;\n\tcout<<\"process:\"<<getpid()<<\" send:\"<<*memPtr<<endl;\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    cout<<\"process:\"<<getpid()<<\" receive:\"<<*memPtr<<endl;\n \n    return 0;\n}\n```\n# 基于mmap的POSIX共享内存\n## 具体步骤\n\n1. 通过shm_open创建或打开一个POSIX共享内存对象\n2. 然后调用mmap将它映射到当前进程的地址空间\n## POSIX共享内存底层支撑对象\n![image.png](/images/shared-mem/3.png)\n### 内存映射文件(memory-mapped file)\n由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。\n### 主流：共享内存区对象(shared-memory object)\n由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。\n## 共享内存区对象API\n### shm_open打开共享内存区\nshm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。\n```cpp\n/**\n* name：POSIX IPC的名字\n* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。\n* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项\n* mode：用于设置创建的共享内存区对象的权限属性。\n* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0\n*/\nint shm_open(const char *name, int oflag, mode_t mode);\n```\n### shm_unlink删除共享内存对象\nshm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。\n```cpp\nint shm_unlink(const char *name);\n```\n### 代码简单测试实例\n```cpp\n//process 1\n#define SHM_NAME \"/memmap\"\n#define SHM_NAME_SEM \"/memmap_sem\" \nchar sharedMem[10];\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR | O_CREAT, 0666);\n    sem = sem_open(SHM_NAME_SEM, O_CREAT, 0666, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(sharedMem));\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, sizeof(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    char msg[] = \"yuki...\";\n \n    memmove(memPtr, msg, sizeof(msg));\n    cout<<\"process:\"<<getpid()<<\" send:\"<<memPtr<<endl;\n \n    sem_post(sem);\n    sem_close(sem);\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR, 0);\n    sem = sem_open(SHM_NAME_SEM, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    struct stat fileStat;\n    fstat(fd, &fileStat);\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    sem_wait(sem);\n \n    cout<<\"process:\"<<getpid()<<\" recv:\"<<memPtr<<endl;\n \n    sem_close(sem);\n \n    return 0;\n}\n```\n\n","source":"_posts/Poxis-api.md","raw":"---\ntitle: 共享内存（二）：POSIX Api\ndate: 2024-02-02 14:31:42\ntags: 共享内存\n---\nPOSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。\n# POSIX Api简介\nPOSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在/dev/shm下创建一个文件，并将其mmap之后映射其内存地址即可。\n# mmap系列函数简介\nmmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。\n## mmap函数主要的作用\n\n- 对普通文件提供内存映射I/O，可以提供无亲缘进程间的通信；\n- 提供匿名内存映射，以供亲缘进程间进行通信。\n-  对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。\n## mmap函数主要的API\n### mmap 映射内存\nmmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。\n```cpp\n/**\n* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址\n* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0\n* prot：内存映射区的保护由该参数来设定\n* \tPROT_READ：数据可读\n* \tPROT_WRITE：数据可写\n* \tPROT_EXEC：数据可执行\n* \tPROT_NONE：数据不可访问\n* flags：设置内存映射区的类型标志\n* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象\n* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象\n*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志\n*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制\n* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1\n* offset：相对文件的起始偏移\n*/\nvoid *mmap(void *start, \n           size_t len, \n           int prot, \n           int flags, \n           int fd, \n           off_t offset);\n```\n\n![image.png](/images/shared-mem/2.png)\n### munmap删除映射\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n*/\nint munmap(void *start, size_t len);\n```\n### msync实时同步\n对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：\n```cpp\n/**\n* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址\n* len：映射区的大小\n* flags：同步标志\n*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；\n*\tMS_SYNC：同步写，要等到写操作完成后才返回。\n*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。\n*/\nint msync(void *start, size_t len, int flags);\n```\n## mmap实现线程中通信\n### 通过匿名内存映射提供亲缘进程间的通信\n我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。\n在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。\n简化测试代码：\n```cpp\nint main(int argc, char **argv)\n{\n    int *memPtr;\n    memPtr = (int *) mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, 0, 0);\n    if (memPtr == MAP_FAILED)\treturn -1;\n    *memPtr = 0;\n    if (fork() == 0)\n    {\n        *memPtr = 1;\n        cout<<\"child:set memory \"<<*memPtr<<endl;\n        exit(0);\n    }\n    sleep(1);\n    cout<<\"parent:memory value \"<<*memPtr<<endl;\n    return 0;\n}\n```\n### 通过内存映射文件提供无亲缘进程间的通信\n通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。\n简化测试代码：\n```cpp\n//process 1\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(int));\n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    *memPtr = 111;\n\tcout<<\"process:\"<<getpid()<<\" send:\"<<*memPtr<<endl;\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int *memPtr;\n    int fd;\n    fd = open(PATH_NAME, O_RDWR | O_CREAT, 0666);\n    if (fd < 0)\n    {\n        return -1;\n    }\n \n    memPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    if (memPtr == MAP_FAILED)\n    {\n        cout<<\"mmap failed...\"<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    cout<<\"process:\"<<getpid()<<\" receive:\"<<*memPtr<<endl;\n \n    return 0;\n}\n```\n# 基于mmap的POSIX共享内存\n## 具体步骤\n\n1. 通过shm_open创建或打开一个POSIX共享内存对象\n2. 然后调用mmap将它映射到当前进程的地址空间\n## POSIX共享内存底层支撑对象\n![image.png](/images/shared-mem/3.png)\n### 内存映射文件(memory-mapped file)\n由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。\n### 主流：共享内存区对象(shared-memory object)\n由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。\n## 共享内存区对象API\n### shm_open打开共享内存区\nshm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。\n```cpp\n/**\n* name：POSIX IPC的名字\n* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。\n* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项\n* mode：用于设置创建的共享内存区对象的权限属性。\n* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0\n*/\nint shm_open(const char *name, int oflag, mode_t mode);\n```\n### shm_unlink删除共享内存对象\nshm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。\n```cpp\nint shm_unlink(const char *name);\n```\n### 代码简单测试实例\n```cpp\n//process 1\n#define SHM_NAME \"/memmap\"\n#define SHM_NAME_SEM \"/memmap_sem\" \nchar sharedMem[10];\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR | O_CREAT, 0666);\n    sem = sem_open(SHM_NAME_SEM, O_CREAT, 0666, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    ftruncate(fd, sizeof(sharedMem));\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, sizeof(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    char msg[] = \"yuki...\";\n \n    memmove(memPtr, msg, sizeof(msg));\n    cout<<\"process:\"<<getpid()<<\" send:\"<<memPtr<<endl;\n \n    sem_post(sem);\n    sem_close(sem);\n \n    return 0;\n}\n \n//process 2\nint main()\n{\n    int fd;\n    sem_t *sem;\n \n    fd = shm_open(SHM_NAME, O_RDWR, 0);\n    sem = sem_open(SHM_NAME_SEM, 0);\n \n    if (fd < 0 || sem == SEM_FAILED)\n    {\n        cout<<\"shm_open or sem_open failed...\";\n        cout<<strerror(errno)<<endl;\n        return -1;\n    }\n \n    struct stat fileStat;\n    fstat(fd, &fileStat);\n \n    char *memPtr;\n    memPtr = (char *)mmap(NULL, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    close(fd);\n \n    sem_wait(sem);\n \n    cout<<\"process:\"<<getpid()<<\" recv:\"<<memPtr<<endl;\n \n    sem_close(sem);\n \n    return 0;\n}\n```\n\n","slug":"Poxis-api","published":1,"updated":"2024-02-02T06:44:33.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4a5r4h0000pjx585w7f6ng","content":"<p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。</p>\n<h1 id=\"POSIX-Api简介\"><a href=\"#POSIX-Api简介\" class=\"headerlink\" title=\"POSIX Api简介\"></a>POSIX Api简介</h1><p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在&#x2F;dev&#x2F;shm下创建一个文件，并将其mmap之后映射其内存地址即可。</p>\n<h1 id=\"mmap系列函数简介\"><a href=\"#mmap系列函数简介\" class=\"headerlink\" title=\"mmap系列函数简介\"></a>mmap系列函数简介</h1><p>mmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。</p>\n<h2 id=\"mmap函数主要的作用\"><a href=\"#mmap函数主要的作用\" class=\"headerlink\" title=\"mmap函数主要的作用\"></a>mmap函数主要的作用</h2><ul>\n<li>对普通文件提供内存映射I&#x2F;O，可以提供无亲缘进程间的通信；</li>\n<li>提供匿名内存映射，以供亲缘进程间进行通信。</li>\n<li>对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。</li>\n</ul>\n<h2 id=\"mmap函数主要的API\"><a href=\"#mmap函数主要的API\" class=\"headerlink\" title=\"mmap函数主要的API\"></a>mmap函数主要的API</h2><h3 id=\"mmap-映射内存\"><a href=\"#mmap-映射内存\" class=\"headerlink\" title=\"mmap 映射内存\"></a>mmap 映射内存</h3><p>mmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0</span></span><br><span class=\"line\"><span class=\"comment\">* prot：内存映射区的保护由该参数来设定</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_READ：数据可读</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_WRITE：数据可写</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_EXEC：数据可执行</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_NONE：数据不可访问</span></span><br><span class=\"line\"><span class=\"comment\">* flags：设置内存映射区的类型标志</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制</span></span><br><span class=\"line\"><span class=\"comment\">* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1</span></span><br><span class=\"line\"><span class=\"comment\">* offset：相对文件的起始偏移</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">size_t</span> len, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> prot, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> flags, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> fd, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/shared-mem/2.png\" alt=\"image.png\"></p>\n<h3 id=\"munmap删除映射\"><a href=\"#munmap删除映射\" class=\"headerlink\" title=\"munmap删除映射\"></a>munmap删除映射</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"msync实时同步\"><a href=\"#msync实时同步\" class=\"headerlink\" title=\"msync实时同步\"></a>msync实时同步</h3><p>对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">* flags：同步标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_SYNC：同步写，要等到写操作完成后才返回。</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">msync</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mmap实现线程中通信\"><a href=\"#mmap实现线程中通信\" class=\"headerlink\" title=\"mmap实现线程中通信\"></a>mmap实现线程中通信</h2><h3 id=\"通过匿名内存映射提供亲缘进程间的通信\"><a href=\"#通过匿名内存映射提供亲缘进程间的通信\" class=\"headerlink\" title=\"通过匿名内存映射提供亲缘进程间的通信\"></a>通过匿名内存映射提供亲缘进程间的通信</h3><p>我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。<br>在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *) <span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    *memPtr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fork() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *memPtr = <span class=\"number\">1</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;child:set memory &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;parent:memory value &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过内存映射文件提供无亲缘进程间的通信\"><a href=\"#通过内存映射文件提供无亲缘进程间的通信\" class=\"headerlink\" title=\"通过内存映射文件提供无亲缘进程间的通信\"></a>通过内存映射文件提供无亲缘进程间的通信</h3><p>通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    *memPtr = <span class=\"number\">111</span>;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; receive:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基于mmap的POSIX共享内存\"><a href=\"#基于mmap的POSIX共享内存\" class=\"headerlink\" title=\"基于mmap的POSIX共享内存\"></a>基于mmap的POSIX共享内存</h1><h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><ol>\n<li>通过shm_open创建或打开一个POSIX共享内存对象</li>\n<li>然后调用mmap将它映射到当前进程的地址空间</li>\n</ol>\n<h2 id=\"POSIX共享内存底层支撑对象\"><a href=\"#POSIX共享内存底层支撑对象\" class=\"headerlink\" title=\"POSIX共享内存底层支撑对象\"></a>POSIX共享内存底层支撑对象</h2><p><img src=\"/images/shared-mem/3.png\" alt=\"image.png\"></p>\n<h3 id=\"内存映射文件-memory-mapped-file\"><a href=\"#内存映射文件-memory-mapped-file\" class=\"headerlink\" title=\"内存映射文件(memory-mapped file)\"></a>内存映射文件(memory-mapped file)</h3><p>由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。</p>\n<h3 id=\"主流：共享内存区对象-shared-memory-object\"><a href=\"#主流：共享内存区对象-shared-memory-object\" class=\"headerlink\" title=\"主流：共享内存区对象(shared-memory object)\"></a>主流：共享内存区对象(shared-memory object)</h3><p>由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。</p>\n<h2 id=\"共享内存区对象API\"><a href=\"#共享内存区对象API\" class=\"headerlink\" title=\"共享内存区对象API\"></a>共享内存区对象API</h2><h3 id=\"shm-open打开共享内存区\"><a href=\"#shm-open打开共享内存区\" class=\"headerlink\" title=\"shm_open打开共享内存区\"></a>shm_open打开共享内存区</h3><p>shm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* name：POSIX IPC的名字</span></span><br><span class=\"line\"><span class=\"comment\">* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。</span></span><br><span class=\"line\"><span class=\"comment\">* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项</span></span><br><span class=\"line\"><span class=\"comment\">* mode：用于设置创建的共享内存区对象的权限属性。</span></span><br><span class=\"line\"><span class=\"comment\">* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">int</span> oflag, <span class=\"type\">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"shm-unlink删除共享内存对象\"><a href=\"#shm-unlink删除共享内存对象\" class=\"headerlink\" title=\"shm_unlink删除共享内存对象\"></a>shm_unlink删除共享内存对象</h3><p>shm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_unlink</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码简单测试实例\"><a href=\"#代码简单测试实例\" class=\"headerlink\" title=\"代码简单测试实例\"></a>代码简单测试实例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME <span class=\"string\">&quot;/memmap&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME_SEM <span class=\"string\">&quot;/memmap_sem&quot;</span> </span></span><br><span class=\"line\"><span class=\"type\">char</span> sharedMem[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, O_CREAT, <span class=\"number\">0666</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(sharedMem));</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;yuki...&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">memmove</span>(memPtr, msg, <span class=\"built_in\">sizeof</span>(msg));</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_post</span>(sem);</span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> fileStat;</span><br><span class=\"line\">    <span class=\"built_in\">fstat</span>(fd, &amp;fileStat);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_wait</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; recv:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。</p>\n<h1 id=\"POSIX-Api简介\"><a href=\"#POSIX-Api简介\" class=\"headerlink\" title=\"POSIX Api简介\"></a>POSIX Api简介</h1><p>POSIX本质上就是 mmap 对文件的共享方式映射，只不过映射的是 tmpfs 文件系统上的文件。tmpfs是Linux提供的一种“临时”的文件系统，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。Linux提供的POSIX共享内存，实际上就是在&#x2F;dev&#x2F;shm下创建一个文件，并将其mmap之后映射其内存地址即可。</p>\n<h1 id=\"mmap系列函数简介\"><a href=\"#mmap系列函数简介\" class=\"headerlink\" title=\"mmap系列函数简介\"></a>mmap系列函数简介</h1><p>mmap函数主要的功能就是将文件或设备映射到调用进程的地址空间中，当使用mmap映射文件到进程后,就可以直接操作这段虚拟地址进行文件的读写等操作,不必再调用read，write等系统调用。在很大程度上提高了系统的效率和代码的简洁性。</p>\n<h2 id=\"mmap函数主要的作用\"><a href=\"#mmap函数主要的作用\" class=\"headerlink\" title=\"mmap函数主要的作用\"></a>mmap函数主要的作用</h2><ul>\n<li>对普通文件提供内存映射I&#x2F;O，可以提供无亲缘进程间的通信；</li>\n<li>提供匿名内存映射，以供亲缘进程间进行通信。</li>\n<li>对shm_open创建的POSIX共享内存区对象进程内存映射，以供无亲缘进程间进行通信。</li>\n</ul>\n<h2 id=\"mmap函数主要的API\"><a href=\"#mmap函数主要的API\" class=\"headerlink\" title=\"mmap函数主要的API\"></a>mmap函数主要的API</h2><h3 id=\"mmap-映射内存\"><a href=\"#mmap-映射内存\" class=\"headerlink\" title=\"mmap 映射内存\"></a>mmap 映射内存</h3><p>mmap成功后，返回值即为fd映射到内存区的起始地址，之后可以关闭fd，一般也是这么做的，这对该内存映射没有任何影响。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：指定描述符fd应被映射到的进程地址空间内的起始地址，通常被设置为NULL，自动选择起始地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射到进程地址空间的字节数，它从被映射文件开头的第offset个字节处开始，offset通常被设置为0</span></span><br><span class=\"line\"><span class=\"comment\">* prot：内存映射区的保护由该参数来设定</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_READ：数据可读</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_WRITE：数据可写</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_EXEC：数据可执行</span></span><br><span class=\"line\"><span class=\"comment\">* \tPROT_NONE：数据不可访问</span></span><br><span class=\"line\"><span class=\"comment\">* flags：设置内存映射区的类型标志</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_SHARED：表示调用进程对被映射内存区的数据所做的修改对于共享该内存区的所有进程都可见，而且确实改变其底层的支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">* \tMAP_PRIVATE：调用进程对被映射内存区的数据所做的修改只对该进程可见，而不改变其底层支撑对象</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_FIXED：该标志表示准确的解释start参数，一般不建议使用该标志，对于可移植的代码，应该把start参数置为NULL，且不指定MAP_FIXED标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMAP_ANON：Linux中定义的非标准参数，提供匿名内存映射机制</span></span><br><span class=\"line\"><span class=\"comment\">* fd：有效的文件描述符。如果设定了MAP_ANONYMOUS（MAP_ANON）标志，在Linux下面会忽略fd参数，而有的系统实现如BSD需要置fd为-1</span></span><br><span class=\"line\"><span class=\"comment\">* offset：相对文件的起始偏移</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">size_t</span> len, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> prot, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> flags, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">int</span> fd, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/shared-mem/2.png\" alt=\"image.png\"></p>\n<h3 id=\"munmap删除映射\"><a href=\"#munmap删除映射\" class=\"headerlink\" title=\"munmap删除映射\"></a>munmap删除映射</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"msync实时同步\"><a href=\"#msync实时同步\" class=\"headerlink\" title=\"msync实时同步\"></a>msync实时同步</h3><p>对于一个MAP_SHARED的内存映射区，内核的虚拟内存算法会保持内存映射文件和内存映射区的同步，也就是说，对于内存映射文件所对应内存映射区的修改，内核会在稍后的某个时刻更新该内存映射文件。如果我们希望硬盘上的文件内容和内存映射区中的内容实时一致，那么我们就可以调用msync开执行这种同步：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* start：被映射到的进程地址空间的内存区的起始地址，即mmap返回的地址</span></span><br><span class=\"line\"><span class=\"comment\">* len：映射区的大小</span></span><br><span class=\"line\"><span class=\"comment\">* flags：同步标志</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_ASYNC：异步写，一旦写操作由内核排入队列，就立刻返回；</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_SYNC：同步写，要等到写操作完成后才返回。</span></span><br><span class=\"line\"><span class=\"comment\">*\tMS_INVALIDATE：使该文件的其他内存映射的副本全部失效。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">msync</span><span class=\"params\">(<span class=\"type\">void</span> *start, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mmap实现线程中通信\"><a href=\"#mmap实现线程中通信\" class=\"headerlink\" title=\"mmap实现线程中通信\"></a>mmap实现线程中通信</h2><h3 id=\"通过匿名内存映射提供亲缘进程间的通信\"><a href=\"#通过匿名内存映射提供亲缘进程间的通信\" class=\"headerlink\" title=\"通过匿名内存映射提供亲缘进程间的通信\"></a>通过匿名内存映射提供亲缘进程间的通信</h3><p>我们可以通过在父进程fork之前指定MAP_SHARED调用mmap，通过映射一个文件来实现父子进程间的通信，POSIX保证了父进程的内存映射关系保留到子进程中，父子进程对内存映射区的修改双方都可以看到。<br>在Linux 2.4以后，mmap提供匿名内存映射机制，即将mmap的flags参数指定为：MAP_SHARED | MAP_ANON。这样就彻底避免了内存映射文件的创建和打开，简化了对文件的操作。匿名内存映射机制的目的就是为了提供一个穿越父子进程间的内存映射区，很方便的提供了亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *) <span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    *memPtr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fork() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *memPtr = <span class=\"number\">1</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;child:set memory &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;parent:memory value &quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过内存映射文件提供无亲缘进程间的通信\"><a href=\"#通过内存映射文件提供无亲缘进程间的通信\" class=\"headerlink\" title=\"通过内存映射文件提供无亲缘进程间的通信\"></a>通过内存映射文件提供无亲缘进程间的通信</h3><p>通过在不同进程间对同一内存映射文件进行映射，来进行无亲缘进程间的通信。<br>简化测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    *memPtr = <span class=\"number\">111</span>;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *memPtr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    fd = <span class=\"built_in\">open</span>(PATH_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    memPtr = (<span class=\"type\">int</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memPtr == MAP_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mmap failed...&quot;</span>&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; receive:&quot;</span>&lt;&lt;*memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基于mmap的POSIX共享内存\"><a href=\"#基于mmap的POSIX共享内存\" class=\"headerlink\" title=\"基于mmap的POSIX共享内存\"></a>基于mmap的POSIX共享内存</h1><h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><ol>\n<li>通过shm_open创建或打开一个POSIX共享内存对象</li>\n<li>然后调用mmap将它映射到当前进程的地址空间</li>\n</ol>\n<h2 id=\"POSIX共享内存底层支撑对象\"><a href=\"#POSIX共享内存底层支撑对象\" class=\"headerlink\" title=\"POSIX共享内存底层支撑对象\"></a>POSIX共享内存底层支撑对象</h2><p><img src=\"/images/shared-mem/3.png\" alt=\"image.png\"></p>\n<h3 id=\"内存映射文件-memory-mapped-file\"><a href=\"#内存映射文件-memory-mapped-file\" class=\"headerlink\" title=\"内存映射文件(memory-mapped file)\"></a>内存映射文件(memory-mapped file)</h3><p>由open函数打开，由mmap函数把所得到的描述符映射到当前进程空间地址中的一个文件。共享的数据载体是物理文件。</p>\n<h3 id=\"主流：共享内存区对象-shared-memory-object\"><a href=\"#主流：共享内存区对象-shared-memory-object\" class=\"headerlink\" title=\"主流：共享内存区对象(shared-memory object)\"></a>主流：共享内存区对象(shared-memory object)</h3><p>由shm_open函数打开一个Posix.1 IPC名字，所返回的描述符由mmap函数映射到当前进程的地址空间。共享的数据载体是物理内存。</p>\n<h2 id=\"共享内存区对象API\"><a href=\"#共享内存区对象API\" class=\"headerlink\" title=\"共享内存区对象API\"></a>共享内存区对象API</h2><h3 id=\"shm-open打开共享内存区\"><a href=\"#shm-open打开共享内存区\" class=\"headerlink\" title=\"shm_open打开共享内存区\"></a>shm_open打开共享内存区</h3><p>shm_open用于创建一个新的共享内存区对象或打开一个已经存在的共享内存区对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* name：POSIX IPC的名字</span></span><br><span class=\"line\"><span class=\"comment\">* oflag：操作标志，包含：O_RDONLY，O_RDWR，O_CREAT，O_EXCL，O_TRUNC。</span></span><br><span class=\"line\"><span class=\"comment\">* 其中O_RDONLY和O_RDWR标志必须且仅能存在一项</span></span><br><span class=\"line\"><span class=\"comment\">* mode：用于设置创建的共享内存区对象的权限属性。</span></span><br><span class=\"line\"><span class=\"comment\">* 该参数必须一直存在，如果oflag参数中没有O_CREAT标志，该位可以置0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">int</span> oflag, <span class=\"type\">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"shm-unlink删除共享内存对象\"><a href=\"#shm-unlink删除共享内存对象\" class=\"headerlink\" title=\"shm_unlink删除共享内存对象\"></a>shm_unlink删除共享内存对象</h3><p>shm_unlink用于删除一个共享内存区对象，跟其他文件的unlink以及其他POSIX IPC的删除操作一样，对象的析构会到对该对象的所有引用全部关闭才会发生。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shm_unlink</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码简单测试实例\"><a href=\"#代码简单测试实例\" class=\"headerlink\" title=\"代码简单测试实例\"></a>代码简单测试实例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//process 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME <span class=\"string\">&quot;/memmap&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHM_NAME_SEM <span class=\"string\">&quot;/memmap_sem&quot;</span> </span></span><br><span class=\"line\"><span class=\"type\">char</span> sharedMem[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR | O_CREAT, <span class=\"number\">0666</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, O_CREAT, <span class=\"number\">0666</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">ftruncate</span>(fd, <span class=\"built_in\">sizeof</span>(sharedMem));</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(sharedMem), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;yuki...&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">memmove</span>(memPtr, msg, <span class=\"built_in\">sizeof</span>(msg));</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; send:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_post</span>(sem);</span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//process 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">sem_t</span> *sem;</span><br><span class=\"line\"> </span><br><span class=\"line\">    fd = <span class=\"built_in\">shm_open</span>(SHM_NAME, O_RDWR, <span class=\"number\">0</span>);</span><br><span class=\"line\">    sem = <span class=\"built_in\">sem_open</span>(SHM_NAME_SEM, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span> || sem == SEM_FAILED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;shm_open or sem_open failed...&quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">strerror</span>(errno)&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> fileStat;</span><br><span class=\"line\">    <span class=\"built_in\">fstat</span>(fd, &amp;fileStat);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">char</span> *memPtr;</span><br><span class=\"line\">    memPtr = (<span class=\"type\">char</span> *)<span class=\"built_in\">mmap</span>(<span class=\"literal\">NULL</span>, fileStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_wait</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;process:&quot;</span>&lt;&lt;<span class=\"built_in\">getpid</span>()&lt;&lt;<span class=\"string\">&quot; recv:&quot;</span>&lt;&lt;memPtr&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">sem_close</span>(sem);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"共享内存（一）：SystemV Api","date":"2024-02-02T06:31:01.000Z","_content":"SymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。\n#  基本API\n## shmget 获取共享内存 \n使用shmget函数获取共享内存，函数原型如下：\n```cpp\n/**\n* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源\n* 参数 size 指定创建的共享内存大小\n* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存\n* 函数调用成功时返回一个新建或已经存在的的共享内存标识符\n* 取决于shmflg的参数。失败返回-1，并设置错误码\n*/\nint shmget(key_t key, size_t size, int shmflg);\n```\nshmget函数返回的是一个标识符，而不是可用的内存地址。\n## shmat 关联共享内存\n使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：\n```cpp\n/**\n* 参数 shmid 是 shmget() 函数返回的标识符\n* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址\n* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段\n* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1\n*/\nvoid *shmat(int shmid, const void *shmaddr, int shmflg);\n```\n## shmdt 取消关联共享内存\n当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：\n```cpp\n/**\n* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值\n* 函数调用成功返回0，出错返回-1\n*/\nint shmdt(const void *shmaddr);\n```\n# 共享内存原理\n概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。\n![image.png](/images/shared-mem/1.png)\n在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。\n```cpp\n/**\n* 用于管理共享内存的信息\n*/\nstruct shmid_ds {\n struct ipc_perm  shm_perm; /* operation perms */\n int   shm_segsz; /* size of segment (bytes) */\n __kernel_time_t  shm_atime; /* last attach time */\n __kernel_time_t  shm_dtime; /* last detach time */\n __kernel_time_t  shm_ctime; /* last change time */\n __kernel_ipc_pid_t shm_cpid; /* pid of creator */\n __kernel_ipc_pid_t shm_lpid; /* pid of last operator */\n unsigned short  shm_nattch; /* no. of current attaches */\n unsigned short   shm_unused; /* compatibility */\n void    *shm_unused2; /* ditto - used by DIPC */\n void   *shm_unused3; /* unused */\n};\n\nstruct shmid_kernel\n{ \n struct shmid_ds  u;\n /* the following are private */\n unsigned long  shm_npages; /* size of segment (pages) */\n pte_t   *shm_pages; /* array of ptrs to frames -> SHMMAX */ \n struct vm_area_struct *attaches; /* descriptors for attaches */\n};\n\n/**\n* shm_segs数组 用于管理系统中所有的共享内存\n*/\nstatic struct shmid_kernel *shm_segs[SHMMNI]; // SHMMNI等于128\n```\n## shmget 函数实现\nshmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。\n```cpp\nasmlinkage long sys_shmget (key_t key, int size, int shmflg)\n{\n struct shmid_kernel *shp;\n int err, id = 0;\n\n down(&current->mm->mmap_sem);\n spin_lock(&shm_lock);\n if (size < 0 || size > shmmax) \n {\n      err = -EINVAL;\n } else if (key == IPC_PRIVATE) \n {\n      err = newseg(key, shmflg, size);\n } else if ((id = findkey (key)) == -1) \n {\n      if (!(shmflg & IPC_CREAT))\n           err = -ENOENT;\n      else\n           err = newseg(key, shmflg, size);\n } else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL)) \n {\n      err = -EEXIST;\n } else {\n      shp = shm_segs[id];\n      if (shp->u.shm_perm.mode & SHM_DEST)\n           err = -EIDRM;\n      else if (size > shp->u.shm_segsz)\n           err = -EINVAL;\n      else if (ipcperms (&shp->u.shm_perm, shmflg))\n           err = -EACCES;\n      else\n           err = (int) shp->u.shm_perm.seq * SHMMNI + id;\n }\n spin_unlock(&shm_lock);\n up(&current->mm->mmap_sem);\n return err;\n}\n```\n## shmat 函数实现\n```cpp\nasmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *raddr)\n{\n    struct shmid_kernel *shp;\n    struct vm_area_struct *shmd;\n    int err = -EINVAL;\n    unsigned int id;\n    unsigned long addr;\n    unsigned long len;\n\n    down(&current->mm->mmap_sem);\n    spin_lock(&shm_lock);\n    if (shmid < 0)\t\t\n        goto out;\n\n   /**\n   * 通过 shmid 标识符来找到共享内存描述符\n   * 系统中所有的共享内存到保存在 shm_segs 数组中\n   */\n    shp = shm_segs[id = (unsigned int) shmid % SHMMNI];\n    if (shp == IPC_UNUSED || shp == IPC_NOID)\t\t\n        goto out;\n   \n    /**\n    * 找到一个可用的虚拟内存地址\n    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址\n    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址\n    */\n    if (!(addr = (ulong) shmaddr)) {\n         if (shmflg & SHM_REMAP)\n              goto out;\n         err = -ENOMEM;\n         addr = 0;\n         again:\n             //获取一个空闲的虚拟内存空间\n             if (!(addr = get_unmapped_area(addr, shp->u.shm_segsz))) \n                  goto out;\n             if(addr & (SHMLBA - 1)) \n             {\n                  addr = (addr + (SHMLBA - 1)) & ~(SHMLBA - 1);\n                  goto again;\n              }\n    } else if (addr & (SHMLBA-1)) \n    {\n         if (shmflg & SHM_RND)\n              addr &= ~(SHMLBA-1);       /* round down */\n         else\n              goto out;\n    }\n   \n    /**\n    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，\n    * vm_area_struct 结构用于管理进程的虚拟内存空间\n    */\n    spin_unlock(&shm_lock);\n    err = -ENOMEM;\n    shmd = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);\n    spin_lock(&shm_lock);\n    if (!shmd)\n         goto out;\n    if ((shp != shm_segs[id]) || (shp->u.shm_perm.seq != (unsigned int) shmid / SHMMNI)) \n    {\n         kmem_cache_free(vm_area_cachep, shmd);\n         err = -EIDRM;\n         goto out;\n    }\n   \n    /**\n    * 设置刚创建的 vm_area_struct 结构的各个字段\n    */\n    shmd->vm_private_data = shm_segs + id;\n    shmd->vm_start = addr;\n    shmd->vm_end = addr + shp->shm_npages * PAGE_SIZE;\n    shmd->vm_mm = current->mm;\n    shmd->vm_page_prot = (shmflg & SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;\n    shmd->vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED\n       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC\n       | ((shmflg & SHM_RDONLY) ? 0 : VM_MAYWRITE | VM_WRITE);\n    shmd->vm_file = NULL;\n    shmd->vm_offset = 0;\n    //这个字段比较重要，数据结构如下\n    shmd->vm_ops = &shm_vm_ops;\n    //shm_vm_ops 的 nopage 回调为 shm_nopage() 函数\n    //当发生页缺失异常时将会调用此函数来恢复内存的映射\n    /**\n    * static struct vm_operations_struct shm_vm_ops = {\n    * \tshm_open,  //open - callback for a new vm-area open \n    * \tshm_close,  //close - callback for when the vm-area is released \n    * \tNULL,   //no need to sync pages at unmap \n    * \tNULL,   //protect \n    * \tNULL,   //sync \n    * \tNULL,   //advise \n    * \tshm_nopage,  //nopage \n    * \tNULL,   //wppage \n    * \tshm_swapout  //swapout \n    * };\n    */\n    shp->u.shm_nattch++;     /* prevent destruction */\n    spin_unlock(&shm_lock);\n    err = shm_map(shmd);\n    spin_lock(&shm_lock);\n    if (err)\n         goto failed_shm_map;\n\n    insert_attach(shp,shmd);  /* insert shmd into shp->attaches */\n\n    shp->u.shm_lpid = current->pid;\n    shp->u.shm_atime = CURRENT_TIME;\n\n    *raddr = addr;\n    err = 0;\n    out:\n        spin_unlock(&shm_lock);\n        up(&current->mm->mmap_sem);\n        return err;\n        ...\n}\n```\n从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。\n## shm_nopage 函数实现\nshm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。\n\n```cpp\nstatic struct page * shm_nopage(struct vm_area_struct * shmd, unsigned long address, int no_share)\n{\n    pte_t pte;\n    struct shmid_kernel *shp;\n    unsigned int idx;\n    struct page * page;\n\n    shp = *(struct shmid_kernel **) shmd->vm_private_data;\n    idx = (address - shmd->vm_start + shmd->vm_offset) >> PAGE_SHIFT;\n\n    spin_lock(&shm_lock);\n    again:\n        pte = shp->shm_pages[idx]; // 共享内存的页表项\n        if (!pte_present(pte)) \n        {   // 如果内存页不存在\n            if (pte_none(pte)) {\n                spin_unlock(&shm_lock);\n                page = get_free_highpage(GFP_HIGHUSER); // 申请一个新的物理内存页\n                if (!page)\n                    goto oom;\n                clear_highpage(page);\n                spin_lock(&shm_lock);\n                if (pte_val(pte) != pte_val(shp->shm_pages[idx]))\n                    goto changed;\n            } else {\n               ...\n            }\n            shm_rss++;\n            pte = pte_mkdirty(mk_pte(page, PAGE_SHARED));   // 创建页表项\n            shp->shm_pages[idx] = pte;                      // 保存共享内存的页表项\n        } else\n              --current->maj_flt;  /* was incremented in do_no_page */\n    done:\n        get_page(pte_page(pte));\n        spin_unlock(&shm_lock);\n        current->min_flt++;\n        return pte_page(pte);\n        ...\n}\n```\n","source":"_posts/Systemv-api.md","raw":"---\ntitle: 共享内存（一）：SystemV Api\ndate: 2024-02-02 14:31:01\ntags: 共享内存\n---\nSymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。\n#  基本API\n## shmget 获取共享内存 \n使用shmget函数获取共享内存，函数原型如下：\n```cpp\n/**\n* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源\n* 参数 size 指定创建的共享内存大小\n* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存\n* 函数调用成功时返回一个新建或已经存在的的共享内存标识符\n* 取决于shmflg的参数。失败返回-1，并设置错误码\n*/\nint shmget(key_t key, size_t size, int shmflg);\n```\nshmget函数返回的是一个标识符，而不是可用的内存地址。\n## shmat 关联共享内存\n使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：\n```cpp\n/**\n* 参数 shmid 是 shmget() 函数返回的标识符\n* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址\n* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段\n* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1\n*/\nvoid *shmat(int shmid, const void *shmaddr, int shmflg);\n```\n## shmdt 取消关联共享内存\n当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：\n```cpp\n/**\n* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值\n* 函数调用成功返回0，出错返回-1\n*/\nint shmdt(const void *shmaddr);\n```\n# 共享内存原理\n概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。\n![image.png](/images/shared-mem/1.png)\n在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。\n```cpp\n/**\n* 用于管理共享内存的信息\n*/\nstruct shmid_ds {\n struct ipc_perm  shm_perm; /* operation perms */\n int   shm_segsz; /* size of segment (bytes) */\n __kernel_time_t  shm_atime; /* last attach time */\n __kernel_time_t  shm_dtime; /* last detach time */\n __kernel_time_t  shm_ctime; /* last change time */\n __kernel_ipc_pid_t shm_cpid; /* pid of creator */\n __kernel_ipc_pid_t shm_lpid; /* pid of last operator */\n unsigned short  shm_nattch; /* no. of current attaches */\n unsigned short   shm_unused; /* compatibility */\n void    *shm_unused2; /* ditto - used by DIPC */\n void   *shm_unused3; /* unused */\n};\n\nstruct shmid_kernel\n{ \n struct shmid_ds  u;\n /* the following are private */\n unsigned long  shm_npages; /* size of segment (pages) */\n pte_t   *shm_pages; /* array of ptrs to frames -> SHMMAX */ \n struct vm_area_struct *attaches; /* descriptors for attaches */\n};\n\n/**\n* shm_segs数组 用于管理系统中所有的共享内存\n*/\nstatic struct shmid_kernel *shm_segs[SHMMNI]; // SHMMNI等于128\n```\n## shmget 函数实现\nshmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。\n```cpp\nasmlinkage long sys_shmget (key_t key, int size, int shmflg)\n{\n struct shmid_kernel *shp;\n int err, id = 0;\n\n down(&current->mm->mmap_sem);\n spin_lock(&shm_lock);\n if (size < 0 || size > shmmax) \n {\n      err = -EINVAL;\n } else if (key == IPC_PRIVATE) \n {\n      err = newseg(key, shmflg, size);\n } else if ((id = findkey (key)) == -1) \n {\n      if (!(shmflg & IPC_CREAT))\n           err = -ENOENT;\n      else\n           err = newseg(key, shmflg, size);\n } else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL)) \n {\n      err = -EEXIST;\n } else {\n      shp = shm_segs[id];\n      if (shp->u.shm_perm.mode & SHM_DEST)\n           err = -EIDRM;\n      else if (size > shp->u.shm_segsz)\n           err = -EINVAL;\n      else if (ipcperms (&shp->u.shm_perm, shmflg))\n           err = -EACCES;\n      else\n           err = (int) shp->u.shm_perm.seq * SHMMNI + id;\n }\n spin_unlock(&shm_lock);\n up(&current->mm->mmap_sem);\n return err;\n}\n```\n## shmat 函数实现\n```cpp\nasmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *raddr)\n{\n    struct shmid_kernel *shp;\n    struct vm_area_struct *shmd;\n    int err = -EINVAL;\n    unsigned int id;\n    unsigned long addr;\n    unsigned long len;\n\n    down(&current->mm->mmap_sem);\n    spin_lock(&shm_lock);\n    if (shmid < 0)\t\t\n        goto out;\n\n   /**\n   * 通过 shmid 标识符来找到共享内存描述符\n   * 系统中所有的共享内存到保存在 shm_segs 数组中\n   */\n    shp = shm_segs[id = (unsigned int) shmid % SHMMNI];\n    if (shp == IPC_UNUSED || shp == IPC_NOID)\t\t\n        goto out;\n   \n    /**\n    * 找到一个可用的虚拟内存地址\n    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址\n    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址\n    */\n    if (!(addr = (ulong) shmaddr)) {\n         if (shmflg & SHM_REMAP)\n              goto out;\n         err = -ENOMEM;\n         addr = 0;\n         again:\n             //获取一个空闲的虚拟内存空间\n             if (!(addr = get_unmapped_area(addr, shp->u.shm_segsz))) \n                  goto out;\n             if(addr & (SHMLBA - 1)) \n             {\n                  addr = (addr + (SHMLBA - 1)) & ~(SHMLBA - 1);\n                  goto again;\n              }\n    } else if (addr & (SHMLBA-1)) \n    {\n         if (shmflg & SHM_RND)\n              addr &= ~(SHMLBA-1);       /* round down */\n         else\n              goto out;\n    }\n   \n    /**\n    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，\n    * vm_area_struct 结构用于管理进程的虚拟内存空间\n    */\n    spin_unlock(&shm_lock);\n    err = -ENOMEM;\n    shmd = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);\n    spin_lock(&shm_lock);\n    if (!shmd)\n         goto out;\n    if ((shp != shm_segs[id]) || (shp->u.shm_perm.seq != (unsigned int) shmid / SHMMNI)) \n    {\n         kmem_cache_free(vm_area_cachep, shmd);\n         err = -EIDRM;\n         goto out;\n    }\n   \n    /**\n    * 设置刚创建的 vm_area_struct 结构的各个字段\n    */\n    shmd->vm_private_data = shm_segs + id;\n    shmd->vm_start = addr;\n    shmd->vm_end = addr + shp->shm_npages * PAGE_SIZE;\n    shmd->vm_mm = current->mm;\n    shmd->vm_page_prot = (shmflg & SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;\n    shmd->vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED\n       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC\n       | ((shmflg & SHM_RDONLY) ? 0 : VM_MAYWRITE | VM_WRITE);\n    shmd->vm_file = NULL;\n    shmd->vm_offset = 0;\n    //这个字段比较重要，数据结构如下\n    shmd->vm_ops = &shm_vm_ops;\n    //shm_vm_ops 的 nopage 回调为 shm_nopage() 函数\n    //当发生页缺失异常时将会调用此函数来恢复内存的映射\n    /**\n    * static struct vm_operations_struct shm_vm_ops = {\n    * \tshm_open,  //open - callback for a new vm-area open \n    * \tshm_close,  //close - callback for when the vm-area is released \n    * \tNULL,   //no need to sync pages at unmap \n    * \tNULL,   //protect \n    * \tNULL,   //sync \n    * \tNULL,   //advise \n    * \tshm_nopage,  //nopage \n    * \tNULL,   //wppage \n    * \tshm_swapout  //swapout \n    * };\n    */\n    shp->u.shm_nattch++;     /* prevent destruction */\n    spin_unlock(&shm_lock);\n    err = shm_map(shmd);\n    spin_lock(&shm_lock);\n    if (err)\n         goto failed_shm_map;\n\n    insert_attach(shp,shmd);  /* insert shmd into shp->attaches */\n\n    shp->u.shm_lpid = current->pid;\n    shp->u.shm_atime = CURRENT_TIME;\n\n    *raddr = addr;\n    err = 0;\n    out:\n        spin_unlock(&shm_lock);\n        up(&current->mm->mmap_sem);\n        return err;\n        ...\n}\n```\n从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。\n## shm_nopage 函数实现\nshm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。\n\n```cpp\nstatic struct page * shm_nopage(struct vm_area_struct * shmd, unsigned long address, int no_share)\n{\n    pte_t pte;\n    struct shmid_kernel *shp;\n    unsigned int idx;\n    struct page * page;\n\n    shp = *(struct shmid_kernel **) shmd->vm_private_data;\n    idx = (address - shmd->vm_start + shmd->vm_offset) >> PAGE_SHIFT;\n\n    spin_lock(&shm_lock);\n    again:\n        pte = shp->shm_pages[idx]; // 共享内存的页表项\n        if (!pte_present(pte)) \n        {   // 如果内存页不存在\n            if (pte_none(pte)) {\n                spin_unlock(&shm_lock);\n                page = get_free_highpage(GFP_HIGHUSER); // 申请一个新的物理内存页\n                if (!page)\n                    goto oom;\n                clear_highpage(page);\n                spin_lock(&shm_lock);\n                if (pte_val(pte) != pte_val(shp->shm_pages[idx]))\n                    goto changed;\n            } else {\n               ...\n            }\n            shm_rss++;\n            pte = pte_mkdirty(mk_pte(page, PAGE_SHARED));   // 创建页表项\n            shp->shm_pages[idx] = pte;                      // 保存共享内存的页表项\n        } else\n              --current->maj_flt;  /* was incremented in do_no_page */\n    done:\n        get_page(pte_page(pte));\n        spin_unlock(&shm_lock);\n        current->min_flt++;\n        return pte_page(pte);\n        ...\n}\n```\n","slug":"Systemv-api","published":1,"updated":"2024-02-02T06:42:56.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls4a5r4m0001pjx5g5thd3g9","content":"<p>SymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。</p>\n<h1 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h1><h2 id=\"shmget-获取共享内存\"><a href=\"#shmget-获取共享内存\" class=\"headerlink\" title=\"shmget 获取共享内存\"></a>shmget 获取共享内存</h2><p>使用shmget函数获取共享内存，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 size 指定创建的共享内存大小</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功时返回一个新建或已经存在的的共享内存标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 取决于shmflg的参数。失败返回-1，并设置错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">size_t</span> size, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>shmget函数返回的是一个标识符，而不是可用的内存地址。</p>\n<h2 id=\"shmat-关联共享内存\"><a href=\"#shmat-关联共享内存\" class=\"headerlink\" title=\"shmat 关联共享内存\"></a>shmat 关联共享内存</h2><p>使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmid 是 shmget() 函数返回的标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmdt-取消关联共享内存\"><a href=\"#shmdt-取消关联共享内存\" class=\"headerlink\" title=\"shmdt 取消关联共享内存\"></a>shmdt 取消关联共享内存</h2><p>当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回0，出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"共享内存原理\"><a href=\"#共享内存原理\" class=\"headerlink\" title=\"共享内存原理\"></a>共享内存原理</h1><p>概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。<br><img src=\"/images/shared-mem/1.png\" alt=\"image.png\"><br>在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 用于管理共享内存的信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">ipc_perm</span>  shm_perm; <span class=\"comment\">/* operation perms */</span></span><br><span class=\"line\"> <span class=\"type\">int</span>   shm_segsz; <span class=\"comment\">/* size of segment (bytes) */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_atime; <span class=\"comment\">/* last attach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_dtime; <span class=\"comment\">/* last detach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_ctime; <span class=\"comment\">/* last change time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_cpid; <span class=\"comment\">/* pid of creator */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_lpid; <span class=\"comment\">/* pid of last operator */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>  shm_nattch; <span class=\"comment\">/* no. of current attaches */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>   shm_unused; <span class=\"comment\">/* compatibility */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>    *shm_unused2; <span class=\"comment\">/* ditto - used by DIPC */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>   *shm_unused3; <span class=\"comment\">/* unused */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span>  u;</span><br><span class=\"line\"> <span class=\"comment\">/* the following are private */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">long</span>  shm_npages; <span class=\"comment\">/* size of segment (pages) */</span></span><br><span class=\"line\"> <span class=\"type\">pte_t</span>   *shm_pages; <span class=\"comment\">/* array of ptrs to frames -&gt; SHMMAX */</span> </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *attaches; <span class=\"comment\">/* descriptors for attaches */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* shm_segs数组 用于管理系统中所有的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shm_segs[SHMMNI]; <span class=\"comment\">// SHMMNI等于128</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shmget-函数实现\"><a href=\"#shmget-函数实现\" class=\"headerlink\" title=\"shmget 函数实现\"></a>shmget 函数实现</h2><p>shmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmget</span> <span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">int</span> size, <span class=\"type\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\"> <span class=\"type\">int</span> err, id = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || size &gt; shmmax) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EINVAL;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == IPC_PRIVATE) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((id = <span class=\"built_in\">findkey</span> (key)) == <span class=\"number\">-1</span>) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(shmflg &amp; IPC_CREAT))</span><br><span class=\"line\">           err = -ENOENT;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((shmflg &amp; IPC_CREAT) &amp;&amp; (shmflg &amp; IPC_EXCL)) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EEXIST;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      shp = shm_segs[id];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shp-&gt;u.shm_perm.mode &amp; SHM_DEST)</span><br><span class=\"line\">           err = -EIDRM;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size &gt; shp-&gt;u.shm_segsz)</span><br><span class=\"line\">           err = -EINVAL;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">ipcperms</span> (&amp;shp-&gt;u.shm_perm, shmflg))</span><br><span class=\"line\">           err = -EACCES;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = (<span class=\"type\">int</span>) shp-&gt;u.shm_perm.seq * SHMMNI + id;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmat-函数实现\"><a href=\"#shmat-函数实现\" class=\"headerlink\" title=\"shmat 函数实现\"></a>shmat 函数实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmat</span> <span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">char</span> *shmaddr, <span class=\"type\">int</span> shmflg, ulong *raddr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *shmd;</span><br><span class=\"line\">    <span class=\"type\">int</span> err = -EINVAL;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shmid &lt; <span class=\"number\">0</span>)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过 shmid 标识符来找到共享内存描述符</span></span><br><span class=\"line\"><span class=\"comment\">   * 系统中所有的共享内存到保存在 shm_segs 数组中</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    shp = shm_segs[id = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid % SHMMNI];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shp == IPC_UNUSED || shp == IPC_NOID)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 找到一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(addr = (ulong) shmaddr)) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_REMAP)</span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">         err = -ENOMEM;</span><br><span class=\"line\">         addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">         again:</span><br><span class=\"line\">             <span class=\"comment\">//获取一个空闲的虚拟内存空间</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (!(addr = <span class=\"built_in\">get_unmapped_area</span>(addr, shp-&gt;u.shm_segsz))) </span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(addr &amp; (SHMLBA - <span class=\"number\">1</span>)) </span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                  addr = (addr + (SHMLBA - <span class=\"number\">1</span>)) &amp; ~(SHMLBA - <span class=\"number\">1</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> again;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (addr &amp; (SHMLBA<span class=\"number\">-1</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_RND)</span><br><span class=\"line\">              addr &amp;= ~(SHMLBA<span class=\"number\">-1</span>);       <span class=\"comment\">/* round down */</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，</span></span><br><span class=\"line\"><span class=\"comment\">    * vm_area_struct 结构用于管理进程的虚拟内存空间</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = -ENOMEM;</span><br><span class=\"line\">    shmd = <span class=\"built_in\">kmem_cache_alloc</span>(vm_area_cachep, SLAB_KERNEL);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shmd)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((shp != shm_segs[id]) || (shp-&gt;u.shm_perm.seq != (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid / SHMMNI)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"built_in\">kmem_cache_free</span>(vm_area_cachep, shmd);</span><br><span class=\"line\">         err = -EIDRM;</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 设置刚创建的 vm_area_struct 结构的各个字段</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shmd-&gt;vm_private_data = shm_segs + id;</span><br><span class=\"line\">    shmd-&gt;vm_start = addr;</span><br><span class=\"line\">    shmd-&gt;vm_end = addr + shp-&gt;shm_npages * PAGE_SIZE;</span><br><span class=\"line\">    shmd-&gt;vm_mm = current-&gt;mm;</span><br><span class=\"line\">    shmd-&gt;vm_page_prot = (shmflg &amp; SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;</span><br><span class=\"line\">    shmd-&gt;vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED</span><br><span class=\"line\">       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC</span><br><span class=\"line\">       | ((shmflg &amp; SHM_RDONLY) ? <span class=\"number\">0</span> : VM_MAYWRITE | VM_WRITE);</span><br><span class=\"line\">    shmd-&gt;vm_file = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    shmd-&gt;vm_offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这个字段比较重要，数据结构如下</span></span><br><span class=\"line\">    shmd-&gt;vm_ops = &amp;shm_vm_ops;</span><br><span class=\"line\">    <span class=\"comment\">//shm_vm_ops 的 nopage 回调为 shm_nopage() 函数</span></span><br><span class=\"line\">    <span class=\"comment\">//当发生页缺失异常时将会调用此函数来恢复内存的映射</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * static struct vm_operations_struct shm_vm_ops = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_open,  //open - callback for a new vm-area open </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_close,  //close - callback for when the vm-area is released </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //no need to sync pages at unmap </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //protect </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //sync </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //advise </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_nopage,  //nopage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //wppage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_swapout  //swapout </span></span><br><span class=\"line\"><span class=\"comment\">    * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shp-&gt;u.shm_nattch++;     <span class=\"comment\">/* prevent destruction */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = <span class=\"built_in\">shm_map</span>(shmd);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> failed_shm_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">insert_attach</span>(shp,shmd);  <span class=\"comment\">/* insert shmd into shp-&gt;attaches */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    shp-&gt;u.shm_lpid = current-&gt;pid;</span><br><span class=\"line\">    shp-&gt;u.shm_atime = CURRENT_TIME;</span><br><span class=\"line\"></span><br><span class=\"line\">    *raddr = addr;</span><br><span class=\"line\">    err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    out:</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。</p>\n<h2 id=\"shm-nopage-函数实现\"><a href=\"#shm-nopage-函数实现\" class=\"headerlink\" title=\"shm_nopage 函数实现\"></a>shm_nopage 函数实现</h2><p>shm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * <span class=\"built_in\">shm_nopage</span>(<span class=\"keyword\">struct</span> vm_area_struct * shmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address, <span class=\"type\">int</span> no_share)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">pte_t</span> pte;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * page;</span><br><span class=\"line\"></span><br><span class=\"line\">    shp = *(<span class=\"keyword\">struct</span> shmid_kernel **) shmd-&gt;vm_private_data;</span><br><span class=\"line\">    idx = (address - shmd-&gt;vm_start + shmd-&gt;vm_offset) &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    again:</span><br><span class=\"line\">        pte = shp-&gt;shm_pages[idx]; <span class=\"comment\">// 共享内存的页表项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">pte_present</span>(pte)) </span><br><span class=\"line\">        &#123;   <span class=\"comment\">// 如果内存页不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_none</span>(pte)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">                page = <span class=\"built_in\">get_free_highpage</span>(GFP_HIGHUSER); <span class=\"comment\">// 申请一个新的物理内存页</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> oom;</span><br><span class=\"line\">                <span class=\"built_in\">clear_highpage</span>(page);</span><br><span class=\"line\">                <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_val</span>(pte) != <span class=\"built_in\">pte_val</span>(shp-&gt;shm_pages[idx]))</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> changed;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            shm_rss++;</span><br><span class=\"line\">            pte = <span class=\"built_in\">pte_mkdirty</span>(<span class=\"built_in\">mk_pte</span>(page, PAGE_SHARED));   <span class=\"comment\">// 创建页表项</span></span><br><span class=\"line\">            shp-&gt;shm_pages[idx] = pte;                      <span class=\"comment\">// 保存共享内存的页表项</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">              --current-&gt;maj_flt;  <span class=\"comment\">/* was incremented in do_no_page */</span></span><br><span class=\"line\">    done:</span><br><span class=\"line\">        <span class=\"built_in\">get_page</span>(<span class=\"built_in\">pte_page</span>(pte));</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        current-&gt;min_flt++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pte_page</span>(pte);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>SymtemV Api是相对来说更为传统的共享内存接口组，更适用于需要底层控制的传统IPC场景。</p>\n<h1 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h1><h2 id=\"shmget-获取共享内存\"><a href=\"#shmget-获取共享内存\" class=\"headerlink\" title=\"shmget 获取共享内存\"></a>shmget 获取共享内存</h2><p>使用shmget函数获取共享内存，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 key 一般由 ftok() 函数生成，用于标识系统的唯一IPC资源</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 size 指定创建的共享内存大小</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 指定 shmget() 的动作，比如 IPC_CREAT 表示要创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功时返回一个新建或已经存在的的共享内存标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 取决于shmflg的参数。失败返回-1，并设置错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">size_t</span> size, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>shmget函数返回的是一个标识符，而不是可用的内存地址。</p>\n<h2 id=\"shmat-关联共享内存\"><a href=\"#shmat-关联共享内存\" class=\"headerlink\" title=\"shmat 关联共享内存\"></a>shmat 关联共享内存</h2><p>使用shmat函数把共享内存关联到某个虚拟内存地址上，函数原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmid 是 shmget() 函数返回的标识符</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmflg 若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr, <span class=\"type\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmdt-取消关联共享内存\"><a href=\"#shmdt-取消关联共享内存\" class=\"headerlink\" title=\"shmdt 取消关联共享内存\"></a>shmdt 取消关联共享内存</h2><p>当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 shmdt函数实现，原型如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 shmaddr 是要取消关联的虚拟内存地址，也就是 shmat() 函数返回的值</span></span><br><span class=\"line\"><span class=\"comment\">* 函数调用成功返回0，出错返回-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"共享内存原理\"><a href=\"#共享内存原理\" class=\"headerlink\" title=\"共享内存原理\"></a>共享内存原理</h1><p>概括而言，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的。<br><img src=\"/images/shared-mem/1.png\" alt=\"image.png\"><br>在Linux 内核中，每个共享内存都由一个名为 shmid_kernel 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 用于管理共享内存的信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">ipc_perm</span>  shm_perm; <span class=\"comment\">/* operation perms */</span></span><br><span class=\"line\"> <span class=\"type\">int</span>   shm_segsz; <span class=\"comment\">/* size of segment (bytes) */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_atime; <span class=\"comment\">/* last attach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_dtime; <span class=\"comment\">/* last detach time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_time_t</span>  shm_ctime; <span class=\"comment\">/* last change time */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_cpid; <span class=\"comment\">/* pid of creator */</span></span><br><span class=\"line\"> <span class=\"type\">__kernel_ipc_pid_t</span> shm_lpid; <span class=\"comment\">/* pid of last operator */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>  shm_nattch; <span class=\"comment\">/* no. of current attaches */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">short</span>   shm_unused; <span class=\"comment\">/* compatibility */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>    *shm_unused2; <span class=\"comment\">/* ditto - used by DIPC */</span></span><br><span class=\"line\"> <span class=\"type\">void</span>   *shm_unused3; <span class=\"comment\">/* unused */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_ds</span>  u;</span><br><span class=\"line\"> <span class=\"comment\">/* the following are private */</span></span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">long</span>  shm_npages; <span class=\"comment\">/* size of segment (pages) */</span></span><br><span class=\"line\"> <span class=\"type\">pte_t</span>   *shm_pages; <span class=\"comment\">/* array of ptrs to frames -&gt; SHMMAX */</span> </span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *attaches; <span class=\"comment\">/* descriptors for attaches */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* shm_segs数组 用于管理系统中所有的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shm_segs[SHMMNI]; <span class=\"comment\">// SHMMNI等于128</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shmget-函数实现\"><a href=\"#shmget-函数实现\" class=\"headerlink\" title=\"shmget 函数实现\"></a>shmget 函数实现</h2><p>shmget 函数的实现比较简单，首先调用 findkey  函数查找值为 key 的共享内存是否已经被创建，findkey 函数返回共享内存在 shm_segs 数组 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 newseg 函数创建新的共享内存。newseg 函数的实现也比较简单，就是创建一个新的 shmid_kernel 结构体，然后设置其各个字段的值，并且保存到 shm_segs 数组 中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmget</span> <span class=\"params\">(<span class=\"type\">key_t</span> key, <span class=\"type\">int</span> size, <span class=\"type\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\"> <span class=\"type\">int</span> err, id = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || size &gt; shmmax) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EINVAL;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == IPC_PRIVATE) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((id = <span class=\"built_in\">findkey</span> (key)) == <span class=\"number\">-1</span>) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(shmflg &amp; IPC_CREAT))</span><br><span class=\"line\">           err = -ENOENT;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = <span class=\"built_in\">newseg</span>(key, shmflg, size);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((shmflg &amp; IPC_CREAT) &amp;&amp; (shmflg &amp; IPC_EXCL)) </span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      err = -EEXIST;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      shp = shm_segs[id];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shp-&gt;u.shm_perm.mode &amp; SHM_DEST)</span><br><span class=\"line\">           err = -EIDRM;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size &gt; shp-&gt;u.shm_segsz)</span><br><span class=\"line\">           err = -EINVAL;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">ipcperms</span> (&amp;shp-&gt;u.shm_perm, shmflg))</span><br><span class=\"line\">           err = -EACCES;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           err = (<span class=\"type\">int</span>) shp-&gt;u.shm_perm.seq * SHMMNI + id;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\"> <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"shmat-函数实现\"><a href=\"#shmat-函数实现\" class=\"headerlink\" title=\"shmat 函数实现\"></a>shmat 函数实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"type\">long</span> <span class=\"title\">sys_shmat</span> <span class=\"params\">(<span class=\"type\">int</span> shmid, <span class=\"type\">char</span> *shmaddr, <span class=\"type\">int</span> shmflg, ulong *raddr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">vm_area_struct</span> *shmd;</span><br><span class=\"line\">    <span class=\"type\">int</span> err = -EINVAL;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">down</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shmid &lt; <span class=\"number\">0</span>)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过 shmid 标识符来找到共享内存描述符</span></span><br><span class=\"line\"><span class=\"comment\">   * 系统中所有的共享内存到保存在 shm_segs 数组中</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    shp = shm_segs[id = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid % SHMMNI];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shp == IPC_UNUSED || shp == IPC_NOID)\t\t</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 找到一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果在调用 shmat() 函数时没有指定了虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    * 那么就通过 get_unmapped_area() 函数来获取一个可用的虚拟内存地址</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(addr = (ulong) shmaddr)) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_REMAP)</span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">         err = -ENOMEM;</span><br><span class=\"line\">         addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">         again:</span><br><span class=\"line\">             <span class=\"comment\">//获取一个空闲的虚拟内存空间</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (!(addr = <span class=\"built_in\">get_unmapped_area</span>(addr, shp-&gt;u.shm_segsz))) </span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(addr &amp; (SHMLBA - <span class=\"number\">1</span>)) </span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                  addr = (addr + (SHMLBA - <span class=\"number\">1</span>)) &amp; ~(SHMLBA - <span class=\"number\">1</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">goto</span> again;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (addr &amp; (SHMLBA<span class=\"number\">-1</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (shmflg &amp; SHM_RND)</span><br><span class=\"line\">              addr &amp;= ~(SHMLBA<span class=\"number\">-1</span>);       <span class=\"comment\">/* round down */</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">              <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 通过调用 kmem_cache_alloc() 函数创建一个 vm_area_struct 结构，</span></span><br><span class=\"line\"><span class=\"comment\">    * vm_area_struct 结构用于管理进程的虚拟内存空间</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = -ENOMEM;</span><br><span class=\"line\">    shmd = <span class=\"built_in\">kmem_cache_alloc</span>(vm_area_cachep, SLAB_KERNEL);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shmd)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((shp != shm_segs[id]) || (shp-&gt;u.shm_perm.seq != (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>) shmid / SHMMNI)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         <span class=\"built_in\">kmem_cache_free</span>(vm_area_cachep, shmd);</span><br><span class=\"line\">         err = -EIDRM;</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 设置刚创建的 vm_area_struct 结构的各个字段</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shmd-&gt;vm_private_data = shm_segs + id;</span><br><span class=\"line\">    shmd-&gt;vm_start = addr;</span><br><span class=\"line\">    shmd-&gt;vm_end = addr + shp-&gt;shm_npages * PAGE_SIZE;</span><br><span class=\"line\">    shmd-&gt;vm_mm = current-&gt;mm;</span><br><span class=\"line\">    shmd-&gt;vm_page_prot = (shmflg &amp; SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;</span><br><span class=\"line\">    shmd-&gt;vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED</span><br><span class=\"line\">       | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC</span><br><span class=\"line\">       | ((shmflg &amp; SHM_RDONLY) ? <span class=\"number\">0</span> : VM_MAYWRITE | VM_WRITE);</span><br><span class=\"line\">    shmd-&gt;vm_file = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    shmd-&gt;vm_offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这个字段比较重要，数据结构如下</span></span><br><span class=\"line\">    shmd-&gt;vm_ops = &amp;shm_vm_ops;</span><br><span class=\"line\">    <span class=\"comment\">//shm_vm_ops 的 nopage 回调为 shm_nopage() 函数</span></span><br><span class=\"line\">    <span class=\"comment\">//当发生页缺失异常时将会调用此函数来恢复内存的映射</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * static struct vm_operations_struct shm_vm_ops = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_open,  //open - callback for a new vm-area open </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_close,  //close - callback for when the vm-area is released </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //no need to sync pages at unmap </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //protect </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //sync </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //advise </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_nopage,  //nopage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tNULL,   //wppage </span></span><br><span class=\"line\"><span class=\"comment\">    * \tshm_swapout  //swapout </span></span><br><span class=\"line\"><span class=\"comment\">    * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    shp-&gt;u.shm_nattch++;     <span class=\"comment\">/* prevent destruction */</span></span><br><span class=\"line\">    <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">    err = <span class=\"built_in\">shm_map</span>(shmd);</span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">         <span class=\"keyword\">goto</span> failed_shm_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">insert_attach</span>(shp,shmd);  <span class=\"comment\">/* insert shmd into shp-&gt;attaches */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    shp-&gt;u.shm_lpid = current-&gt;pid;</span><br><span class=\"line\">    shp-&gt;u.shm_atime = CURRENT_TIME;</span><br><span class=\"line\"></span><br><span class=\"line\">    *raddr = addr;</span><br><span class=\"line\">    err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    out:</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        <span class=\"built_in\">up</span>(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码可看出，shmat 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请。 事实上，当进程发生缺页异常的时候会调用 shm_nopage 函数来恢复进程的虚拟内存地址到物理内存地址的映射。</p>\n<h2 id=\"shm-nopage-函数实现\"><a href=\"#shm-nopage-函数实现\" class=\"headerlink\" title=\"shm_nopage 函数实现\"></a>shm_nopage 函数实现</h2><p>shm_nopage 函数是当发生内存缺页异常时被调用的，主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * <span class=\"built_in\">shm_nopage</span>(<span class=\"keyword\">struct</span> vm_area_struct * shmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address, <span class=\"type\">int</span> no_share)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">pte_t</span> pte;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">shmid_kernel</span> *shp;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">page</span> * page;</span><br><span class=\"line\"></span><br><span class=\"line\">    shp = *(<span class=\"keyword\">struct</span> shmid_kernel **) shmd-&gt;vm_private_data;</span><br><span class=\"line\">    idx = (address - shmd-&gt;vm_start + shmd-&gt;vm_offset) &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">    again:</span><br><span class=\"line\">        pte = shp-&gt;shm_pages[idx]; <span class=\"comment\">// 共享内存的页表项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">pte_present</span>(pte)) </span><br><span class=\"line\">        &#123;   <span class=\"comment\">// 如果内存页不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_none</span>(pte)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">                page = <span class=\"built_in\">get_free_highpage</span>(GFP_HIGHUSER); <span class=\"comment\">// 申请一个新的物理内存页</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> oom;</span><br><span class=\"line\">                <span class=\"built_in\">clear_highpage</span>(page);</span><br><span class=\"line\">                <span class=\"built_in\">spin_lock</span>(&amp;shm_lock);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">pte_val</span>(pte) != <span class=\"built_in\">pte_val</span>(shp-&gt;shm_pages[idx]))</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> changed;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            shm_rss++;</span><br><span class=\"line\">            pte = <span class=\"built_in\">pte_mkdirty</span>(<span class=\"built_in\">mk_pte</span>(page, PAGE_SHARED));   <span class=\"comment\">// 创建页表项</span></span><br><span class=\"line\">            shp-&gt;shm_pages[idx] = pte;                      <span class=\"comment\">// 保存共享内存的页表项</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">              --current-&gt;maj_flt;  <span class=\"comment\">/* was incremented in do_no_page */</span></span><br><span class=\"line\">    done:</span><br><span class=\"line\">        <span class=\"built_in\">get_page</span>(<span class=\"built_in\">pte_page</span>(pte));</span><br><span class=\"line\">        <span class=\"built_in\">spin_unlock</span>(&amp;shm_lock);</span><br><span class=\"line\">        current-&gt;min_flt++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pte_page</span>(pte);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"同步与阻塞概念的区别","date":"2024-02-05T05:31:33.000Z","_content":"sync/async这组概念和block/unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。\n# 直接解释\n## 同步/异步\n关注的是消息通信机制 (synchronous communication/ asynchronous communication) 。\n\n- 所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。\n- 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。\n## 阻塞/非阻塞\n关注的是程序在等待调用结果（消息，返回值）时的状态。\n\n- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n# 进程间的场景\n> 进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是**阻塞的**或**非阻塞的** – 也被称为**同步**或**异步**的\n\n从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对**发送方**和**接收方**作区分对待。\n\n- 阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。\n- 非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。\n- 阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。\n- 非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。\n# 系统调用的场景\n在 I/O 系统调用层面， **非阻塞 IO 系统调用 **和** 异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。\n\n- 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。\n- 而**异步I/O系统调用 read()** 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。\n# 结论\n因此，非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。\n","source":"_posts/Sync-and-block.md","raw":"---\ntitle: 同步与阻塞概念的区别\ndate: 2024-02-05 13:31:33\ntags: 随感杂记\n---\nsync/async这组概念和block/unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。\n# 直接解释\n## 同步/异步\n关注的是消息通信机制 (synchronous communication/ asynchronous communication) 。\n\n- 所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。\n- 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。\n## 阻塞/非阻塞\n关注的是程序在等待调用结果（消息，返回值）时的状态。\n\n- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n# 进程间的场景\n> 进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是**阻塞的**或**非阻塞的** – 也被称为**同步**或**异步**的\n\n从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对**发送方**和**接收方**作区分对待。\n\n- 阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。\n- 非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。\n- 阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。\n- 非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。\n# 系统调用的场景\n在 I/O 系统调用层面， **非阻塞 IO 系统调用 **和** 异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。\n\n- 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。\n- 而**异步I/O系统调用 read()** 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。\n# 结论\n因此，非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。\n","slug":"Sync-and-block","published":1,"updated":"2024-02-05T05:33:17.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8hy75u0000czx5b01l49t8","content":"<p>sync&#x2F;async这组概念和block&#x2F;unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。</p>\n<h1 id=\"直接解释\"><a href=\"#直接解释\" class=\"headerlink\" title=\"直接解释\"></a>直接解释</h1><h2 id=\"同步-异步\"><a href=\"#同步-异步\" class=\"headerlink\" title=\"同步&#x2F;异步\"></a>同步&#x2F;异步</h2><p>关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication) 。</p>\n<ul>\n<li>所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。</li>\n<li>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。</li>\n</ul>\n<h2 id=\"阻塞-非阻塞\"><a href=\"#阻塞-非阻塞\" class=\"headerlink\" title=\"阻塞&#x2F;非阻塞\"></a>阻塞&#x2F;非阻塞</h2><p>关注的是程序在等待调用结果（消息，返回值）时的状态。</p>\n<ul>\n<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>\n<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>\n</ul>\n<h1 id=\"进程间的场景\"><a href=\"#进程间的场景\" class=\"headerlink\" title=\"进程间的场景\"></a>进程间的场景</h1><blockquote>\n<p>进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是<strong>阻塞的</strong>或<strong>非阻塞的</strong> – 也被称为<strong>同步</strong>或<strong>异步</strong>的</p>\n</blockquote>\n<p>从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对<strong>发送方</strong>和<strong>接收方</strong>作区分对待。</p>\n<ul>\n<li>阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li>\n<li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li>\n<li>阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li>\n<li>非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li>\n</ul>\n<h1 id=\"系统调用的场景\"><a href=\"#系统调用的场景\" class=\"headerlink\" title=\"系统调用的场景\"></a>系统调用的场景</h1><p>在 I&#x2F;O 系统调用层面， <strong>非阻塞 IO 系统调用 <strong>和</strong> 异步 IO 系统调用</strong>存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。</p>\n<ul>\n<li>一个<strong>非阻塞I&#x2F;O 系统调用 read()</strong> 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li>\n<li>而<strong>异步I&#x2F;O系统调用 read()</strong> 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li>\n</ul>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>因此，非阻塞系统调用（non-blocking I&#x2F;O system call 与 asynchronous I&#x2F;O system call） 的存在可以用来实现线程级别的 I&#x2F;O 并发， 与通过多进程实现的 I&#x2F;O 并发相比可以减少内存消耗以及进程切换的开销。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>sync&#x2F;async这组概念和block&#x2F;unblock这组概念太过于相似，以至于很多时候混用它们。虽然有过于咬文嚼字的嫌疑，但还是写一下在我的理解中他们的区别。</p>\n<h1 id=\"直接解释\"><a href=\"#直接解释\" class=\"headerlink\" title=\"直接解释\"></a>直接解释</h1><h2 id=\"同步-异步\"><a href=\"#同步-异步\" class=\"headerlink\" title=\"同步&#x2F;异步\"></a>同步&#x2F;异步</h2><p>关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication) 。</p>\n<ul>\n<li>所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。</li>\n<li>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。</li>\n</ul>\n<h2 id=\"阻塞-非阻塞\"><a href=\"#阻塞-非阻塞\" class=\"headerlink\" title=\"阻塞&#x2F;非阻塞\"></a>阻塞&#x2F;非阻塞</h2><p>关注的是程序在等待调用结果（消息，返回值）时的状态。</p>\n<ul>\n<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>\n<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>\n</ul>\n<h1 id=\"进程间的场景\"><a href=\"#进程间的场景\" class=\"headerlink\" title=\"进程间的场景\"></a>进程间的场景</h1><blockquote>\n<p>进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是<strong>阻塞的</strong>或<strong>非阻塞的</strong> – 也被称为<strong>同步</strong>或<strong>异步</strong>的</p>\n</blockquote>\n<p>从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对<strong>发送方</strong>和<strong>接收方</strong>作区分对待。</p>\n<ul>\n<li>阻塞式发送（blocking send）。发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li>\n<li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li>\n<li>阻塞式接收（blocking receive）。 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li>\n<li>非阻塞式接受（nonblocking receive）。 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li>\n</ul>\n<h1 id=\"系统调用的场景\"><a href=\"#系统调用的场景\" class=\"headerlink\" title=\"系统调用的场景\"></a>系统调用的场景</h1><p>在 I&#x2F;O 系统调用层面， <strong>非阻塞 IO 系统调用 <strong>和</strong> 异步 IO 系统调用</strong>存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别。</p>\n<ul>\n<li>一个<strong>非阻塞I&#x2F;O 系统调用 read()</strong> 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li>\n<li>而<strong>异步I&#x2F;O系统调用 read()</strong> 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li>\n</ul>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>因此，非阻塞系统调用（non-blocking I&#x2F;O system call 与 asynchronous I&#x2F;O system call） 的存在可以用来实现线程级别的 I&#x2F;O 并发， 与通过多进程实现的 I&#x2F;O 并发相比可以减少内存消耗以及进程切换的开销。</p>\n"},{"title":"异步事件框架学习","date":"2024-02-05T05:44:59.000Z","_content":"最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。\n因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。\n# 核心构成\nevent-loop + 基于I/O或者其他事件通知的回调函数。\n在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：\n```cpp\nwhile there are still events to process:\n    e = get the next event\n    if there is a callback associated with e:\n        call the callback\n```\n# 异步实现\n## 需要非阻塞原因\n系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。\n## 解决方案一：多线程\n每一个阻塞的I/O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。\n## 解决方案二：异步\n现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。\n例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。\n异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。\n# 异步实现的基础\n为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。\n## epoll简介\nepoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：\n\n- 告诉系统帮助我们同时监控多个文件描述符\n- 当这其中的一个或者多个文件描述符的 I/O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）\n## epoll流程示例\n![image.png](/images/async-framework/1.png)\n使用伪代码写一个epoll的具体实现流程，即如下：\n```cpp\n// 创建 epoll 实例\nint epfd = epoll_create(MAX_EVENTS);\n// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`\nepoll_ctl_add(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);\n\nwhile(1) {\n  // 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时\n  // 由系统通知应用。通知的形式如下：\n  //\n  // epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生\n  // 变化时返回\n  //\n  // epoll_wait 调用返回后：\n  // nfds 表示发生变化的文件描述符数量\n  // events 会保存当前的事件，它的数量就是 nfds\n  int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);\n\n  // 遍历 events，对事件作出符合应用预期的响应\n  for (int i = 0; i < nfds; i++) {\n    consume events[i]\n  }\n}\n\n```\n## epoll的触发模式\n触发模式分为水平触发和边缘触发。\n### 名词来源\n触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。\n水平触发：在高低电压的峰谷值周期内部会激活对应的电路。![image.png](/images/async-framework/2.png)\n边缘触发：在高低电压变化的瞬间会激活对应的电路。![image.png](/images/async-framework/3.png)\n### epoll中触发模式实例\n比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。\n**如果是水平触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容\n\n**如果是边缘触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）\n- 系统唤醒我们的应用，此时缓冲区有 6 bytes = (4 + 2) bytes\n\n**对此场景下两种触发模式的理解：**\n水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；\n边缘触发，对应的是**状态的变化**，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。\n## epoll的局限性\nepoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。\n所以在实现异步操作框架时，一般会混合多种非阻塞手段：\n\n- 将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）\n- 对于可以利用系统调用的 IO 操作，优先使用统一后的 API\n- 对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API\n- 最后，将上面的细节封装在内部，对外提供统一的 API\n# 框架逻辑结构\n## 基础代码示例\n这个是一个异步事件框架的基本骨架，很重要。\n主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。\n```cpp\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r) uv__update_time(loop);\n\n  // 是循环，没错了\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    // 处理 timer 队列\n    uv__run_timers(loop);\n    // 处理 pending 队列\n    ran_pending = uv__run_pending(loop);\n    // 处理 idle 队列\n    uv__run_idle(loop);\n    // 处理 prepare 队列\n    uv__run_prepare(loop);\n\n    // 执行 io_poll\n    uv__io_poll(loop, timeout);\n    uv__metrics_update_idle_time(loop);\n\n    // 执行 check 队列\n    uv__run_check(loop);\n    // 执行 closing 队列\n    uv__run_closing_handles(loop);\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break;\n  }\n\n  return r;\n}\n```\n## 抽象的操作概念\nevent-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。\n### Handle\nHandle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。\n**handle的API如下：**\n因为是长期存在的操作，所以基本上会拥有三个步骤：初始化/开始/停止。\n```cpp\n// IO 操作\nint uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket);\nint uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nint uv_poll_stop(uv_poll_t* poll);\n\n// timer\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n### Requet\n**request的API如下：**\nrequst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。\n```cpp\nint uv_getaddrinfo\n(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, /* ... */);\n```\n### 联系\n Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。\n## 不同的回调队列\n### timer\ntimer存在以下三个API：\n```cpp\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n#### init\ninit没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。\n#### start\nstart内部做了如下的一些工作：\n```cpp\nint uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  // loop->time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值\n  // clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要\n  // 计算了，直接从 timers 中取符合条件的即可\n  if (clamped_timeout < timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle->timer_cb = cb;\n  handle->timeout = clamped_timeout;\n  handle->repeat = repeat;\n\n  // 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的\n  //自增 start_id 作为比较条件来觉得 handle 的执行先后顺序\n  handle->start_id = handle->loop->timer_counter++;\n\n  // 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是\n  // clamped_timeout 值（或者 start_id）最小的 handle\n  heap_insert(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的开始状态\n  uv__handle_start(handle);\n\n  return 0;\n}\n```\n#### stop\nstop内部做了如下的一些工作：\n```cpp\nint uv_timer_stop(uv_timer_t* handle) {\n  if (!uv__is_active(handle))\n    return 0;\n\n  // 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外\n  // 还会维护 timer_heap 以保障其始终是 binary min heap\n  heap_remove(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的状态为停止\n  uv__handle_stop(handle);\n\n  return 0;\n}\n```\n#### timers串联分析\nstart 和 stop 其实可以粗略地概括为，往属性 loop->timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。\n**整个timers的启动：**\n```cpp\nvoid uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    // 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个\n    heap_node = heap_min(timer_heap(loop));\n    if (heap_node == NULL)\n      break;\n\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle->timeout > loop->time)\n      break;\n\n    // 停止、移出 handle、顺便维护 timer_heap\n    uv_timer_stop(handle);\n    // 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中\n    // 会在下一次事件循环中、由本方法继续执行\n    uv_timer_again(handle);\n    // 执行超时 handle 其对应的回调\n    handle->timer_cb(handle);\n  }\n}\n```\n### pending\n#### pending数据结构\n使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。\n#### pending串联分析\n```cpp\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  // 不断从队列中弹出元素进行操作\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n```\n### idle，check，prepare\n这部分感觉不重要，思想上和pending大同小异，不重点看了。\n### io poll\n在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。\n```cpp\nvoid uv__io_poll(uv_loop_t* loop, int timeout) {\n  while (!QUEUE_EMPTY(&loop->watcher_queue)) {\n    // ...\n    // `loop->backend_fd` 是使用 `epoll_create` 创建的 epoll 实例\n    epoll_ctl(loop->backend_fd, op, w->fd, &e)\n    // ...\n  }\n\n  // ...\n  for (;;) {\n  // ...\n    if (/* ... */) {\n      // ...\n    } else {\n      // ...\n      // `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者\n      nfds = epoll_wait(loop->backend_fd,\n                        events,\n                        ARRAY_SIZE(events),\n                        timeout);\n      // ...\n    }\n  }\n  // ...\n\n  for (i = 0; i < nfds; i++) {\n    // ...\n    w = loop->watchers[fd];\n    // ...\n    w->cb(loop, w, pe->events);\n  }\n}\n```\n#### timeout参数\n**在epoll_wait中timeout参数的含义：**\n\n- 如果是 -1 表示一直等到有事件产生\n- 如果是 0 则立即返回，包含调用时产生的事件\n- 如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内\n\n**在epoll_wait中timeout参数的获得：**\n核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。\n 在uv__next_timeout 实现主要分为三部分：\n\n- 只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达\n- 当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer\n- 当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间\n```cpp\nint uv_backend_timeout(const uv_loop_t* loop) {\n  // 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环\n  if (loop->stop_flag != 0)\n    return 0;\n\n  // 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回\n  if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))\n    return 0;\n\n  // idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环\n  // 否则会导致 idle 产生过高的延迟\n  if (!QUEUE_EMPTY(&loop->idle_handles))\n    return 0;\n\n  // 和上一步目的一样，不过这里是换成了 pending 队列\n  if (!QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  // 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟\n  if (loop->closing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}\n\nint uv__next_timeout(const uv_loop_t* loop) {\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  heap_node = heap_min(timer_heap(loop));\n  // 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达\n  if (heap_node == NULL)\n    return -1; /* block indefinitely */\n\n  handle = container_of(heap_node, uv_timer_t, heap_node);\n  // 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`\n  // 尽快返回，以在下一个事件循环迭代内处理超时的 timer\n  if (handle->timeout <= loop->time)\n    return 0;\n\n  // 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间\n  // 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待\n  // epoll 事件\n  diff = handle->timeout - loop->time;\n  if (diff > INT_MAX)\n    diff = INT_MAX;\n\n  return (int) diff;\n}\n```\n### thread pool\n在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。\n#### init\n通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。\n```cpp\nvoid uv__work_submit(uv_loop_t* loop,\n                     struct uv__work* w,\n                     enum uv__work_kind kind,\n                     void (*work)(struct uv__work* w),\n                     void (*done)(struct uv__work* w, int status)) {\n  uv_once(&once, init_once);\n  // ...\n  post(&w->wq, kind);\n}\n```\ninit_once 内部会调用 init_threads 来完成线程池初始化工作。\n```cpp\nstatic uv_thread_t default_threads[4];\n\nstatic void init_threads(void) {\n  // ...\n  nthreads = ARRAY_SIZE(default_threads);\n  val = getenv(\"UV_THREADPOOL_SIZE\");\n  // ...\n  for (i = 0; i < nthreads; i++)\n    if (uv_thread_create(threads + i, worker, &sem))\n      abort();\n  // ...\n}\n```\n#### post\n还是uv__work_submit 方法，内部通过post函数完成任务的提交。\n提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。\n```cpp\nstatic void post(QUEUE* q, enum uv__work_kind kind) {\n  uv_mutex_lock(&mutex);\n  // ...\n  // 将任务插入到 `wq` 这个线程共享的队列中\n  QUEUE_INSERT_TAIL(&wq, q);\n  // 如果有空闲线程，则通知它们开始工作\n  if (idle_threads > 0)\n    uv_cond_signal(&cond);\n  uv_mutex_unlock(&mutex);\n}\n```\n#### 更多逻辑\n线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。\n### closing\n通过closing队列来实现对长操作handle的关闭操作。\n调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。\n```cpp\nvoid uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!uv__is_closing(handle));\n\n  handle->flags |= UV_HANDLE_CLOSING;\n  handle->close_cb = close_cb;\n\n  switch (handle->type) {\n  // 根据不同的 handle 类型，执行各自的资源回收工作\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n  // ...\n\n  default:\n    assert(0);\n  }\n  \n  // 添加到 `loop->closing_handles`\n  uv__make_close_pending(handle);\n}\n\nvoid uv__make_close_pending(uv_handle_t* handle) {\n  assert(handle->flags & UV_HANDLE_CLOSING);\n  assert(!(handle->flags & UV_HANDLE_CLOSED));\n  handle->next_closing = handle->loop->closing_handles;\n  handle->loop->closing_handles = handle;\n}\n```\n","source":"_posts/Async-framework.md","raw":"---\ntitle: 异步事件框架学习\ndate: 2024-02-05 13:44:59\ntags: 学习笔记\n---\n最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。\n因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。\n# 核心构成\nevent-loop + 基于I/O或者其他事件通知的回调函数。\n在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：\n```cpp\nwhile there are still events to process:\n    e = get the next event\n    if there is a callback associated with e:\n        call the callback\n```\n# 异步实现\n## 需要非阻塞原因\n系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。\n## 解决方案一：多线程\n每一个阻塞的I/O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。\n## 解决方案二：异步\n现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。\n例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。\n异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。\n# 异步实现的基础\n为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。\n## epoll简介\nepoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：\n\n- 告诉系统帮助我们同时监控多个文件描述符\n- 当这其中的一个或者多个文件描述符的 I/O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）\n## epoll流程示例\n![image.png](/images/async-framework/1.png)\n使用伪代码写一个epoll的具体实现流程，即如下：\n```cpp\n// 创建 epoll 实例\nint epfd = epoll_create(MAX_EVENTS);\n// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`\nepoll_ctl_add(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);\n\nwhile(1) {\n  // 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时\n  // 由系统通知应用。通知的形式如下：\n  //\n  // epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生\n  // 变化时返回\n  //\n  // epoll_wait 调用返回后：\n  // nfds 表示发生变化的文件描述符数量\n  // events 会保存当前的事件，它的数量就是 nfds\n  int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);\n\n  // 遍历 events，对事件作出符合应用预期的响应\n  for (int i = 0; i < nfds; i++) {\n    consume events[i]\n  }\n}\n\n```\n## epoll的触发模式\n触发模式分为水平触发和边缘触发。\n### 名词来源\n触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。\n水平触发：在高低电压的峰谷值周期内部会激活对应的电路。![image.png](/images/async-framework/2.png)\n边缘触发：在高低电压变化的瞬间会激活对应的电路。![image.png](/images/async-framework/3.png)\n### epoll中触发模式实例\n比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。\n**如果是水平触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容\n\n**如果是边缘触发：**\n\n- 我们的应用会被系统唤醒，因为 fd 此时状态变为了可读\n- 我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作\n- 进入到新的一次事件循环，等待系统下一次唤醒\n- 此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）\n- 系统唤醒我们的应用，此时缓冲区有 6 bytes = (4 + 2) bytes\n\n**对此场景下两种触发模式的理解：**\n水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；\n边缘触发，对应的是**状态的变化**，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。\n## epoll的局限性\nepoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。\n所以在实现异步操作框架时，一般会混合多种非阻塞手段：\n\n- 将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）\n- 对于可以利用系统调用的 IO 操作，优先使用统一后的 API\n- 对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API\n- 最后，将上面的细节封装在内部，对外提供统一的 API\n# 框架逻辑结构\n## 基础代码示例\n这个是一个异步事件框架的基本骨架，很重要。\n主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。\n```cpp\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r) uv__update_time(loop);\n\n  // 是循环，没错了\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    // 处理 timer 队列\n    uv__run_timers(loop);\n    // 处理 pending 队列\n    ran_pending = uv__run_pending(loop);\n    // 处理 idle 队列\n    uv__run_idle(loop);\n    // 处理 prepare 队列\n    uv__run_prepare(loop);\n\n    // 执行 io_poll\n    uv__io_poll(loop, timeout);\n    uv__metrics_update_idle_time(loop);\n\n    // 执行 check 队列\n    uv__run_check(loop);\n    // 执行 closing 队列\n    uv__run_closing_handles(loop);\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break;\n  }\n\n  return r;\n}\n```\n## 抽象的操作概念\nevent-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。\n### Handle\nHandle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。\n**handle的API如下：**\n因为是长期存在的操作，所以基本上会拥有三个步骤：初始化/开始/停止。\n```cpp\n// IO 操作\nint uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket);\nint uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nint uv_poll_stop(uv_poll_t* poll);\n\n// timer\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n### Requet\n**request的API如下：**\nrequst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。\n```cpp\nint uv_getaddrinfo\n(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, /* ... */);\n```\n### 联系\n Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。\n## 不同的回调队列\n### timer\ntimer存在以下三个API：\n```cpp\nint uv_timer_init(uv_loop_t* loop, uv_timer_t* handle);\nint uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat);\nint uv_timer_stop(uv_timer_t* handle);\n```\n#### init\ninit没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。\n#### start\nstart内部做了如下的一些工作：\n```cpp\nint uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  // loop->time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值\n  // clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要\n  // 计算了，直接从 timers 中取符合条件的即可\n  if (clamped_timeout < timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle->timer_cb = cb;\n  handle->timeout = clamped_timeout;\n  handle->repeat = repeat;\n\n  // 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的\n  //自增 start_id 作为比较条件来觉得 handle 的执行先后顺序\n  handle->start_id = handle->loop->timer_counter++;\n\n  // 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是\n  // clamped_timeout 值（或者 start_id）最小的 handle\n  heap_insert(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的开始状态\n  uv__handle_start(handle);\n\n  return 0;\n}\n```\n#### stop\nstop内部做了如下的一些工作：\n```cpp\nint uv_timer_stop(uv_timer_t* handle) {\n  if (!uv__is_active(handle))\n    return 0;\n\n  // 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外\n  // 还会维护 timer_heap 以保障其始终是 binary min heap\n  heap_remove(timer_heap(handle->loop),\n              (struct heap_node*) &handle->heap_node,\n              timer_less_than);\n  // 设置 handle 的状态为停止\n  uv__handle_stop(handle);\n\n  return 0;\n}\n```\n#### timers串联分析\nstart 和 stop 其实可以粗略地概括为，往属性 loop->timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。\n**整个timers的启动：**\n```cpp\nvoid uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    // 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个\n    heap_node = heap_min(timer_heap(loop));\n    if (heap_node == NULL)\n      break;\n\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle->timeout > loop->time)\n      break;\n\n    // 停止、移出 handle、顺便维护 timer_heap\n    uv_timer_stop(handle);\n    // 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中\n    // 会在下一次事件循环中、由本方法继续执行\n    uv_timer_again(handle);\n    // 执行超时 handle 其对应的回调\n    handle->timer_cb(handle);\n  }\n}\n```\n### pending\n#### pending数据结构\n使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。\n#### pending串联分析\n```cpp\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  // 不断从队列中弹出元素进行操作\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n```\n### idle，check，prepare\n这部分感觉不重要，思想上和pending大同小异，不重点看了。\n### io poll\n在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。\n```cpp\nvoid uv__io_poll(uv_loop_t* loop, int timeout) {\n  while (!QUEUE_EMPTY(&loop->watcher_queue)) {\n    // ...\n    // `loop->backend_fd` 是使用 `epoll_create` 创建的 epoll 实例\n    epoll_ctl(loop->backend_fd, op, w->fd, &e)\n    // ...\n  }\n\n  // ...\n  for (;;) {\n  // ...\n    if (/* ... */) {\n      // ...\n    } else {\n      // ...\n      // `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者\n      nfds = epoll_wait(loop->backend_fd,\n                        events,\n                        ARRAY_SIZE(events),\n                        timeout);\n      // ...\n    }\n  }\n  // ...\n\n  for (i = 0; i < nfds; i++) {\n    // ...\n    w = loop->watchers[fd];\n    // ...\n    w->cb(loop, w, pe->events);\n  }\n}\n```\n#### timeout参数\n**在epoll_wait中timeout参数的含义：**\n\n- 如果是 -1 表示一直等到有事件产生\n- 如果是 0 则立即返回，包含调用时产生的事件\n- 如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内\n\n**在epoll_wait中timeout参数的获得：**\n核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。\n 在uv__next_timeout 实现主要分为三部分：\n\n- 只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达\n- 当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer\n- 当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间\n```cpp\nint uv_backend_timeout(const uv_loop_t* loop) {\n  // 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环\n  if (loop->stop_flag != 0)\n    return 0;\n\n  // 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回\n  if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))\n    return 0;\n\n  // idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环\n  // 否则会导致 idle 产生过高的延迟\n  if (!QUEUE_EMPTY(&loop->idle_handles))\n    return 0;\n\n  // 和上一步目的一样，不过这里是换成了 pending 队列\n  if (!QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  // 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟\n  if (loop->closing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}\n\nint uv__next_timeout(const uv_loop_t* loop) {\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  heap_node = heap_min(timer_heap(loop));\n  // 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达\n  if (heap_node == NULL)\n    return -1; /* block indefinitely */\n\n  handle = container_of(heap_node, uv_timer_t, heap_node);\n  // 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`\n  // 尽快返回，以在下一个事件循环迭代内处理超时的 timer\n  if (handle->timeout <= loop->time)\n    return 0;\n\n  // 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间\n  // 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待\n  // epoll 事件\n  diff = handle->timeout - loop->time;\n  if (diff > INT_MAX)\n    diff = INT_MAX;\n\n  return (int) diff;\n}\n```\n### thread pool\n在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。\n#### init\n通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。\n```cpp\nvoid uv__work_submit(uv_loop_t* loop,\n                     struct uv__work* w,\n                     enum uv__work_kind kind,\n                     void (*work)(struct uv__work* w),\n                     void (*done)(struct uv__work* w, int status)) {\n  uv_once(&once, init_once);\n  // ...\n  post(&w->wq, kind);\n}\n```\ninit_once 内部会调用 init_threads 来完成线程池初始化工作。\n```cpp\nstatic uv_thread_t default_threads[4];\n\nstatic void init_threads(void) {\n  // ...\n  nthreads = ARRAY_SIZE(default_threads);\n  val = getenv(\"UV_THREADPOOL_SIZE\");\n  // ...\n  for (i = 0; i < nthreads; i++)\n    if (uv_thread_create(threads + i, worker, &sem))\n      abort();\n  // ...\n}\n```\n#### post\n还是uv__work_submit 方法，内部通过post函数完成任务的提交。\n提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。\n```cpp\nstatic void post(QUEUE* q, enum uv__work_kind kind) {\n  uv_mutex_lock(&mutex);\n  // ...\n  // 将任务插入到 `wq` 这个线程共享的队列中\n  QUEUE_INSERT_TAIL(&wq, q);\n  // 如果有空闲线程，则通知它们开始工作\n  if (idle_threads > 0)\n    uv_cond_signal(&cond);\n  uv_mutex_unlock(&mutex);\n}\n```\n#### 更多逻辑\n线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。\n### closing\n通过closing队列来实现对长操作handle的关闭操作。\n调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。\n```cpp\nvoid uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!uv__is_closing(handle));\n\n  handle->flags |= UV_HANDLE_CLOSING;\n  handle->close_cb = close_cb;\n\n  switch (handle->type) {\n  // 根据不同的 handle 类型，执行各自的资源回收工作\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n  // ...\n\n  default:\n    assert(0);\n  }\n  \n  // 添加到 `loop->closing_handles`\n  uv__make_close_pending(handle);\n}\n\nvoid uv__make_close_pending(uv_handle_t* handle) {\n  assert(handle->flags & UV_HANDLE_CLOSING);\n  assert(!(handle->flags & UV_HANDLE_CLOSED));\n  handle->next_closing = handle->loop->closing_handles;\n  handle->loop->closing_handles = handle;\n}\n```\n","slug":"Async-framework","published":1,"updated":"2024-02-05T05:52:42.390Z","_id":"cls8ihuyg0000icx5gxv6hdkd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。<br>因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。</p>\n<h1 id=\"核心构成\"><a href=\"#核心构成\" class=\"headerlink\" title=\"核心构成\"></a>核心构成</h1><p>event-loop + 基于I&#x2F;O或者其他事件通知的回调函数。<br>在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> there are still events to process:</span><br><span class=\"line\">    e = get the next event</span><br><span class=\"line\">    <span class=\"keyword\">if</span> there is a callback associated with e:</span><br><span class=\"line\">        call the callback</span><br></pre></td></tr></table></figure>\n<h1 id=\"异步实现\"><a href=\"#异步实现\" class=\"headerlink\" title=\"异步实现\"></a>异步实现</h1><h2 id=\"需要非阻塞原因\"><a href=\"#需要非阻塞原因\" class=\"headerlink\" title=\"需要非阻塞原因\"></a>需要非阻塞原因</h2><p>系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。</p>\n<h2 id=\"解决方案一：多线程\"><a href=\"#解决方案一：多线程\" class=\"headerlink\" title=\"解决方案一：多线程\"></a>解决方案一：多线程</h2><p>每一个阻塞的I&#x2F;O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。</p>\n<h2 id=\"解决方案二：异步\"><a href=\"#解决方案二：异步\" class=\"headerlink\" title=\"解决方案二：异步\"></a>解决方案二：异步</h2><p>现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。<br>例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。<br>异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。</p>\n<h1 id=\"异步实现的基础\"><a href=\"#异步实现的基础\" class=\"headerlink\" title=\"异步实现的基础\"></a>异步实现的基础</h1><p>为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。</p>\n<h2 id=\"epoll简介\"><a href=\"#epoll简介\" class=\"headerlink\" title=\"epoll简介\"></a>epoll简介</h2><p>epoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：</p>\n<ul>\n<li>告诉系统帮助我们同时监控多个文件描述符</li>\n<li>当这其中的一个或者多个文件描述符的 I&#x2F;O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）</li>\n</ul>\n<h2 id=\"epoll流程示例\"><a href=\"#epoll流程示例\" class=\"headerlink\" title=\"epoll流程示例\"></a>epoll流程示例</h2><p><img src=\"/images/async-framework/1.png\" alt=\"image.png\"><br>使用伪代码写一个epoll的具体实现流程，即如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 epoll 实例</span></span><br><span class=\"line\"><span class=\"type\">int</span> epfd = <span class=\"built_in\">epoll_create</span>(MAX_EVENTS);</span><br><span class=\"line\"><span class=\"comment\">// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`</span></span><br><span class=\"line\"><span class=\"built_in\">epoll_ctl_add</span>(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时</span></span><br><span class=\"line\">  <span class=\"comment\">// 由系统通知应用。通知的形式如下：</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生</span></span><br><span class=\"line\">  <span class=\"comment\">// 变化时返回</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用返回后：</span></span><br><span class=\"line\">  <span class=\"comment\">// nfds 表示发生变化的文件描述符数量</span></span><br><span class=\"line\">  <span class=\"comment\">// events 会保存当前的事件，它的数量就是 nfds</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nfds = <span class=\"built_in\">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 遍历 events，对事件作出符合应用预期的响应</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    consume events[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll的触发模式\"><a href=\"#epoll的触发模式\" class=\"headerlink\" title=\"epoll的触发模式\"></a>epoll的触发模式</h2><p>触发模式分为水平触发和边缘触发。</p>\n<h3 id=\"名词来源\"><a href=\"#名词来源\" class=\"headerlink\" title=\"名词来源\"></a>名词来源</h3><p>触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。<br>水平触发：在高低电压的峰谷值周期内部会激活对应的电路。<img src=\"/images/async-framework/2.png\" alt=\"image.png\"><br>边缘触发：在高低电压变化的瞬间会激活对应的电路。<img src=\"/images/async-framework/3.png\" alt=\"image.png\"></p>\n<h3 id=\"epoll中触发模式实例\"><a href=\"#epoll中触发模式实例\" class=\"headerlink\" title=\"epoll中触发模式实例\"></a>epoll中触发模式实例</h3><p>比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。<br><strong>如果是水平触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容</li>\n</ul>\n<p><strong>如果是边缘触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）</li>\n<li>系统唤醒我们的应用，此时缓冲区有 6 bytes &#x3D; (4 + 2) bytes</li>\n</ul>\n<p><strong>对此场景下两种触发模式的理解：</strong><br>水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；<br>边缘触发，对应的是<strong>状态的变化</strong>，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。</p>\n<h2 id=\"epoll的局限性\"><a href=\"#epoll的局限性\" class=\"headerlink\" title=\"epoll的局限性\"></a>epoll的局限性</h2><p>epoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。<br>所以在实现异步操作框架时，一般会混合多种非阻塞手段：</p>\n<ul>\n<li>将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）</li>\n<li>对于可以利用系统调用的 IO 操作，优先使用统一后的 API</li>\n<li>对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API</li>\n<li>最后，将上面的细节封装在内部，对外提供统一的 API</li>\n</ul>\n<h1 id=\"框架逻辑结构\"><a href=\"#框架逻辑结构\" class=\"headerlink\" title=\"框架逻辑结构\"></a>框架逻辑结构</h1><h2 id=\"基础代码示例\"><a href=\"#基础代码示例\" class=\"headerlink\" title=\"基础代码示例\"></a>基础代码示例</h2><p>这个是一个异步事件框架的基本骨架，很重要。<br>主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_run</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">  <span class=\"type\">int</span> r;</span><br><span class=\"line\">  <span class=\"type\">int</span> ran_pending;</span><br><span class=\"line\"></span><br><span class=\"line\">  r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!r) <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是循环，没错了</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (r != <span class=\"number\">0</span> &amp;&amp; loop-&gt;stop_flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 timer 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_timers</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 pending 队列</span></span><br><span class=\"line\">    ran_pending = <span class=\"built_in\">uv__run_pending</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 idle 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_idle</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 prepare 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_prepare</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 io_poll</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__io_poll</span>(loop, timeout);</span><br><span class=\"line\">    <span class=\"built_in\">uv__metrics_update_idle_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 check 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_check</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 closing 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_closing_handles</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"抽象的操作概念\"><a href=\"#抽象的操作概念\" class=\"headerlink\" title=\"抽象的操作概念\"></a>抽象的操作概念</h2><p>event-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。</p>\n<h3 id=\"Handle\"><a href=\"#Handle\" class=\"headerlink\" title=\"Handle\"></a>Handle</h3><p>Handle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。<br><strong>handle的API如下：</strong><br>因为是长期存在的操作，所以基本上会拥有三个步骤：初始化&#x2F;开始&#x2F;停止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IO 操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_init_socket</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">uv_os_sock_t</span> socket)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_start</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">int</span> events, uv_poll_cb cb)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_stop</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* poll)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// timer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Requet\"><a href=\"#Requet\" class=\"headerlink\" title=\"Requet\"></a>Requet</h3><p><strong>request的API如下：</strong><br>requst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_getaddrinfo</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_getaddrinfo_t</span>* req, uv_getaddrinfo_cb getaddrinfo_cb, <span class=\"comment\">/* ... */</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><p> Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。</p>\n<h2 id=\"不同的回调队列\"><a href=\"#不同的回调队列\" class=\"headerlink\" title=\"不同的回调队列\"></a>不同的回调队列</h2><h3 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h3><p>timer存在以下三个API：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h4><p>init没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。</p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h4><p>start内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   uv_timer_cb cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> timeout,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> repeat)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> clamped_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// loop-&gt;time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要</span></span><br><span class=\"line\">  <span class=\"comment\">// 计算了，直接从 timers 中取符合条件的即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (clamped_timeout &lt; timeout)</span><br><span class=\"line\">    clamped_timeout = (<span class=\"type\">uint64_t</span>) <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;timer_cb = cb;</span><br><span class=\"line\">  handle-&gt;timeout = clamped_timeout;</span><br><span class=\"line\">  handle-&gt;repeat = repeat;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的</span></span><br><span class=\"line\">  <span class=\"comment\">//自增 start_id 作为比较条件来觉得 handle 的执行先后顺序</span></span><br><span class=\"line\">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 值（或者 start_id）最小的 handle</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_insert</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的开始状态</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_start</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h4><p>stop内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__is_active</span>(handle))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外</span></span><br><span class=\"line\">  <span class=\"comment\">// 还会维护 timer_heap 以保障其始终是 binary min heap</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_remove</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的状态为停止</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_stop</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timers串联分析\"><a href=\"#timers串联分析\" class=\"headerlink\" title=\"timers串联分析\"></a>timers串联分析</h4><p>start 和 stop 其实可以粗略地概括为，往属性 loop-&gt;timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。<br><strong>整个timers的启动：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__run_timers</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个</span></span><br><span class=\"line\">    heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 停止、移出 handle、顺便维护 timer_heap</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_stop</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中</span></span><br><span class=\"line\">    <span class=\"comment\">// 会在下一次事件循环中、由本方法继续执行</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_again</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 执行超时 handle 其对应的回调</span></span><br><span class=\"line\">    handle-&gt;<span class=\"built_in\">timer_cb</span>(handle);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pending\"><a href=\"#pending\" class=\"headerlink\" title=\"pending\"></a>pending</h3><h4 id=\"pending数据结构\"><a href=\"#pending数据结构\" class=\"headerlink\" title=\"pending数据结构\"></a>pending数据结构</h4><p>使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。</p>\n<h4 id=\"pending串联分析\"><a href=\"#pending串联分析\" class=\"headerlink\" title=\"pending串联分析\"></a>pending串联分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">uv__run_pending</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  QUEUE* q;</span><br><span class=\"line\">  QUEUE pq;</span><br><span class=\"line\">  <span class=\"type\">uv__io_t</span>* w;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_MOVE</span>(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不断从队列中弹出元素进行操作</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;pq)) &#123;</span><br><span class=\"line\">    q = <span class=\"built_in\">QUEUE_HEAD</span>(&amp;pq);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_REMOVE</span>(q);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_INIT</span>(q);</span><br><span class=\"line\">    w = <span class=\"built_in\">QUEUE_DATA</span>(q, <span class=\"type\">uv__io_t</span>, pending_queue);</span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, POLLOUT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"idle，check，prepare\"><a href=\"#idle，check，prepare\" class=\"headerlink\" title=\"idle，check，prepare\"></a>idle，check，prepare</h3><p>这部分感觉不重要，思想上和pending大同小异，不重点看了。</p>\n<h3 id=\"io-poll\"><a href=\"#io-poll\" class=\"headerlink\" title=\"io poll\"></a>io poll</h3><p>在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__io_poll</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">int</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// `loop-&gt;backend_fd` 是使用 `epoll_create` 创建的 epoll 实例</span></span><br><span class=\"line\">    <span class=\"built_in\">epoll_ctl</span>(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* ... */</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者</span></span><br><span class=\"line\">      nfds = <span class=\"built_in\">epoll_wait</span>(loop-&gt;backend_fd,</span><br><span class=\"line\">                        events,</span><br><span class=\"line\">                        <span class=\"built_in\">ARRAY_SIZE</span>(events),</span><br><span class=\"line\">                        timeout);</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w = loop-&gt;watchers[fd];</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, pe-&gt;events);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timeout参数\"><a href=\"#timeout参数\" class=\"headerlink\" title=\"timeout参数\"></a>timeout参数</h4><p><strong>在epoll_wait中timeout参数的含义：</strong></p>\n<ul>\n<li>如果是 -1 表示一直等到有事件产生</li>\n<li>如果是 0 则立即返回，包含调用时产生的事件</li>\n<li>如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内</li>\n</ul>\n<p><strong>在epoll_wait中timeout参数的获得：</strong><br>核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。<br> 在uv__next_timeout 实现主要分为三部分：</p>\n<ul>\n<li>只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达</li>\n<li>当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer</li>\n<li>当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_backend_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;stop_flag != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__has_active_handles</span>(loop) &amp;&amp; !<span class=\"built_in\">uv__has_active_reqs</span>(loop))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则会导致 idle 产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;idle_handles))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里是换成了 pending 队列</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;closing_handles)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">uv__next_timeout</span>(loop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv__next_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> diff;</span><br><span class=\"line\"></span><br><span class=\"line\">  heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">/* block indefinitely */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">  <span class=\"comment\">// 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`</span></span><br><span class=\"line\">  <span class=\"comment\">// 尽快返回，以在下一个事件循环迭代内处理超时的 timer</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll 事件</span></span><br><span class=\"line\">  diff = handle-&gt;timeout - loop-&gt;time;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (diff &gt; INT_MAX)</span><br><span class=\"line\">    diff = INT_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) diff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"thread-pool\"><a href=\"#thread-pool\" class=\"headerlink\" title=\"thread pool\"></a>thread pool</h3><p>在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。</p>\n<h4 id=\"init-1\"><a href=\"#init-1\" class=\"headerlink\" title=\"init\"></a>init</h4><p>通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__work_submit</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">struct</span> uv__work* w,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">enum</span> uv__work_kind kind,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*work)(<span class=\"keyword\">struct</span> uv__work* w),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*done)(<span class=\"keyword\">struct</span> uv__work* w, <span class=\"type\">int</span> status))</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_once</span>(&amp;once, init_once);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">post</span>(&amp;w-&gt;wq, kind);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>init_once 内部会调用 init_threads 来完成线程池初始化工作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uv_thread_t</span> default_threads[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">init_threads</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  nthreads = <span class=\"built_in\">ARRAY_SIZE</span>(default_threads);</span><br><span class=\"line\">  val = <span class=\"built_in\">getenv</span>(<span class=\"string\">&quot;UV_THREADPOOL_SIZE&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nthreads; i++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">uv_thread_create</span>(threads + i, worker, &amp;sem))</span><br><span class=\"line\">      <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"post\"></a>post</h4><p>还是uv__work_submit 方法，内部通过post函数完成任务的提交。<br>提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">post</span><span class=\"params\">(QUEUE* q, <span class=\"keyword\">enum</span> uv__work_kind kind)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_lock</span>(&amp;mutex);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 将任务插入到 `wq` 这个线程共享的队列中</span></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_INSERT_TAIL</span>(&amp;wq, q);</span><br><span class=\"line\">  <span class=\"comment\">// 如果有空闲线程，则通知它们开始工作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (idle_threads &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">uv_cond_signal</span>(&amp;cond);</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_unlock</span>(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"更多逻辑\"><a href=\"#更多逻辑\" class=\"headerlink\" title=\"更多逻辑\"></a>更多逻辑</h4><p>线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。</p>\n<h3 id=\"closing\"><a href=\"#closing\" class=\"headerlink\" title=\"closing\"></a>closing</h3><p>通过closing队列来实现对长操作handle的关闭操作。<br>调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv_close</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle, uv_close_cb close_cb)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!<span class=\"built_in\">uv__is_closing</span>(handle));</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;flags |= UV_HANDLE_CLOSING;</span><br><span class=\"line\">  handle-&gt;close_cb = close_cb;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (handle-&gt;type) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据不同的 handle 类型，执行各自的资源回收工作</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_NAMED_PIPE:</span><br><span class=\"line\">    <span class=\"built_in\">uv__pipe_close</span>((<span class=\"type\">uv_pipe_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TTY:</span><br><span class=\"line\">    <span class=\"built_in\">uv__stream_close</span>((<span class=\"type\">uv_stream_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TCP:</span><br><span class=\"line\">    <span class=\"built_in\">uv__tcp_close</span>((<span class=\"type\">uv_tcp_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 添加到 `loop-&gt;closing_handles`</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__make_close_pending</span>(handle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__make_close_pending</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class=\"line\">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class=\"line\">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近有使用到事件框架，因此对事件框架的学习简单做一个学习笔记。<br>因为我使用的是libuv，所以后文中部分跟事件框架特性相关的内容和图片是基于libuv的官方文档而言的，不泛指一切事件框架。</p>\n<h1 id=\"核心构成\"><a href=\"#核心构成\" class=\"headerlink\" title=\"核心构成\"></a>核心构成</h1><p>event-loop + 基于I&#x2F;O或者其他事件通知的回调函数。<br>在事件驱动编程中，程序会关注每一个事件，并且对每一个事件的发生做出反应。libuv会负责监听各个来源的事件。用户通过注册回调函数在监听到事件的时候被调用。event-loop会一直保持运行状态。用伪代码描述如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> there are still events to process:</span><br><span class=\"line\">    e = get the next event</span><br><span class=\"line\">    <span class=\"keyword\">if</span> there is a callback associated with e:</span><br><span class=\"line\">        call the callback</span><br></pre></td></tr></table></figure>\n<h1 id=\"异步实现\"><a href=\"#异步实现\" class=\"headerlink\" title=\"异步实现\"></a>异步实现</h1><h2 id=\"需要非阻塞原因\"><a href=\"#需要非阻塞原因\" class=\"headerlink\" title=\"需要非阻塞原因\"></a>需要非阻塞原因</h2><p>系统编程中出现输入输出的场景多于数据处理。问题在于传统的输入输出函数(例如read，fprintf)都是阻塞式的。在任务完成前函数不会返回，程序在这段时间内什么也做不了。这导致远低于cpu处理速度的IO传输速度是高性能系统的主要障碍。</p>\n<h2 id=\"解决方案一：多线程\"><a href=\"#解决方案一：多线程\" class=\"headerlink\" title=\"解决方案一：多线程\"></a>解决方案一：多线程</h2><p>每一个阻塞的I&#x2F;O操作都会被分配到各个线程中。当某个线程一旦阻塞，处理器就可以调度处理其他需要cpu资源的线程（操作系统自行分配cpu资源，采用非阻塞方式来轮流执行任务）。</p>\n<h2 id=\"解决方案二：异步\"><a href=\"#解决方案二：异步\" class=\"headerlink\" title=\"解决方案二：异步\"></a>解决方案二：异步</h2><p>现代操作系统大多提供了基于事件通知的子系统。为异步的实现提供了基础。<br>例如正常的socket上的read调用会发生阻塞，直到发送方把信息发送过来。但是，实际上程序可以请求操作系统监视socket事件的到来，并将这个事件通知放到事件队列中。这样，程序就可以很简单地检查事件是否到来，通知正在处理其他任务的cpu处理事件，及时地获取数据。<br>异步的具体表现是程序可以在时空上地某一端表达对某事件的兴趣，并在时空地另一端被动地获取到数据。非阻塞是因为程序不是主动地请求等待，而是被动地被事件调用，期间可以自由地做其他的事。</p>\n<h1 id=\"异步实现的基础\"><a href=\"#异步实现的基础\" class=\"headerlink\" title=\"异步实现的基础\"></a>异步实现的基础</h1><p>为了追本溯源，以 epoll 为例分析可实现异步的操作系统基础。</p>\n<h2 id=\"epoll简介\"><a href=\"#epoll简介\" class=\"headerlink\" title=\"epoll简介\"></a>epoll简介</h2><p>epoll 是由 Linux 内核提供的一个系统调用，我们的应用程序可以通过它：</p>\n<ul>\n<li>告诉系统帮助我们同时监控多个文件描述符</li>\n<li>当这其中的一个或者多个文件描述符的 I&#x2F;O 可操作状态改变时，我们的应用程序会接收到来自系统的事件提示（event notification）</li>\n</ul>\n<h2 id=\"epoll流程示例\"><a href=\"#epoll流程示例\" class=\"headerlink\" title=\"epoll流程示例\"></a>epoll流程示例</h2><p><img src=\"/images/async-framework/1.png\" alt=\"image.png\"><br>使用伪代码写一个epoll的具体实现流程，即如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 epoll 实例</span></span><br><span class=\"line\"><span class=\"type\">int</span> epfd = <span class=\"built_in\">epoll_create</span>(MAX_EVENTS);</span><br><span class=\"line\"><span class=\"comment\">// 向 epoll 实例中添加需要监听的文件描述符，这里是 `listen_sock`</span></span><br><span class=\"line\"><span class=\"built_in\">epoll_ctl_add</span>(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等待来自 epoll 的通知，通知会在其中的文件描述符状态改变时</span></span><br><span class=\"line\">  <span class=\"comment\">// 由系统通知应用。通知的形式如下：</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用不会立即返回，系统会在其中的文件描述符状态发生</span></span><br><span class=\"line\">  <span class=\"comment\">// 变化时返回</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll_wait 调用返回后：</span></span><br><span class=\"line\">  <span class=\"comment\">// nfds 表示发生变化的文件描述符数量</span></span><br><span class=\"line\">  <span class=\"comment\">// events 会保存当前的事件，它的数量就是 nfds</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nfds = <span class=\"built_in\">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 遍历 events，对事件作出符合应用预期的响应</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    consume events[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll的触发模式\"><a href=\"#epoll的触发模式\" class=\"headerlink\" title=\"epoll的触发模式\"></a>epoll的触发模式</h2><p>触发模式分为水平触发和边缘触发。</p>\n<h3 id=\"名词来源\"><a href=\"#名词来源\" class=\"headerlink\" title=\"名词来源\"></a>名词来源</h3><p>触发模式是传统电子领域的名词的衍生义，下图为电子领域表示电压变化的时序图。<br>水平触发：在高低电压的峰谷值周期内部会激活对应的电路。<img src=\"/images/async-framework/2.png\" alt=\"image.png\"><br>边缘触发：在高低电压变化的瞬间会激活对应的电路。<img src=\"/images/async-framework/3.png\" alt=\"image.png\"></p>\n<h3 id=\"epoll中触发模式实例\"><a href=\"#epoll中触发模式实例\" class=\"headerlink\" title=\"epoll中触发模式实例\"></a>epoll中触发模式实例</h3><p>比如我们有一个fd表示刚建立的客户端连接，随后客户端给我们发送了 5 bytes 的内容。<br><strong>如果是水平触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>系统继续唤醒我们的应用，因为缓冲区还有未读取的 4 bytes 内容</li>\n</ul>\n<p><strong>如果是边缘触发：</strong></p>\n<ul>\n<li>我们的应用会被系统唤醒，因为 fd 此时状态变为了可读</li>\n<li>我们从系统的缓冲区中读取 1 byte 的内容，并做了一些业务操作</li>\n<li>进入到新的一次事件循环，等待系统下一次唤醒</li>\n<li>此时系统并不会唤醒我们的应用，直到下一次客户端发送了一些内容，比如发送了 2 bytes（因为直到下一次客户端发送了请求之前，fd 的状态并没有改变，所以在边缘触发下系统不会唤醒应用）</li>\n<li>系统唤醒我们的应用，此时缓冲区有 6 bytes &#x3D; (4 + 2) bytes</li>\n</ul>\n<p><strong>对此场景下两种触发模式的理解：</strong><br>水平触发，因为已经是可读状态，所以它会一直触发，直到我们读完缓冲区，且系统缓冲区没有新的客户端发送的内容；<br>边缘触发，对应的是<strong>状态的变化</strong>，每次有新的客户端发送内容，都会设置可读状态，因此只会在这个时机触发。</p>\n<h2 id=\"epoll的局限性\"><a href=\"#epoll的局限性\" class=\"headerlink\" title=\"epoll的局限性\"></a>epoll的局限性</h2><p>epoll 并不能够作用在所有的 IO 操作上，比如文件的读写操作，就无法享受到 epoll 的便利性。<br>所以在实现异步操作框架时，一般会混合多种非阻塞手段：</p>\n<ul>\n<li>将各种操作系统上的类似 epoll 的系统调用（比如 Unix 上的 kqueue 和 Windows 上的 IOCP）抽象出统一的 API（内部 API）</li>\n<li>对于可以利用系统调用的 IO 操作，优先使用统一后的 API</li>\n<li>对于不支持或者支持度不够的 IO 操作，使用线程池（Thread pool）的方式模拟出异步 API</li>\n<li>最后，将上面的细节封装在内部，对外提供统一的 API</li>\n</ul>\n<h1 id=\"框架逻辑结构\"><a href=\"#框架逻辑结构\" class=\"headerlink\" title=\"框架逻辑结构\"></a>框架逻辑结构</h1><h2 id=\"基础代码示例\"><a href=\"#基础代码示例\" class=\"headerlink\" title=\"基础代码示例\"></a>基础代码示例</h2><p>这个是一个异步事件框架的基本骨架，很重要。<br>主体就是一个while循环，内部依次处理了timer，pending，idle，prepare，io_poll，check，closing的队列事件，这个先后顺序也表示了这些事件的优先级。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_run</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">  <span class=\"type\">int</span> r;</span><br><span class=\"line\">  <span class=\"type\">int</span> ran_pending;</span><br><span class=\"line\"></span><br><span class=\"line\">  r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!r) <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是循环，没错了</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (r != <span class=\"number\">0</span> &amp;&amp; loop-&gt;stop_flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">uv__update_time</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 timer 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_timers</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 pending 队列</span></span><br><span class=\"line\">    ran_pending = <span class=\"built_in\">uv__run_pending</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 idle 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_idle</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 prepare 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_prepare</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 io_poll</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__io_poll</span>(loop, timeout);</span><br><span class=\"line\">    <span class=\"built_in\">uv__metrics_update_idle_time</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 check 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_check</span>(loop);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 closing 队列</span></span><br><span class=\"line\">    <span class=\"built_in\">uv__run_closing_handles</span>(loop);</span><br><span class=\"line\"></span><br><span class=\"line\">    r = <span class=\"built_in\">uv__loop_alive</span>(loop);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"抽象的操作概念\"><a href=\"#抽象的操作概念\" class=\"headerlink\" title=\"抽象的操作概念\"></a>抽象的操作概念</h2><p>event-loop中存在一些操作的抽象概念，通过分析他们的api对他们的抽象进行一个简述。</p>\n<h3 id=\"Handle\"><a href=\"#Handle\" class=\"headerlink\" title=\"Handle\"></a>Handle</h3><p>Handle表示需要长期存在的操作，Request表示只需要短暂存在的操作，有着不同的使用方式。<br><strong>handle的API如下：</strong><br>因为是长期存在的操作，所以基本上会拥有三个步骤：初始化&#x2F;开始&#x2F;停止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IO 操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_init_socket</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">uv_os_sock_t</span> socket)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_start</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* handle, <span class=\"type\">int</span> events, uv_poll_cb cb)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_poll_stop</span><span class=\"params\">(<span class=\"type\">uv_poll_t</span>* poll)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// timer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Requet\"><a href=\"#Requet\" class=\"headerlink\" title=\"Requet\"></a>Requet</h3><p><strong>request的API如下：</strong><br>requst是个短暂操作，交互形式本质是个请求，提交请求则返回结果。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_getaddrinfo</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_getaddrinfo_t</span>* req, uv_getaddrinfo_cb getaddrinfo_cb, <span class=\"comment\">/* ... */</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><p> Handle 和 Request 两者不是互斥的概念，Handle 内部实现可能也用到了 Request。因为一些宏观来看的长期操作，在每个时间切片内是可以看成是 Request 的，比如我们处理一个请求，可以看成是一个 Handle，而在当次的请求中，我们很可能会做一些读取和写入的操作，这些操作就可以看成是 Request。</p>\n<h2 id=\"不同的回调队列\"><a href=\"#不同的回调队列\" class=\"headerlink\" title=\"不同的回调队列\"></a>不同的回调队列</h2><h3 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h3><p>timer存在以下三个API：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_init</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle, uv_timer_cb cb, <span class=\"type\">uint64_t</span> timeout, <span class=\"type\">uint64_t</span> repeat)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h4><p>init没有什么特殊的地方，只是出初始了一下handle并将handle添加到了队列里。</p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h4><p>start内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_start</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   uv_timer_cb cb,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> timeout,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">uint64_t</span> repeat)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> clamped_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// loop-&gt;time 表示 loop 当前的时间。loop 每次迭代开始时，会用当次时间更新该值</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 就是该 timer 未来超时的时间点，这里直接计算好，这样未来就不需要</span></span><br><span class=\"line\">  <span class=\"comment\">// 计算了，直接从 timers 中取符合条件的即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (clamped_timeout &lt; timeout)</span><br><span class=\"line\">    clamped_timeout = (<span class=\"type\">uint64_t</span>) <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;timer_cb = cb;</span><br><span class=\"line\">  handle-&gt;timeout = clamped_timeout;</span><br><span class=\"line\">  handle-&gt;repeat = repeat;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 除了预先计算好的 clamped_timeout 以外，未来当 clamped_timeout 相同时，使用这里的</span></span><br><span class=\"line\">  <span class=\"comment\">//自增 start_id 作为比较条件来觉得 handle 的执行先后顺序</span></span><br><span class=\"line\">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 插入到 timer_heap 中，这里的 heap 是 binary min heap，所以根节点就是</span></span><br><span class=\"line\">  <span class=\"comment\">// clamped_timeout 值（或者 start_id）最小的 handle</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_insert</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的开始状态</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_start</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h4><p>stop内部做了如下的一些工作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_timer_stop</span><span class=\"params\">(<span class=\"type\">uv_timer_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__is_active</span>(handle))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 handle 移出 timer_heap，和 heap_insert 操作一样，除了移出之外</span></span><br><span class=\"line\">  <span class=\"comment\">// 还会维护 timer_heap 以保障其始终是 binary min heap</span></span><br><span class=\"line\">  <span class=\"built_in\">heap_remove</span>(<span class=\"built_in\">timer_heap</span>(handle-&gt;loop),</span><br><span class=\"line\">              (<span class=\"keyword\">struct</span> heap_node*) &amp;handle-&gt;heap_node,</span><br><span class=\"line\">              timer_less_than);</span><br><span class=\"line\">  <span class=\"comment\">// 设置 handle 的状态为停止</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__handle_stop</span>(handle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timers串联分析\"><a href=\"#timers串联分析\" class=\"headerlink\" title=\"timers串联分析\"></a>timers串联分析</h4><p>start 和 stop 其实可以粗略地概括为，往属性 loop-&gt;timer_heap 中插入或者移出 handle，并且这个timer_heap 使用 binary min heap 的数据结构。<br><strong>整个timers的启动：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__run_timers</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取根节点，该值保证始终是所有待执行的 handle中，最先超时的那一个</span></span><br><span class=\"line\">    heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 停止、移出 handle、顺便维护 timer_heap</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_stop</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 如果是需要 repeat 的 handle，则重新加入到 timer_heap 中</span></span><br><span class=\"line\">    <span class=\"comment\">// 会在下一次事件循环中、由本方法继续执行</span></span><br><span class=\"line\">    <span class=\"built_in\">uv_timer_again</span>(handle);</span><br><span class=\"line\">    <span class=\"comment\">// 执行超时 handle 其对应的回调</span></span><br><span class=\"line\">    handle-&gt;<span class=\"built_in\">timer_cb</span>(handle);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pending\"><a href=\"#pending\" class=\"headerlink\" title=\"pending\"></a>pending</h3><h4 id=\"pending数据结构\"><a href=\"#pending数据结构\" class=\"headerlink\" title=\"pending数据结构\"></a>pending数据结构</h4><p>使用了一个queue来维护handle。在libuv中，queue是一个环形结构，首尾指针都是本身。具体可以看libuv中的queue.h的头文件，不详细展开了。</p>\n<h4 id=\"pending串联分析\"><a href=\"#pending串联分析\" class=\"headerlink\" title=\"pending串联分析\"></a>pending串联分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">uv__run_pending</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  QUEUE* q;</span><br><span class=\"line\">  QUEUE pq;</span><br><span class=\"line\">  <span class=\"type\">uv__io_t</span>* w;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_MOVE</span>(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不断从队列中弹出元素进行操作</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;pq)) &#123;</span><br><span class=\"line\">    q = <span class=\"built_in\">QUEUE_HEAD</span>(&amp;pq);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_REMOVE</span>(q);</span><br><span class=\"line\">    <span class=\"built_in\">QUEUE_INIT</span>(q);</span><br><span class=\"line\">    w = <span class=\"built_in\">QUEUE_DATA</span>(q, <span class=\"type\">uv__io_t</span>, pending_queue);</span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, POLLOUT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"idle，check，prepare\"><a href=\"#idle，check，prepare\" class=\"headerlink\" title=\"idle，check，prepare\"></a>idle，check，prepare</h3><p>这部分感觉不重要，思想上和pending大同小异，不重点看了。</p>\n<h3 id=\"io-poll\"><a href=\"#io-poll\" class=\"headerlink\" title=\"io poll\"></a>io poll</h3><p>在libuv中，虽然把相关名字取成了poll，但是实际调用的确实是epoll。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__io_poll</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop, <span class=\"type\">int</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// `loop-&gt;backend_fd` 是使用 `epoll_create` 创建的 epoll 实例</span></span><br><span class=\"line\">    <span class=\"built_in\">epoll_ctl</span>(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* ... */</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// `epoll_wait` 和 `epoll_pwait` 只有细微的差别，所以这里只考虑前者</span></span><br><span class=\"line\">      nfds = <span class=\"built_in\">epoll_wait</span>(loop-&gt;backend_fd,</span><br><span class=\"line\">                        events,</span><br><span class=\"line\">                        <span class=\"built_in\">ARRAY_SIZE</span>(events),</span><br><span class=\"line\">                        timeout);</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nfds; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w = loop-&gt;watchers[fd];</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    w-&gt;<span class=\"built_in\">cb</span>(loop, w, pe-&gt;events);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"timeout参数\"><a href=\"#timeout参数\" class=\"headerlink\" title=\"timeout参数\"></a>timeout参数</h4><p><strong>在epoll_wait中timeout参数的含义：</strong></p>\n<ul>\n<li>如果是 -1 表示一直等到有事件产生</li>\n<li>如果是 0 则立即返回，包含调用时产生的事件</li>\n<li>如果是其余整数，则以 milliseconds 为单位，规约到未来某个系统时间片内</li>\n</ul>\n<p><strong>在epoll_wait中timeout参数的获得：</strong><br>核心思想就是要尽可能的让 CPU 时间能够在事件循环的多次迭代的、多个不同任务队列的执行、中尽可能的分配均匀，避免某个类型的任务产生很高的延迟。<br> 在uv__next_timeout 实现主要分为三部分：</p>\n<ul>\n<li>只有在没有 timer 待处理的时候，才会是 -1，-1 会让后续的 uv__io_poll 进入 block 状态、完全等待事件的到达</li>\n<li>当有 timer，且有超时的 timer handle，则返回 0，这样 uv__io_poll 不会 block 住事件循环，目的是为了快速进入下一次事件循环、以执行超时的 timer</li>\n<li>当有 timer，不过都没有超时，则计算最小超时时间 diff 来作为 uv__io_poll 的阻塞时间<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv_backend_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 时间循环被外部停止了，所以让 `uv__io_poll` 理解返回以便尽快结束事件循环</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;stop_flag != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有待处理的 handle 和 request，则也不需要等待了，同样让 `uv__io_poll`尽快返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">uv__has_active_handles</span>(loop) &amp;&amp; !<span class=\"built_in\">uv__has_active_reqs</span>(loop))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// idle 队列不为空，也要求 `uv__io_poll` 尽快返回，这样尽快进入下一个时间循环</span></span><br><span class=\"line\">  <span class=\"comment\">// 否则会导致 idle 产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;idle_handles))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里是换成了 pending 队列</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">QUEUE_EMPTY</span>(&amp;loop-&gt;pending_queue))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 和上一步目的一样，不过这里换成，待关闭的 handles，都是为了避免目标队列产生过高的延迟</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (loop-&gt;closing_handles)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">uv__next_timeout</span>(loop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uv__next_timeout</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">heap_node</span>* heap_node;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">uv_timer_t</span>* handle;</span><br><span class=\"line\">  <span class=\"type\">uint64_t</span> diff;</span><br><span class=\"line\"></span><br><span class=\"line\">  heap_node = <span class=\"built_in\">heap_min</span>(<span class=\"built_in\">timer_heap</span>(loop));</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有 timer 待处理，则可以放心的 block 住，等待事件到达</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (heap_node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">/* block indefinitely */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handle = <span class=\"built_in\">container_of</span>(heap_node, <span class=\"type\">uv_timer_t</span>, heap_node);</span><br><span class=\"line\">  <span class=\"comment\">// 有 timer，且 timer 已经到了要被执行的时间内，则需让 `uv__io_poll`</span></span><br><span class=\"line\">  <span class=\"comment\">// 尽快返回，以在下一个事件循环迭代内处理超时的 timer</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有 timer 超时，用最小超时间减去、当前的循环时间的差值，作为超时时间</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为在为了这个差值时间内是没有 timer 超时的，所以可以放心 block 以等待</span></span><br><span class=\"line\">  <span class=\"comment\">// epoll 事件</span></span><br><span class=\"line\">  diff = handle-&gt;timeout - loop-&gt;time;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (diff &gt; INT_MAX)</span><br><span class=\"line\">    diff = INT_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) diff;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"thread-pool\"><a href=\"#thread-pool\" class=\"headerlink\" title=\"thread pool\"></a>thread pool</h3><p>在前面提到过， epoll 目前并不能处理所有的 IO 操作，对于那些 epoll 不支持的 IO 操作，需要内部的线程池来模拟出异步 IO。</p>\n<h4 id=\"init-1\"><a href=\"#init-1\" class=\"headerlink\" title=\"init\"></a>init</h4><p>通过 uv_fs_read 的内部实现，找到 uv__work_submit 方法，发现其中初始化的线程池。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__work_submit</span><span class=\"params\">(<span class=\"type\">uv_loop_t</span>* loop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">struct</span> uv__work* w,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">enum</span> uv__work_kind kind,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*work)(<span class=\"keyword\">struct</span> uv__work* w),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"type\">void</span> (*done)(<span class=\"keyword\">struct</span> uv__work* w, <span class=\"type\">int</span> status))</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_once</span>(&amp;once, init_once);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">post</span>(&amp;w-&gt;wq, kind);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>init_once 内部会调用 init_threads 来完成线程池初始化工作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uv_thread_t</span> default_threads[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">init_threads</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  nthreads = <span class=\"built_in\">ARRAY_SIZE</span>(default_threads);</span><br><span class=\"line\">  val = <span class=\"built_in\">getenv</span>(<span class=\"string\">&quot;UV_THREADPOOL_SIZE&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nthreads; i++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">uv_thread_create</span>(threads + i, worker, &amp;sem))</span><br><span class=\"line\">      <span class=\"built_in\">abort</span>();</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"post\"></a>post</h4><p>还是uv__work_submit 方法，内部通过post函数完成任务的提交。<br>提交任务其实就是将任务插入到线程共享队列 wq，并且有空闲线程时才会通知它们工作。如果当前没有空闲进程，那么工作线程会在完成当前工作后，主动检查 wq 队列是否还有待完成的工作，有的话会继续完成，没有的话，则进入睡眠，等待下次被唤醒。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">post</span><span class=\"params\">(QUEUE* q, <span class=\"keyword\">enum</span> uv__work_kind kind)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_lock</span>(&amp;mutex);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 将任务插入到 `wq` 这个线程共享的队列中</span></span><br><span class=\"line\">  <span class=\"built_in\">QUEUE_INSERT_TAIL</span>(&amp;wq, q);</span><br><span class=\"line\">  <span class=\"comment\">// 如果有空闲线程，则通知它们开始工作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (idle_threads &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">uv_cond_signal</span>(&amp;cond);</span><br><span class=\"line\">  <span class=\"built_in\">uv_mutex_unlock</span>(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"更多逻辑\"><a href=\"#更多逻辑\" class=\"headerlink\" title=\"更多逻辑\"></a>更多逻辑</h4><p>线程池调度这块的实现有些复杂，这边先跳过，之后有机会再补。</p>\n<h3 id=\"closing\"><a href=\"#closing\" class=\"headerlink\" title=\"closing\"></a>closing</h3><p>通过closing队列来实现对长操作handle的关闭操作。<br>调用 uv_close 关闭handle后，libuv 会先释放其占用的资源（比如关闭 fd），随后通过调用 uv__make_close_pending 把 handle 连接到 closing_handles 队列中，该队列会在事件循环中被 uv__run_closing_handles(loop) 调用所执行。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv_close</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle, uv_close_cb close_cb)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!<span class=\"built_in\">uv__is_closing</span>(handle));</span><br><span class=\"line\"></span><br><span class=\"line\">  handle-&gt;flags |= UV_HANDLE_CLOSING;</span><br><span class=\"line\">  handle-&gt;close_cb = close_cb;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (handle-&gt;type) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据不同的 handle 类型，执行各自的资源回收工作</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_NAMED_PIPE:</span><br><span class=\"line\">    <span class=\"built_in\">uv__pipe_close</span>((<span class=\"type\">uv_pipe_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TTY:</span><br><span class=\"line\">    <span class=\"built_in\">uv__stream_close</span>((<span class=\"type\">uv_stream_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> UV_TCP:</span><br><span class=\"line\">    <span class=\"built_in\">uv__tcp_close</span>((<span class=\"type\">uv_tcp_t</span>*)handle);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 添加到 `loop-&gt;closing_handles`</span></span><br><span class=\"line\">  <span class=\"built_in\">uv__make_close_pending</span>(handle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">uv__make_close_pending</span><span class=\"params\">(<span class=\"type\">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class=\"line\">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class=\"line\">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Socket中的字节序转换","date":"2024-02-05T05:56:32.000Z","_content":"经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。\n# 转换类型相关api\n```cpp\nhtonl()--\"Host to Network Long\"\nntohl()--\"Network to Host Long\"\nhtons()--\"Host to Network Short\"\nntohs()--\"Network to Host Short\"  \n```\n# 两种字节序\n## 网络字节序NBO（Network Byte Order）\n按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。\n## 主机字节序HBO（Host Byte Order）\n不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。 \n如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。\n## 需要进行字节序转换原因\n由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。\n","source":"_posts/Byte-order-conversion.md","raw":"---\ntitle: Socket中的字节序转换\ndate: 2024-02-05 13:56:32\ntags: 随感杂记\n---\n经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。\n# 转换类型相关api\n```cpp\nhtonl()--\"Host to Network Long\"\nntohl()--\"Network to Host Long\"\nhtons()--\"Host to Network Short\"\nntohs()--\"Network to Host Short\"  \n```\n# 两种字节序\n## 网络字节序NBO（Network Byte Order）\n按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。\n## 主机字节序HBO（Host Byte Order）\n不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。 \n如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。\n## 需要进行字节序转换原因\n由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。\n","slug":"Byte-order-conversion","published":1,"updated":"2024-02-05T05:58:06.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8itme40000i2x55kln7r1i","content":"<p>经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。</p>\n<h1 id=\"转换类型相关api\"><a href=\"#转换类型相关api\" class=\"headerlink\" title=\"转换类型相关api\"></a>转换类型相关api</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">htonl</span>()--<span class=\"string\">&quot;Host to Network Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohl</span>()--<span class=\"string\">&quot;Network to Host Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">htons</span>()--<span class=\"string\">&quot;Host to Network Short&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohs</span>()--<span class=\"string\">&quot;Network to Host Short&quot;</span>  </span><br></pre></td></tr></table></figure>\n<h1 id=\"两种字节序\"><a href=\"#两种字节序\" class=\"headerlink\" title=\"两种字节序\"></a>两种字节序</h1><h2 id=\"网络字节序NBO（Network-Byte-Order）\"><a href=\"#网络字节序NBO（Network-Byte-Order）\" class=\"headerlink\" title=\"网络字节序NBO（Network Byte Order）\"></a>网络字节序NBO（Network Byte Order）</h2><p>按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>\n<h2 id=\"主机字节序HBO（Host-Byte-Order）\"><a href=\"#主机字节序HBO（Host-Byte-Order）\" class=\"headerlink\" title=\"主机字节序HBO（Host Byte Order）\"></a>主机字节序HBO（Host Byte Order）</h2><p>不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。<br>如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。</p>\n<h2 id=\"需要进行字节序转换原因\"><a href=\"#需要进行字节序转换原因\" class=\"headerlink\" title=\"需要进行字节序转换原因\"></a>需要进行字节序转换原因</h2><p>由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>经常忘记几个字节序转换的api名字，顺手记一下这几个api相关以加深印象。</p>\n<h1 id=\"转换类型相关api\"><a href=\"#转换类型相关api\" class=\"headerlink\" title=\"转换类型相关api\"></a>转换类型相关api</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">htonl</span>()--<span class=\"string\">&quot;Host to Network Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohl</span>()--<span class=\"string\">&quot;Network to Host Long&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">htons</span>()--<span class=\"string\">&quot;Host to Network Short&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">ntohs</span>()--<span class=\"string\">&quot;Network to Host Short&quot;</span>  </span><br></pre></td></tr></table></figure>\n<h1 id=\"两种字节序\"><a href=\"#两种字节序\" class=\"headerlink\" title=\"两种字节序\"></a>两种字节序</h1><h2 id=\"网络字节序NBO（Network-Byte-Order）\"><a href=\"#网络字节序NBO（Network-Byte-Order）\" class=\"headerlink\" title=\"网络字节序NBO（Network Byte Order）\"></a>网络字节序NBO（Network Byte Order）</h2><p>按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>\n<h2 id=\"主机字节序HBO（Host-Byte-Order）\"><a href=\"#主机字节序HBO（Host-Byte-Order）\" class=\"headerlink\" title=\"主机字节序HBO（Host Byte Order）\"></a>主机字节序HBO（Host Byte Order）</h2><p>不同的机器HBO不相同，与CPU设计有关，数据的顺序是由CPU决定的,而与操作系统无关。<br>如 Intel X86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78。</p>\n<h2 id=\"需要进行字节序转换原因\"><a href=\"#需要进行字节序转换原因\" class=\"headerlink\" title=\"需要进行字节序转换原因\"></a>需要进行字节序转换原因</h2><p>由于不同的字节序导致不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同powerpc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。</p>\n"},{"title":"性能优化（一）：概述","date":"2024-02-02T06:19:15.000Z","_content":"性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。\n# 性能优化的目的\n在计算机硬件/工程师价格和收益之间找一个平衡点。\n# 性能优化流程\n![image.png](/images/preformance-optimize-overview/1.png)\n# 程序性能优化方法\n性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。\n## 针对IO瓶颈的性能优化\n每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：\n\n1. 预先顺序读文件避免随机访问。\n2. 合并多个小文件为单个大文件。\n3. 优化动态库文件的加载。\n4. 交错IO时间和CPU时间。\n## 针对计算密集的性能优化\n计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：\n\n1. 去除冗余代码。\n2. 字符串操作优化。\n3. 减少内存分配、释放操作，例如使用内存池。\n4. 减少不必要的互斥锁操作。\n5. 根据性能需求选择数据结构。\n6. 延迟工作，按需执行。\n7. 减少跨进程的调用。\n8. 使用高性能的函数库。\n## C++特性相关的性能优化\nC++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。\n","source":"_posts/Preformance-optimize-1.md","raw":"---\ntitle: 性能优化（一）：概述\ndate: 2024-02-02 14:19:15\ntags: 性能优化\n---\n性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。\n# 性能优化的目的\n在计算机硬件/工程师价格和收益之间找一个平衡点。\n# 性能优化流程\n![image.png](/images/preformance-optimize-overview/1.png)\n# 程序性能优化方法\n性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。\n## 针对IO瓶颈的性能优化\n每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：\n\n1. 预先顺序读文件避免随机访问。\n2. 合并多个小文件为单个大文件。\n3. 优化动态库文件的加载。\n4. 交错IO时间和CPU时间。\n## 针对计算密集的性能优化\n计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：\n\n1. 去除冗余代码。\n2. 字符串操作优化。\n3. 减少内存分配、释放操作，例如使用内存池。\n4. 减少不必要的互斥锁操作。\n5. 根据性能需求选择数据结构。\n6. 延迟工作，按需执行。\n7. 减少跨进程的调用。\n8. 使用高性能的函数库。\n## C++特性相关的性能优化\nC++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。\n","slug":"Preformance-optimize-1","published":1,"updated":"2024-02-05T06:10:37.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8jg44f0000pxx5c6qtaeda","content":"<p>性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。</p>\n<h1 id=\"性能优化的目的\"><a href=\"#性能优化的目的\" class=\"headerlink\" title=\"性能优化的目的\"></a>性能优化的目的</h1><p>在计算机硬件&#x2F;工程师价格和收益之间找一个平衡点。</p>\n<h1 id=\"性能优化流程\"><a href=\"#性能优化流程\" class=\"headerlink\" title=\"性能优化流程\"></a>性能优化流程</h1><p><img src=\"/images/preformance-optimize-overview/1.png\" alt=\"image.png\"></p>\n<h1 id=\"程序性能优化方法\"><a href=\"#程序性能优化方法\" class=\"headerlink\" title=\"程序性能优化方法\"></a>程序性能优化方法</h1><p>性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。</p>\n<h2 id=\"针对IO瓶颈的性能优化\"><a href=\"#针对IO瓶颈的性能优化\" class=\"headerlink\" title=\"针对IO瓶颈的性能优化\"></a>针对IO瓶颈的性能优化</h2><p>每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：</p>\n<ol>\n<li>预先顺序读文件避免随机访问。</li>\n<li>合并多个小文件为单个大文件。</li>\n<li>优化动态库文件的加载。</li>\n<li>交错IO时间和CPU时间。</li>\n</ol>\n<h2 id=\"针对计算密集的性能优化\"><a href=\"#针对计算密集的性能优化\" class=\"headerlink\" title=\"针对计算密集的性能优化\"></a>针对计算密集的性能优化</h2><p>计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：</p>\n<ol>\n<li>去除冗余代码。</li>\n<li>字符串操作优化。</li>\n<li>减少内存分配、释放操作，例如使用内存池。</li>\n<li>减少不必要的互斥锁操作。</li>\n<li>根据性能需求选择数据结构。</li>\n<li>延迟工作，按需执行。</li>\n<li>减少跨进程的调用。</li>\n<li>使用高性能的函数库。</li>\n</ol>\n<h2 id=\"C-特性相关的性能优化\"><a href=\"#C-特性相关的性能优化\" class=\"headerlink\" title=\"C++特性相关的性能优化\"></a>C++特性相关的性能优化</h2><p>C++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>性能优化其实是个很泛泛而谈的概念，偶尔翻到了刚入职的时候，在进行性能优化项目前的一份思维导图的草稿，姑且把它简单整理成博文进行归档。现如今越是接触，越是感觉这个问题的复杂程度，从程序的外在表现，到具体的底层优化，都大有文章可做，留待之后再详细地汇总一下思路。</p>\n<h1 id=\"性能优化的目的\"><a href=\"#性能优化的目的\" class=\"headerlink\" title=\"性能优化的目的\"></a>性能优化的目的</h1><p>在计算机硬件&#x2F;工程师价格和收益之间找一个平衡点。</p>\n<h1 id=\"性能优化流程\"><a href=\"#性能优化流程\" class=\"headerlink\" title=\"性能优化流程\"></a>性能优化流程</h1><p><img src=\"/images/preformance-optimize-overview/1.png\" alt=\"image.png\"></p>\n<h1 id=\"程序性能优化方法\"><a href=\"#程序性能优化方法\" class=\"headerlink\" title=\"程序性能优化方法\"></a>程序性能优化方法</h1><p>性能问题分析完成后，需要进行性能优化。根据性能分析结果的不同，优化方法也各有不同。</p>\n<h2 id=\"针对IO瓶颈的性能优化\"><a href=\"#针对IO瓶颈的性能优化\" class=\"headerlink\" title=\"针对IO瓶颈的性能优化\"></a>针对IO瓶颈的性能优化</h2><p>每次IO操作大概在10ms量级，100次就需要1秒左右，因此尽量避免不必要的IO操作。具体做法如下：</p>\n<ol>\n<li>预先顺序读文件避免随机访问。</li>\n<li>合并多个小文件为单个大文件。</li>\n<li>优化动态库文件的加载。</li>\n<li>交错IO时间和CPU时间。</li>\n</ol>\n<h2 id=\"针对计算密集的性能优化\"><a href=\"#针对计算密集的性能优化\" class=\"headerlink\" title=\"针对计算密集的性能优化\"></a>针对计算密集的性能优化</h2><p>计算密集的性能问题主要有内存分配性能、字符串操作、共享变量的互斥锁保护等，具体优化方法如下：</p>\n<ol>\n<li>去除冗余代码。</li>\n<li>字符串操作优化。</li>\n<li>减少内存分配、释放操作，例如使用内存池。</li>\n<li>减少不必要的互斥锁操作。</li>\n<li>根据性能需求选择数据结构。</li>\n<li>延迟工作，按需执行。</li>\n<li>减少跨进程的调用。</li>\n<li>使用高性能的函数库。</li>\n</ol>\n<h2 id=\"C-特性相关的性能优化\"><a href=\"#C-特性相关的性能优化\" class=\"headerlink\" title=\"C++特性相关的性能优化\"></a>C++特性相关的性能优化</h2><p>C++语言特性相关的性能优化包括模板展开、内联函数、引用、编译优化选项等。</p>\n"},{"title":"性能优化（二）：交易系统","date":"2024-02-05T06:11:05.000Z","_content":"> 如果你对性能不敏感的话，你不应该直接写python调库吗？\n\n# 接收数据前网络时延\n和软件提供商，期货公司，交易所之间的连接。\n# 数据进入CPU前时延\n尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果\n# 具体的服务器设置\n\n- disable hyperthreading\n- turn on over clocking\n- disable Nagle's algorithm\n- set cpu affinity and isolation\n# 代码编程注意点\n### 能用单线程，就不要多线程\n如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全\n### 优化剪短关键路径\n### 降低run-time处理数据的复杂度\n能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。\n### 避免run-time的memory allocation\n可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。\n### 允许undefined behavior的存在\n要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。\n### 利用好cache\n尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。\n\n- 尽量让可能被同时使用的数据挨在一起\n- 减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）\n- 尽量节省内存（比如用unique_ptr<Data[]>取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）\n- 指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）\n- 会被多个核同时读写的数据按照缓存行对齐（避免false sharing）\n### 注意struct padding\n### 避免不必要的branch和table lookup\n使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。\n### 确定合适的container\n部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。\n### 用好编译器提供的builtins\n比如__expected，__prefetch之类\n### 了解编译器和连接器在做什么\n最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2/O3的优化，因为各种原因，反而会让代码变慢。比如： https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\n# 参考链接 \n\n- optiver的cppcon17分享：https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\n- DRW前员工Matt Godbolt的分享：https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\n- 如何使用cache friendly代码：https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\n","source":"_posts/Preformance-optimize-2.md","raw":"---\ntitle: 性能优化（二）：交易系统\ndate: 2024-02-05 14:11:05\ntags: 性能优化\n---\n> 如果你对性能不敏感的话，你不应该直接写python调库吗？\n\n# 接收数据前网络时延\n和软件提供商，期货公司，交易所之间的连接。\n# 数据进入CPU前时延\n尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果\n# 具体的服务器设置\n\n- disable hyperthreading\n- turn on over clocking\n- disable Nagle's algorithm\n- set cpu affinity and isolation\n# 代码编程注意点\n### 能用单线程，就不要多线程\n如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全\n### 优化剪短关键路径\n### 降低run-time处理数据的复杂度\n能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。\n### 避免run-time的memory allocation\n可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。\n### 允许undefined behavior的存在\n要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。\n### 利用好cache\n尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。\n\n- 尽量让可能被同时使用的数据挨在一起\n- 减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）\n- 尽量节省内存（比如用unique_ptr<Data[]>取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）\n- 指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）\n- 会被多个核同时读写的数据按照缓存行对齐（避免false sharing）\n### 注意struct padding\n### 避免不必要的branch和table lookup\n使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。\n### 确定合适的container\n部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。\n### 用好编译器提供的builtins\n比如__expected，__prefetch之类\n### 了解编译器和连接器在做什么\n最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2/O3的优化，因为各种原因，反而会让代码变慢。比如： https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\n# 参考链接 \n\n- optiver的cppcon17分享：https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\n- DRW前员工Matt Godbolt的分享：https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\n- 如何使用cache friendly代码：https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\n","slug":"Preformance-optimize-2","published":1,"updated":"2024-02-05T06:14:36.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8jg44j0001pxx5gg823l2o","content":"<blockquote>\n<p>如果你对性能不敏感的话，你不应该直接写python调库吗？</p>\n</blockquote>\n<h1 id=\"接收数据前网络时延\"><a href=\"#接收数据前网络时延\" class=\"headerlink\" title=\"接收数据前网络时延\"></a>接收数据前网络时延</h1><p>和软件提供商，期货公司，交易所之间的连接。</p>\n<h1 id=\"数据进入CPU前时延\"><a href=\"#数据进入CPU前时延\" class=\"headerlink\" title=\"数据进入CPU前时延\"></a>数据进入CPU前时延</h1><p>尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果</p>\n<h1 id=\"具体的服务器设置\"><a href=\"#具体的服务器设置\" class=\"headerlink\" title=\"具体的服务器设置\"></a>具体的服务器设置</h1><ul>\n<li>disable hyperthreading</li>\n<li>turn on over clocking</li>\n<li>disable Nagle’s algorithm</li>\n<li>set cpu affinity and isolation</li>\n</ul>\n<h1 id=\"代码编程注意点\"><a href=\"#代码编程注意点\" class=\"headerlink\" title=\"代码编程注意点\"></a>代码编程注意点</h1><h3 id=\"能用单线程，就不要多线程\"><a href=\"#能用单线程，就不要多线程\" class=\"headerlink\" title=\"能用单线程，就不要多线程\"></a>能用单线程，就不要多线程</h3><p>如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全</p>\n<h3 id=\"优化剪短关键路径\"><a href=\"#优化剪短关键路径\" class=\"headerlink\" title=\"优化剪短关键路径\"></a>优化剪短关键路径</h3><h3 id=\"降低run-time处理数据的复杂度\"><a href=\"#降低run-time处理数据的复杂度\" class=\"headerlink\" title=\"降低run-time处理数据的复杂度\"></a>降低run-time处理数据的复杂度</h3><p>能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。</p>\n<h3 id=\"避免run-time的memory-allocation\"><a href=\"#避免run-time的memory-allocation\" class=\"headerlink\" title=\"避免run-time的memory allocation\"></a>避免run-time的memory allocation</h3><p>可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。</p>\n<h3 id=\"允许undefined-behavior的存在\"><a href=\"#允许undefined-behavior的存在\" class=\"headerlink\" title=\"允许undefined behavior的存在\"></a>允许undefined behavior的存在</h3><p>要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。</p>\n<h3 id=\"利用好cache\"><a href=\"#利用好cache\" class=\"headerlink\" title=\"利用好cache\"></a>利用好cache</h3><p>尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。</p>\n<ul>\n<li>尽量让可能被同时使用的数据挨在一起</li>\n<li>减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）</li>\n<li>尽量节省内存（比如用unique_ptr&lt;Data[]&gt;取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）</li>\n<li>指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）</li>\n<li>会被多个核同时读写的数据按照缓存行对齐（避免false sharing）</li>\n</ul>\n<h3 id=\"注意struct-padding\"><a href=\"#注意struct-padding\" class=\"headerlink\" title=\"注意struct padding\"></a>注意struct padding</h3><h3 id=\"避免不必要的branch和table-lookup\"><a href=\"#避免不必要的branch和table-lookup\" class=\"headerlink\" title=\"避免不必要的branch和table lookup\"></a>避免不必要的branch和table lookup</h3><p>使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。</p>\n<h3 id=\"确定合适的container\"><a href=\"#确定合适的container\" class=\"headerlink\" title=\"确定合适的container\"></a>确定合适的container</h3><p>部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。</p>\n<h3 id=\"用好编译器提供的builtins\"><a href=\"#用好编译器提供的builtins\" class=\"headerlink\" title=\"用好编译器提供的builtins\"></a>用好编译器提供的builtins</h3><p>比如__expected，__prefetch之类</p>\n<h3 id=\"了解编译器和连接器在做什么\"><a href=\"#了解编译器和连接器在做什么\" class=\"headerlink\" title=\"了解编译器和连接器在做什么\"></a>了解编译器和连接器在做什么</h3><p>最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2&#x2F;O3的优化，因为各种原因，反而会让代码变慢。比如： <a href=\"https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\">https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82</a></p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li>optiver的cppcon17分享：<a href=\"https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\">https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82</a></li>\n<li>DRW前员工Matt Godbolt的分享：<a href=\"https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\">https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82</a></li>\n<li>如何使用cache friendly代码：<a href=\"https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\">https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>如果你对性能不敏感的话，你不应该直接写python调库吗？</p>\n</blockquote>\n<h1 id=\"接收数据前网络时延\"><a href=\"#接收数据前网络时延\" class=\"headerlink\" title=\"接收数据前网络时延\"></a>接收数据前网络时延</h1><p>和软件提供商，期货公司，交易所之间的连接。</p>\n<h1 id=\"数据进入CPU前时延\"><a href=\"#数据进入CPU前时延\" class=\"headerlink\" title=\"数据进入CPU前时延\"></a>数据进入CPU前时延</h1><p>尽量减少数据拷贝以及context switches。比如Solarflare的nic卡就是通过interrupt kernel来达到kernel bypassing的效果</p>\n<h1 id=\"具体的服务器设置\"><a href=\"#具体的服务器设置\" class=\"headerlink\" title=\"具体的服务器设置\"></a>具体的服务器设置</h1><ul>\n<li>disable hyperthreading</li>\n<li>turn on over clocking</li>\n<li>disable Nagle’s algorithm</li>\n<li>set cpu affinity and isolation</li>\n</ul>\n<h1 id=\"代码编程注意点\"><a href=\"#代码编程注意点\" class=\"headerlink\" title=\"代码编程注意点\"></a>代码编程注意点</h1><h3 id=\"能用单线程，就不要多线程\"><a href=\"#能用单线程，就不要多线程\" class=\"headerlink\" title=\"能用单线程，就不要多线程\"></a>能用单线程，就不要多线程</h3><p>如果必须存在IPC，那么使用共享内存作为唯一的IPC机制，可能需要手动实现无锁内存池、无锁队列和顺序锁等来保证共享的数据在多进程下是安全</p>\n<h3 id=\"优化剪短关键路径\"><a href=\"#优化剪短关键路径\" class=\"headerlink\" title=\"优化剪短关键路径\"></a>优化剪短关键路径</h3><h3 id=\"降低run-time处理数据的复杂度\"><a href=\"#降低run-time处理数据的复杂度\" class=\"headerlink\" title=\"降低run-time处理数据的复杂度\"></a>降低run-time处理数据的复杂度</h3><p>能用CRTP的地方就别用dynamic polymorphism。能用expression templates来帮助计算的，就可以考虑使用它。</p>\n<h3 id=\"避免run-time的memory-allocation\"><a href=\"#避免run-time的memory-allocation\" class=\"headerlink\" title=\"避免run-time的memory allocation\"></a>避免run-time的memory allocation</h3><p>可以考虑重复使用同类的object，或者是memory pool，这样可以避免overhead，也可以减少memory fragmentation。</p>\n<h3 id=\"允许undefined-behavior的存在\"><a href=\"#允许undefined-behavior的存在\" class=\"headerlink\" title=\"允许undefined behavior的存在\"></a>允许undefined behavior的存在</h3><p>要了解自己待处理的数据，这样在一定条件下可以允许undefined behavior的存在。比如，vector[] vs vector.at()，因为safety check有时候都会expensive。</p>\n<h3 id=\"利用好cache\"><a href=\"#利用好cache\" class=\"headerlink\" title=\"利用好cache\"></a>利用好cache</h3><p>尽量使用contiguous blocks of memory。基本的规则大概就是： 能在cache里面存下data和instructions，就不用access main memory，能在registers里面存下，就不要access cache。</p>\n<ul>\n<li>尽量让可能被同时使用的数据挨在一起</li>\n<li>减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）</li>\n<li>尽量节省内存（比如用unique_ptr&lt;Data[]&gt;取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）</li>\n<li>指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）</li>\n<li>会被多个核同时读写的数据按照缓存行对齐（避免false sharing）</li>\n</ul>\n<h3 id=\"注意struct-padding\"><a href=\"#注意struct-padding\" class=\"headerlink\" title=\"注意struct padding\"></a>注意struct padding</h3><h3 id=\"避免不必要的branch和table-lookup\"><a href=\"#避免不必要的branch和table-lookup\" class=\"headerlink\" title=\"避免不必要的branch和table lookup\"></a>避免不必要的branch和table lookup</h3><p>使用virtual functions和大量叠加的if语句，都有可能增加cache misses和pipeline clearances的可能性。</p>\n<h3 id=\"确定合适的container\"><a href=\"#确定合适的container\" class=\"headerlink\" title=\"确定合适的container\"></a>确定合适的container</h3><p>部分STL中的container比如std::undered_map，性能对于低时延系统就不够用。</p>\n<h3 id=\"用好编译器提供的builtins\"><a href=\"#用好编译器提供的builtins\" class=\"headerlink\" title=\"用好编译器提供的builtins\"></a>用好编译器提供的builtins</h3><p>比如__expected，__prefetch之类</p>\n<h3 id=\"了解编译器和连接器在做什么\"><a href=\"#了解编译器和连接器在做什么\" class=\"headerlink\" title=\"了解编译器和连接器在做什么\"></a>了解编译器和连接器在做什么</h3><p>最好不要简单的假设-O2就可以帮你解决全部问题。有时候，O2&#x2F;O3的优化，因为各种原因，反而会让代码变慢。比如： <a href=\"https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82\">https://stackoverflow.com/questions/43651923/gcc-fails-to-optimize-aligned-stdarray-like-c-array%E3%80%82</a></p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li>optiver的cppcon17分享：<a href=\"https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82\">https://www.youtube.com/watch?v=NH1Tta7purM%E3%80%82</a></li>\n<li>DRW前员工Matt Godbolt的分享：<a href=\"https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82\">https://www.youtube.com/watch?v=fV6qYho-XVs%E3%80%82</a></li>\n<li>如何使用cache friendly代码：<a href=\"https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html\">https://cppatomic.blogspot.com/2018/02/cache-friendly-code.html</a></li>\n</ul>\n"},{"title":"Linux下高精度测时","date":"2024-02-05T07:01:25.000Z","_content":"目前大多数Linux下的高精度测试基本通过tsc寄存器实现的，简单记录一下可能存在的问题。\n## 如何获取tsc\nX86 平台提供读取tsc的指令 **rdtsc/rdtscp** 可以用户态轻量获取tsc的值。\n相比vsdo提供的**gettimeofday**更高效。\n## tsc的可靠性问题\n\n- **Invariant**：单核情况下的tsc受cpu动态变化的主频影响，进入某些异常状态下（C-State状态--尚未研究这个状态会发生什么）甚至会停止计数。\n- **Reliable**：多核情况下的tsc可能存在不同步，存在一个核间的“可视时延”（找不到准确翻译了），大致就是核间所见非所得的情况。\n## 可靠性问题解法\n### 单核情况下的解法\n存疑-未详细验证：intel在x86的cpu层面做出了增强，新增了两个特性\n\n- **constant_tsc**：含义是以固定的频率跳动，与cpu当前的频率无关。\n- **nonstop_tsc**：进入C-State也不会停止跳动。\n\n解决了单核情况下的问题，使得tsc以理想的恒定频率跳动。\n### 多核架构下的解法\nLinux 内核启动时，探测tsc是否同步，采用尝试校准多个核心上的tsc以相同的频率和起始值启动运行。这通过写入MSR寄存器值来设置tsc的特性，需要cpu支持，目前仅仅intel的cpu才可能被认为是多核同步的。如果tsc经过内核测试和校准，被认为是可以核心间同步的，则会被当作时钟源来使用。\n通过下面指令来确定时钟源：\n```\nsudo cat /sys/devices/system/clocksource/clocksource0/current_clocksource\n```\n# TSCNS代码的解读\n对外提供的主要接口以及实现\n## init\n初始化数据\nvoid init(int64_t init_calibrate_ns, int64_t calibrate_interval_ns)\n双参数可设置，用以确定初始校准等待时间和校准间隔时间 \n## getTscGhz\n通过算数运算计算CPU主频\n算数计算公式\nexpected_err_at_next_calibration = ns_err + (ns_err - last_ns_err) / (ns - last_ns) * calibate_interval_ns;\nnew_ns_per_tsc =ns_per_tsc * (1.0 - expected_err_at_next_calibration / calibate_interval_ns)\nTscGhz = 1.0 / new_ns_per_tsc \n## calibrate\nThe calibrate() function is non-blocking and cheap to call but not thread-safe, so user should have only one thread calling it. The calibrations will adjust tsc frequency in the library to trace that of the system clock and keep timestamp divergence in a minimum level.\n## rdns\nGetting nanosecond timestamp in a single step.\n# 参考链接\n\n- http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#32-software-tsc-usage-bugs\n- https://github.com/MengRao/tscns\n\n","source":"_posts/Measure-time.md","raw":"---\ntitle: Linux下高精度测时\ndate: 2024-02-05 15:01:25\ntags: 随感杂记\n---\n目前大多数Linux下的高精度测试基本通过tsc寄存器实现的，简单记录一下可能存在的问题。\n## 如何获取tsc\nX86 平台提供读取tsc的指令 **rdtsc/rdtscp** 可以用户态轻量获取tsc的值。\n相比vsdo提供的**gettimeofday**更高效。\n## tsc的可靠性问题\n\n- **Invariant**：单核情况下的tsc受cpu动态变化的主频影响，进入某些异常状态下（C-State状态--尚未研究这个状态会发生什么）甚至会停止计数。\n- **Reliable**：多核情况下的tsc可能存在不同步，存在一个核间的“可视时延”（找不到准确翻译了），大致就是核间所见非所得的情况。\n## 可靠性问题解法\n### 单核情况下的解法\n存疑-未详细验证：intel在x86的cpu层面做出了增强，新增了两个特性\n\n- **constant_tsc**：含义是以固定的频率跳动，与cpu当前的频率无关。\n- **nonstop_tsc**：进入C-State也不会停止跳动。\n\n解决了单核情况下的问题，使得tsc以理想的恒定频率跳动。\n### 多核架构下的解法\nLinux 内核启动时，探测tsc是否同步，采用尝试校准多个核心上的tsc以相同的频率和起始值启动运行。这通过写入MSR寄存器值来设置tsc的特性，需要cpu支持，目前仅仅intel的cpu才可能被认为是多核同步的。如果tsc经过内核测试和校准，被认为是可以核心间同步的，则会被当作时钟源来使用。\n通过下面指令来确定时钟源：\n```\nsudo cat /sys/devices/system/clocksource/clocksource0/current_clocksource\n```\n# TSCNS代码的解读\n对外提供的主要接口以及实现\n## init\n初始化数据\nvoid init(int64_t init_calibrate_ns, int64_t calibrate_interval_ns)\n双参数可设置，用以确定初始校准等待时间和校准间隔时间 \n## getTscGhz\n通过算数运算计算CPU主频\n算数计算公式\nexpected_err_at_next_calibration = ns_err + (ns_err - last_ns_err) / (ns - last_ns) * calibate_interval_ns;\nnew_ns_per_tsc =ns_per_tsc * (1.0 - expected_err_at_next_calibration / calibate_interval_ns)\nTscGhz = 1.0 / new_ns_per_tsc \n## calibrate\nThe calibrate() function is non-blocking and cheap to call but not thread-safe, so user should have only one thread calling it. The calibrations will adjust tsc frequency in the library to trace that of the system clock and keep timestamp divergence in a minimum level.\n## rdns\nGetting nanosecond timestamp in a single step.\n# 参考链接\n\n- http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#32-software-tsc-usage-bugs\n- https://github.com/MengRao/tscns\n\n","slug":"Measure-time","published":1,"updated":"2024-02-05T07:03:57.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cls8l6zba0000xqx5gbvb5dgi","content":"<p>目前大多数Linux下的高精度测试基本通过tsc寄存器实现的，简单记录一下可能存在的问题。</p>\n<h2 id=\"如何获取tsc\"><a href=\"#如何获取tsc\" class=\"headerlink\" title=\"如何获取tsc\"></a>如何获取tsc</h2><p>X86 平台提供读取tsc的指令 <strong>rdtsc&#x2F;rdtscp</strong> 可以用户态轻量获取tsc的值。<br>相比vsdo提供的<strong>gettimeofday</strong>更高效。</p>\n<h2 id=\"tsc的可靠性问题\"><a href=\"#tsc的可靠性问题\" class=\"headerlink\" title=\"tsc的可靠性问题\"></a>tsc的可靠性问题</h2><ul>\n<li><strong>Invariant</strong>：单核情况下的tsc受cpu动态变化的主频影响，进入某些异常状态下（C-State状态–尚未研究这个状态会发生什么）甚至会停止计数。</li>\n<li><strong>Reliable</strong>：多核情况下的tsc可能存在不同步，存在一个核间的“可视时延”（找不到准确翻译了），大致就是核间所见非所得的情况。</li>\n</ul>\n<h2 id=\"可靠性问题解法\"><a href=\"#可靠性问题解法\" class=\"headerlink\" title=\"可靠性问题解法\"></a>可靠性问题解法</h2><h3 id=\"单核情况下的解法\"><a href=\"#单核情况下的解法\" class=\"headerlink\" title=\"单核情况下的解法\"></a>单核情况下的解法</h3><p>存疑-未详细验证：intel在x86的cpu层面做出了增强，新增了两个特性</p>\n<ul>\n<li><strong>constant_tsc</strong>：含义是以固定的频率跳动，与cpu当前的频率无关。</li>\n<li><strong>nonstop_tsc</strong>：进入C-State也不会停止跳动。</li>\n</ul>\n<p>解决了单核情况下的问题，使得tsc以理想的恒定频率跳动。</p>\n<h3 id=\"多核架构下的解法\"><a href=\"#多核架构下的解法\" class=\"headerlink\" title=\"多核架构下的解法\"></a>多核架构下的解法</h3><p>Linux 内核启动时，探测tsc是否同步，采用尝试校准多个核心上的tsc以相同的频率和起始值启动运行。这通过写入MSR寄存器值来设置tsc的特性，需要cpu支持，目前仅仅intel的cpu才可能被认为是多核同步的。如果tsc经过内核测试和校准，被认为是可以核心间同步的，则会被当作时钟源来使用。<br>通过下面指令来确定时钟源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span><br></pre></td></tr></table></figure>\n<h1 id=\"TSCNS代码的解读\"><a href=\"#TSCNS代码的解读\" class=\"headerlink\" title=\"TSCNS代码的解读\"></a>TSCNS代码的解读</h1><p>对外提供的主要接口以及实现</p>\n<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2><p>初始化数据<br>void init(int64_t init_calibrate_ns, int64_t calibrate_interval_ns)<br>双参数可设置，用以确定初始校准等待时间和校准间隔时间 </p>\n<h2 id=\"getTscGhz\"><a href=\"#getTscGhz\" class=\"headerlink\" title=\"getTscGhz\"></a>getTscGhz</h2><p>通过算数运算计算CPU主频<br>算数计算公式<br>expected_err_at_next_calibration &#x3D; ns_err + (ns_err - last_ns_err) &#x2F; (ns - last_ns) * calibate_interval_ns;<br>new_ns_per_tsc &#x3D;ns_per_tsc * (1.0 - expected_err_at_next_calibration &#x2F; calibate_interval_ns)<br>TscGhz &#x3D; 1.0 &#x2F; new_ns_per_tsc </p>\n<h2 id=\"calibrate\"><a href=\"#calibrate\" class=\"headerlink\" title=\"calibrate\"></a>calibrate</h2><p>The calibrate() function is non-blocking and cheap to call but not thread-safe, so user should have only one thread calling it. The calibrations will adjust tsc frequency in the library to trace that of the system clock and keep timestamp divergence in a minimum level.</p>\n<h2 id=\"rdns\"><a href=\"#rdns\" class=\"headerlink\" title=\"rdns\"></a>rdns</h2><p>Getting nanosecond timestamp in a single step.</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#32-software-tsc-usage-bugs\">http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#32-software-tsc-usage-bugs</a></li>\n<li><a href=\"https://github.com/MengRao/tscns\">https://github.com/MengRao/tscns</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>目前大多数Linux下的高精度测试基本通过tsc寄存器实现的，简单记录一下可能存在的问题。</p>\n<h2 id=\"如何获取tsc\"><a href=\"#如何获取tsc\" class=\"headerlink\" title=\"如何获取tsc\"></a>如何获取tsc</h2><p>X86 平台提供读取tsc的指令 <strong>rdtsc&#x2F;rdtscp</strong> 可以用户态轻量获取tsc的值。<br>相比vsdo提供的<strong>gettimeofday</strong>更高效。</p>\n<h2 id=\"tsc的可靠性问题\"><a href=\"#tsc的可靠性问题\" class=\"headerlink\" title=\"tsc的可靠性问题\"></a>tsc的可靠性问题</h2><ul>\n<li><strong>Invariant</strong>：单核情况下的tsc受cpu动态变化的主频影响，进入某些异常状态下（C-State状态–尚未研究这个状态会发生什么）甚至会停止计数。</li>\n<li><strong>Reliable</strong>：多核情况下的tsc可能存在不同步，存在一个核间的“可视时延”（找不到准确翻译了），大致就是核间所见非所得的情况。</li>\n</ul>\n<h2 id=\"可靠性问题解法\"><a href=\"#可靠性问题解法\" class=\"headerlink\" title=\"可靠性问题解法\"></a>可靠性问题解法</h2><h3 id=\"单核情况下的解法\"><a href=\"#单核情况下的解法\" class=\"headerlink\" title=\"单核情况下的解法\"></a>单核情况下的解法</h3><p>存疑-未详细验证：intel在x86的cpu层面做出了增强，新增了两个特性</p>\n<ul>\n<li><strong>constant_tsc</strong>：含义是以固定的频率跳动，与cpu当前的频率无关。</li>\n<li><strong>nonstop_tsc</strong>：进入C-State也不会停止跳动。</li>\n</ul>\n<p>解决了单核情况下的问题，使得tsc以理想的恒定频率跳动。</p>\n<h3 id=\"多核架构下的解法\"><a href=\"#多核架构下的解法\" class=\"headerlink\" title=\"多核架构下的解法\"></a>多核架构下的解法</h3><p>Linux 内核启动时，探测tsc是否同步，采用尝试校准多个核心上的tsc以相同的频率和起始值启动运行。这通过写入MSR寄存器值来设置tsc的特性，需要cpu支持，目前仅仅intel的cpu才可能被认为是多核同步的。如果tsc经过内核测试和校准，被认为是可以核心间同步的，则会被当作时钟源来使用。<br>通过下面指令来确定时钟源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span><br></pre></td></tr></table></figure>\n<h1 id=\"TSCNS代码的解读\"><a href=\"#TSCNS代码的解读\" class=\"headerlink\" title=\"TSCNS代码的解读\"></a>TSCNS代码的解读</h1><p>对外提供的主要接口以及实现</p>\n<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2><p>初始化数据<br>void init(int64_t init_calibrate_ns, int64_t calibrate_interval_ns)<br>双参数可设置，用以确定初始校准等待时间和校准间隔时间 </p>\n<h2 id=\"getTscGhz\"><a href=\"#getTscGhz\" class=\"headerlink\" title=\"getTscGhz\"></a>getTscGhz</h2><p>通过算数运算计算CPU主频<br>算数计算公式<br>expected_err_at_next_calibration &#x3D; ns_err + (ns_err - last_ns_err) &#x2F; (ns - last_ns) * calibate_interval_ns;<br>new_ns_per_tsc &#x3D;ns_per_tsc * (1.0 - expected_err_at_next_calibration &#x2F; calibate_interval_ns)<br>TscGhz &#x3D; 1.0 &#x2F; new_ns_per_tsc </p>\n<h2 id=\"calibrate\"><a href=\"#calibrate\" class=\"headerlink\" title=\"calibrate\"></a>calibrate</h2><p>The calibrate() function is non-blocking and cheap to call but not thread-safe, so user should have only one thread calling it. The calibrations will adjust tsc frequency in the library to trace that of the system clock and keep timestamp divergence in a minimum level.</p>\n<h2 id=\"rdns\"><a href=\"#rdns\" class=\"headerlink\" title=\"rdns\"></a>rdns</h2><p>Getting nanosecond timestamp in a single step.</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#32-software-tsc-usage-bugs\">http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#32-software-tsc-usage-bugs</a></li>\n<li><a href=\"https://github.com/MengRao/tscns\">https://github.com/MengRao/tscns</a></li>\n</ul>\n"},{"title":"模板编程（一）：特化","date":"2024-02-08T17:25:55.000Z","_content":"这是模板编程系列的第一篇，主要回顾了模板的基础和特化与偏特化的实现语法。\n# 模版的介绍\n## 模板的基本概念\n模板（Templates）是编程语言提供的一种泛型编程机制，允许程序员编写通用的代码，而不需要指定具体数据类型，使得可以处理多种数据类型而不必为每种类型编写特定的代码。\n在C++中，可以通过 template 这个关键字来定义和实现基础的模板编程。\n## 模板的本质——从运行期到编译期\n模板的功能看起来非常吸引人，编译器智能地根据输入的类型选择对应的对该类型的处理逻辑，似乎是一种非常理想的**编程范式1**，在这种范式之下，我们的代码优雅得可以消灭一切对类型判断的if-else分支。那么编译器的这种智能的表象下的本质是什么：\n> 在我看来，模板的本质是代码枚举，将代码在运行期间的可能性，转移到编译期间通过编译器对代码的枚举进行覆盖。\n\n上面的本质是我对模板的一种粗暴的、不准确的、但是易于理解的总结，姑且写在文章开头，可以留待之后的文章中继续讨论。\n# 模板的基础语法\n在开始实践之前，先简单回顾一下模板的基础语法和一些编程规则。\n## 模板类和模板函数\n模板类和模板函数是模板的最基础的应用，也是平常使用中接触的最多的使用方式。\n在模板类中，传入的模板参数一般被用来替换类中元素的类型，使得同一个类在模板的帮助下表现出泛化的特性。\n平时基于可读性和分离编译考虑，如下面的示例，我一般会更喜欢把模板类内的函数实现放在类的外部。\n```cpp\ntemplate <typename T>\nclass vector\n{\npublic:\n\t// 这里只有声明\n    void clear();            \nprivate:\n    T* elements;\n};\n// 函数的实现放在这里\ntemplate <typename T>\nvoid vector<T>::clear()        \n{\n    // Function body\n}\n```\n相较于模板类的模板参数的占位对象的统一，模板函数的占位对象会显得更多五花八门。\n在模板函数中，除了函数名和形参之外，函数签名之中其他部分都可以用占位符代替。甚至函数内的对象的类型也可以是占位符，这就导致模板函数的形式很多样化。\n```cpp\ntemplate <typename T> \nvoid foo(T const& v);\n\ntemplate <typename T> \nT foo();\n\ntemplate <typename T, typename U> \nU foo(T const&);\n\ntemplate <typename T> \nvoid foo()\n{\n    T var;\n    // ...\n}\n```\n事实上，除了typename关键字外，还有一种模板整型的应用场景，在这种场景下，整型模版参数的作用，就是定义一个常数，替一个常数占位。\n```cpp\ntemplate <int Size> struct Array\n{\n    int data[Size];\n};\n\nArray<16> arr;\n```\n# 模板特化与偏特化\n> 所谓模板特例化即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization），另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization）。\n> 用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。\n\n当然，其实如果把模板当作是一门独立的图灵完备的编程语言的话，那么模板的特化与偏特化其实是这个语言中“if else then”的逻辑判断语句，实现了根据“入参”进行判断从而走向不同的分支，这也是模板元编程的基础之一，当然这一点会在之后的篇章详细展开。\n## 模板特化\n如果说，模板提供给了我们很好的对公共特性的抽象能力，那么，模版的特化，就是给予我们针对一些非公共特性进行特殊化的处理。类比成面向对象的抽象，基类可以类比为模板抽象出了最大公约数的能力，那么部分特殊的能力就由继承基类的派生类来实现。\n最基本的代码示例如下：\n```cpp\n// 模板的一般形式（原型）\ntemplate <typename T> class AddFloatOrMulInt\n{\n    static T Do(T a, T b)\n    {\n        return T(0);\n    }\n};\n\n// 指定T是int时候的特化\ntemplate <> class AddFloatOrMulInt<int>\n{\npublic:\n    static int Do(int a, int b)  \n    {\n        return a * b;\n    }\n};\n\n// 指定T是float时候的特化\ntemplate <> class AddFloatOrMulInt<float>\n{\npublic:\n    static float Do(float a, float b)\n    {\n        return a + b;\n    }\n};\n```\n在这个示例中，模板函数除了针对泛化的类型提供了能力之外，还对int或者float两种类型进行了特化处理，自定义了一些操作以应对他们所需要的区别性。\n## 模板偏特化\n如果说模板的特化是对某个固定的类型进行特化处理，那么偏特化可以理解为批量特化，即对批量符合特征的类型进行特化处理：比如说如果传入指针则进行特化处理。\n如下面的示例所示，该模版的偏特化实现了对所有传入类型是指针的批量特化。\n```cpp\n// 通用模板\ntemplate <typename T>\nstruct MyTemplate {\n    void print() {\n        std::cout << \"Generic Template\" << std::endl;\n    }\n};\n\n// 模板偏特化：当传入类型是指针时\ntemplate <typename T>\nstruct MyTemplate<T*> {\n    void print() {\n        std::cout << \"Partial Specialization for Pointers\" << std::endl;\n    }\n};\n```\n或者如下的另外一个例子，实现了对传入的两个类型相同时候的批量特化。\n```cpp\n// 通用模板\ntemplate <typename T, typename U>\nstruct MyTemplate {\n    void print() {\n        std::cout << \"Generic Template\" << std::endl;\n    }\n};\n\n// 模板偏特化：当两个模板参数相同时\ntemplate <typename T>\nstruct MyTemplate<T, T> {\n    void print() {\n        std::cout << \"Partial Specialization for T and T\" << std::endl;\n    }\n};\n```\n## 不定长模板参数\n在C++11中，引入了变参模板（Variadic Template），这一特性拓展了模板的参数的自由度，我们可以通过tuple在C++11标准发布前后的变更来了解变参模板的使用。\n引入变参模板之前，**tuple代码2**如下：\n```cpp\n// Tuple 的声明，来自 boost\nstruct null_type;\n\ntemplate <\n  class T0 = null_type, class T1 = null_type, class T2 = null_type,\n  class T3 = null_type, class T4 = null_type, class T5 = null_type,\n  class T6 = null_type, class T7 = null_type, class T8 = null_type,\n  class T9 = null_type>\nclass tuple;\n\n// Tuple的一些用例\ntuple<int> a;\ntuple<double&, const double&, const double, double*, const double*> b;\ntuple<A, int(*)(char, int), B(A::*)(C&), C> c;\ntuple<std::string, std::pair<A, B> > d;\ntuple<A*, tuple<const A*, const B&, C>, bool, void*> e;\n```\n这是tuple在boost中的实现，但是这个方案的缺陷很明显：代码臃肿和潜在的正确性问题。此外，过度使用模板偏特化、大量冗余的类型参数也给编译器带来了沉重的负担。此外，boost中也还有不少类似实现，比如MPL库也使用了这个手法将boost::mpl::vector映射到boost::mpl::vector _n_上。\n在引入了变参模板之后，tuple的模板可以被如此实现：\n```cpp\ntemplate <typename... Ts> class tuple;\n```\n这里的typename... Ts相当于一个声明，是说Ts不是一个类型，而是一个不定常的类型列表。需要注意的是，因为C++的模板是自左向右匹配的，所以不定长参数只能结尾。\n```cpp\n//模板的原型\ntemplate <typename... Ts, typename U> class X {};              // (1) error!\ntemplate <typename... Ts>             class Y {};              // (2)\n//偏特化时，模板参数列表并不代表匹配顺序，\n//它们只是为偏特化的模式提供的声明\n//它们的匹配顺序，只是按照<U, Ts...>来\n//而之前的参数只是声明Ts是一个类型列表，而U是一个类型，排名不分先后\ntemplate <typename... Ts, typename U> class Y<U, Ts...> {};    // (3)\ntemplate <typename... Ts, typename U> class Y<Ts..., U> {};    // (4) error!\n```\n# 参考资料\n[https://sg-first.gitbooks.io/cpp-template-tutorial/content/](https://sg-first.gitbooks.io/cpp-template-tutorial/content/)\n[https://www.cnblogs.com/liangliangh/p/4219879.html](https://www.cnblogs.com/liangliangh/p/4219879.html)\n\n编程范式1：是一种编程风格或方法论，这个概念并没有一个确切的起源，它是随着计算机科学和软件工程的发展逐渐演变和形成的，它描述了解决问题和构建软件的基本方式。不同的编程范式强调不同的原则、思想和实践，影响着程序的结构和组织方式。常见的编程范式包括**命令式编程、声明式编程、函数式编程、面向对象编程、泛型编程等**。\n\ntuple代码2 ：这段代码来自于Boost库中的tuple实现，具体代码位置：[https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp](https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp) \n## \n# \n\n","source":"_posts/Template-programming-1.md","raw":"---\ntitle: 模板编程（一）：特化\ndate: 2024-02-09 01:25:55\ntags: 模板编程\n---\n这是模板编程系列的第一篇，主要回顾了模板的基础和特化与偏特化的实现语法。\n# 模版的介绍\n## 模板的基本概念\n模板（Templates）是编程语言提供的一种泛型编程机制，允许程序员编写通用的代码，而不需要指定具体数据类型，使得可以处理多种数据类型而不必为每种类型编写特定的代码。\n在C++中，可以通过 template 这个关键字来定义和实现基础的模板编程。\n## 模板的本质——从运行期到编译期\n模板的功能看起来非常吸引人，编译器智能地根据输入的类型选择对应的对该类型的处理逻辑，似乎是一种非常理想的**编程范式1**，在这种范式之下，我们的代码优雅得可以消灭一切对类型判断的if-else分支。那么编译器的这种智能的表象下的本质是什么：\n> 在我看来，模板的本质是代码枚举，将代码在运行期间的可能性，转移到编译期间通过编译器对代码的枚举进行覆盖。\n\n上面的本质是我对模板的一种粗暴的、不准确的、但是易于理解的总结，姑且写在文章开头，可以留待之后的文章中继续讨论。\n# 模板的基础语法\n在开始实践之前，先简单回顾一下模板的基础语法和一些编程规则。\n## 模板类和模板函数\n模板类和模板函数是模板的最基础的应用，也是平常使用中接触的最多的使用方式。\n在模板类中，传入的模板参数一般被用来替换类中元素的类型，使得同一个类在模板的帮助下表现出泛化的特性。\n平时基于可读性和分离编译考虑，如下面的示例，我一般会更喜欢把模板类内的函数实现放在类的外部。\n```cpp\ntemplate <typename T>\nclass vector\n{\npublic:\n\t// 这里只有声明\n    void clear();            \nprivate:\n    T* elements;\n};\n// 函数的实现放在这里\ntemplate <typename T>\nvoid vector<T>::clear()        \n{\n    // Function body\n}\n```\n相较于模板类的模板参数的占位对象的统一，模板函数的占位对象会显得更多五花八门。\n在模板函数中，除了函数名和形参之外，函数签名之中其他部分都可以用占位符代替。甚至函数内的对象的类型也可以是占位符，这就导致模板函数的形式很多样化。\n```cpp\ntemplate <typename T> \nvoid foo(T const& v);\n\ntemplate <typename T> \nT foo();\n\ntemplate <typename T, typename U> \nU foo(T const&);\n\ntemplate <typename T> \nvoid foo()\n{\n    T var;\n    // ...\n}\n```\n事实上，除了typename关键字外，还有一种模板整型的应用场景，在这种场景下，整型模版参数的作用，就是定义一个常数，替一个常数占位。\n```cpp\ntemplate <int Size> struct Array\n{\n    int data[Size];\n};\n\nArray<16> arr;\n```\n# 模板特化与偏特化\n> 所谓模板特例化即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization），另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization）。\n> 用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。\n\n当然，其实如果把模板当作是一门独立的图灵完备的编程语言的话，那么模板的特化与偏特化其实是这个语言中“if else then”的逻辑判断语句，实现了根据“入参”进行判断从而走向不同的分支，这也是模板元编程的基础之一，当然这一点会在之后的篇章详细展开。\n## 模板特化\n如果说，模板提供给了我们很好的对公共特性的抽象能力，那么，模版的特化，就是给予我们针对一些非公共特性进行特殊化的处理。类比成面向对象的抽象，基类可以类比为模板抽象出了最大公约数的能力，那么部分特殊的能力就由继承基类的派生类来实现。\n最基本的代码示例如下：\n```cpp\n// 模板的一般形式（原型）\ntemplate <typename T> class AddFloatOrMulInt\n{\n    static T Do(T a, T b)\n    {\n        return T(0);\n    }\n};\n\n// 指定T是int时候的特化\ntemplate <> class AddFloatOrMulInt<int>\n{\npublic:\n    static int Do(int a, int b)  \n    {\n        return a * b;\n    }\n};\n\n// 指定T是float时候的特化\ntemplate <> class AddFloatOrMulInt<float>\n{\npublic:\n    static float Do(float a, float b)\n    {\n        return a + b;\n    }\n};\n```\n在这个示例中，模板函数除了针对泛化的类型提供了能力之外，还对int或者float两种类型进行了特化处理，自定义了一些操作以应对他们所需要的区别性。\n## 模板偏特化\n如果说模板的特化是对某个固定的类型进行特化处理，那么偏特化可以理解为批量特化，即对批量符合特征的类型进行特化处理：比如说如果传入指针则进行特化处理。\n如下面的示例所示，该模版的偏特化实现了对所有传入类型是指针的批量特化。\n```cpp\n// 通用模板\ntemplate <typename T>\nstruct MyTemplate {\n    void print() {\n        std::cout << \"Generic Template\" << std::endl;\n    }\n};\n\n// 模板偏特化：当传入类型是指针时\ntemplate <typename T>\nstruct MyTemplate<T*> {\n    void print() {\n        std::cout << \"Partial Specialization for Pointers\" << std::endl;\n    }\n};\n```\n或者如下的另外一个例子，实现了对传入的两个类型相同时候的批量特化。\n```cpp\n// 通用模板\ntemplate <typename T, typename U>\nstruct MyTemplate {\n    void print() {\n        std::cout << \"Generic Template\" << std::endl;\n    }\n};\n\n// 模板偏特化：当两个模板参数相同时\ntemplate <typename T>\nstruct MyTemplate<T, T> {\n    void print() {\n        std::cout << \"Partial Specialization for T and T\" << std::endl;\n    }\n};\n```\n## 不定长模板参数\n在C++11中，引入了变参模板（Variadic Template），这一特性拓展了模板的参数的自由度，我们可以通过tuple在C++11标准发布前后的变更来了解变参模板的使用。\n引入变参模板之前，**tuple代码2**如下：\n```cpp\n// Tuple 的声明，来自 boost\nstruct null_type;\n\ntemplate <\n  class T0 = null_type, class T1 = null_type, class T2 = null_type,\n  class T3 = null_type, class T4 = null_type, class T5 = null_type,\n  class T6 = null_type, class T7 = null_type, class T8 = null_type,\n  class T9 = null_type>\nclass tuple;\n\n// Tuple的一些用例\ntuple<int> a;\ntuple<double&, const double&, const double, double*, const double*> b;\ntuple<A, int(*)(char, int), B(A::*)(C&), C> c;\ntuple<std::string, std::pair<A, B> > d;\ntuple<A*, tuple<const A*, const B&, C>, bool, void*> e;\n```\n这是tuple在boost中的实现，但是这个方案的缺陷很明显：代码臃肿和潜在的正确性问题。此外，过度使用模板偏特化、大量冗余的类型参数也给编译器带来了沉重的负担。此外，boost中也还有不少类似实现，比如MPL库也使用了这个手法将boost::mpl::vector映射到boost::mpl::vector _n_上。\n在引入了变参模板之后，tuple的模板可以被如此实现：\n```cpp\ntemplate <typename... Ts> class tuple;\n```\n这里的typename... Ts相当于一个声明，是说Ts不是一个类型，而是一个不定常的类型列表。需要注意的是，因为C++的模板是自左向右匹配的，所以不定长参数只能结尾。\n```cpp\n//模板的原型\ntemplate <typename... Ts, typename U> class X {};              // (1) error!\ntemplate <typename... Ts>             class Y {};              // (2)\n//偏特化时，模板参数列表并不代表匹配顺序，\n//它们只是为偏特化的模式提供的声明\n//它们的匹配顺序，只是按照<U, Ts...>来\n//而之前的参数只是声明Ts是一个类型列表，而U是一个类型，排名不分先后\ntemplate <typename... Ts, typename U> class Y<U, Ts...> {};    // (3)\ntemplate <typename... Ts, typename U> class Y<Ts..., U> {};    // (4) error!\n```\n# 参考资料\n[https://sg-first.gitbooks.io/cpp-template-tutorial/content/](https://sg-first.gitbooks.io/cpp-template-tutorial/content/)\n[https://www.cnblogs.com/liangliangh/p/4219879.html](https://www.cnblogs.com/liangliangh/p/4219879.html)\n\n编程范式1：是一种编程风格或方法论，这个概念并没有一个确切的起源，它是随着计算机科学和软件工程的发展逐渐演变和形成的，它描述了解决问题和构建软件的基本方式。不同的编程范式强调不同的原则、思想和实践，影响着程序的结构和组织方式。常见的编程范式包括**命令式编程、声明式编程、函数式编程、面向对象编程、泛型编程等**。\n\ntuple代码2 ：这段代码来自于Boost库中的tuple实现，具体代码位置：[https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp](https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp) \n## \n# \n\n","slug":"Template-programming-1","published":1,"updated":"2024-02-08T17:33:06.733Z","_id":"clsdhsxsw0000aox5hi21hy3d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是模板编程系列的第一篇，主要回顾了模板的基础和特化与偏特化的实现语法。</p>\n<h1 id=\"模版的介绍\"><a href=\"#模版的介绍\" class=\"headerlink\" title=\"模版的介绍\"></a>模版的介绍</h1><h2 id=\"模板的基本概念\"><a href=\"#模板的基本概念\" class=\"headerlink\" title=\"模板的基本概念\"></a>模板的基本概念</h2><p>模板（Templates）是编程语言提供的一种泛型编程机制，允许程序员编写通用的代码，而不需要指定具体数据类型，使得可以处理多种数据类型而不必为每种类型编写特定的代码。<br>在C++中，可以通过 template 这个关键字来定义和实现基础的模板编程。</p>\n<h2 id=\"模板的本质——从运行期到编译期\"><a href=\"#模板的本质——从运行期到编译期\" class=\"headerlink\" title=\"模板的本质——从运行期到编译期\"></a>模板的本质——从运行期到编译期</h2><p>模板的功能看起来非常吸引人，编译器智能地根据输入的类型选择对应的对该类型的处理逻辑，似乎是一种非常理想的<strong>编程范式1</strong>，在这种范式之下，我们的代码优雅得可以消灭一切对类型判断的if-else分支。那么编译器的这种智能的表象下的本质是什么：</p>\n<blockquote>\n<p>在我看来，模板的本质是代码枚举，将代码在运行期间的可能性，转移到编译期间通过编译器对代码的枚举进行覆盖。</p>\n</blockquote>\n<p>上面的本质是我对模板的一种粗暴的、不准确的、但是易于理解的总结，姑且写在文章开头，可以留待之后的文章中继续讨论。</p>\n<h1 id=\"模板的基础语法\"><a href=\"#模板的基础语法\" class=\"headerlink\" title=\"模板的基础语法\"></a>模板的基础语法</h1><p>在开始实践之前，先简单回顾一下模板的基础语法和一些编程规则。</p>\n<h2 id=\"模板类和模板函数\"><a href=\"#模板类和模板函数\" class=\"headerlink\" title=\"模板类和模板函数\"></a>模板类和模板函数</h2><p>模板类和模板函数是模板的最基础的应用，也是平常使用中接触的最多的使用方式。<br>在模板类中，传入的模板参数一般被用来替换类中元素的类型，使得同一个类在模板的帮助下表现出泛化的特性。<br>平时基于可读性和分离编译考虑，如下面的示例，我一般会更喜欢把模板类内的函数实现放在类的外部。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">vector</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 这里只有声明</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;            </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* elements;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 函数的实现放在这里</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> vector&lt;T&gt;::<span class=\"built_in\">clear</span>()        </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Function body</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于模板类的模板参数的占位对象的统一，模板函数的占位对象会显得更多五花八门。<br>在模板函数中，除了函数名和形参之外，函数签名之中其他部分都可以用占位符代替。甚至函数内的对象的类型也可以是占位符，这就导致模板函数的形式很多样化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(T <span class=\"type\">const</span>&amp; v)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt; </span><br><span class=\"line\"><span class=\"function\">U <span class=\"title\">foo</span><span class=\"params\">(T <span class=\"type\">const</span>&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    T var;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事实上，除了typename关键字外，还有一种模板整型的应用场景，在这种场景下，整型模版参数的作用，就是定义一个常数，替一个常数占位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> Size&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Array</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data[Size];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Array&lt;<span class=\"number\">16</span>&gt; arr;</span><br></pre></td></tr></table></figure>\n<h1 id=\"模板特化与偏特化\"><a href=\"#模板特化与偏特化\" class=\"headerlink\" title=\"模板特化与偏特化\"></a>模板特化与偏特化</h1><blockquote>\n<p>所谓模板特例化即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization），另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization）。<br>用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。</p>\n</blockquote>\n<p>当然，其实如果把模板当作是一门独立的图灵完备的编程语言的话，那么模板的特化与偏特化其实是这个语言中“if else then”的逻辑判断语句，实现了根据“入参”进行判断从而走向不同的分支，这也是模板元编程的基础之一，当然这一点会在之后的篇章详细展开。</p>\n<h2 id=\"模板特化\"><a href=\"#模板特化\" class=\"headerlink\" title=\"模板特化\"></a>模板特化</h2><p>如果说，模板提供给了我们很好的对公共特性的抽象能力，那么，模版的特化，就是给予我们针对一些非公共特性进行特殊化的处理。类比成面向对象的抽象，基类可以类比为模板抽象出了最大公约数的能力，那么部分特殊的能力就由继承基类的派生类来实现。<br>最基本的代码示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模板的一般形式（原型）</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">AddFloatOrMulInt</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> T <span class=\"title\">Do</span><span class=\"params\">(T a, T b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">T</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定T是int时候的特化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">AddFloatOrMulInt</span>&lt;<span class=\"type\">int</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">Do</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定T是float时候的特化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">AddFloatOrMulInt</span>&lt;<span class=\"type\">float</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">float</span> <span class=\"title\">Do</span><span class=\"params\">(<span class=\"type\">float</span> a, <span class=\"type\">float</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，模板函数除了针对泛化的类型提供了能力之外，还对int或者float两种类型进行了特化处理，自定义了一些操作以应对他们所需要的区别性。</p>\n<h2 id=\"模板偏特化\"><a href=\"#模板偏特化\" class=\"headerlink\" title=\"模板偏特化\"></a>模板偏特化</h2><p>如果说模板的特化是对某个固定的类型进行特化处理，那么偏特化可以理解为批量特化，即对批量符合特征的类型进行特化处理：比如说如果传入指针则进行特化处理。<br>如下面的示例所示，该模版的偏特化实现了对所有传入类型是指针的批量特化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Generic Template&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板偏特化：当传入类型是指针时</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span>&lt;T*&gt; &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Partial Specialization for Pointers&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>或者如下的另外一个例子，实现了对传入的两个类型相同时候的批量特化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Generic Template&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板偏特化：当两个模板参数相同时</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span>&lt;T, T&gt; &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Partial Specialization for T and T&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不定长模板参数\"><a href=\"#不定长模板参数\" class=\"headerlink\" title=\"不定长模板参数\"></a>不定长模板参数</h2><p>在C++11中，引入了变参模板（Variadic Template），这一特性拓展了模板的参数的自由度，我们可以通过tuple在C++11标准发布前后的变更来了解变参模板的使用。<br>引入变参模板之前，<strong>tuple代码2</strong>如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tuple 的声明，来自 boost</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">null_type</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;</span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">T0</span> = null_type, <span class=\"keyword\">class</span> T1 = null_type, <span class=\"keyword\">class</span> T2 = null_type,</span><br><span class=\"line\">  <span class=\"keyword\">class</span> T3 = null_type, <span class=\"keyword\">class</span> T4 = null_type, <span class=\"keyword\">class</span> T5 = null_type,</span><br><span class=\"line\">  <span class=\"keyword\">class</span> T6 = null_type, <span class=\"keyword\">class</span> T7 = null_type, <span class=\"keyword\">class</span> T8 = null_type,</span><br><span class=\"line\">  <span class=\"keyword\">class</span> T9 = null_type&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> tuple;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Tuple的一些用例</span></span><br><span class=\"line\">tuple&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\">tuple&lt;<span class=\"type\">double</span>&amp;, <span class=\"type\">const</span> <span class=\"type\">double</span>&amp;, <span class=\"type\">const</span> <span class=\"type\">double</span>, <span class=\"type\">double</span>*, <span class=\"type\">const</span> <span class=\"type\">double</span>*&gt; b;</span><br><span class=\"line\">tuple&lt;A, <span class=\"type\">int</span>(*)(<span class=\"type\">char</span>, <span class=\"type\">int</span>), B(A::*)(C&amp;), C&gt; c;</span><br><span class=\"line\">tuple&lt;std::string, std::pair&lt;A, B&gt; &gt; d;</span><br><span class=\"line\">tuple&lt;A*, tuple&lt;<span class=\"type\">const</span> A*, <span class=\"type\">const</span> B&amp;, C&gt;, <span class=\"type\">bool</span>, <span class=\"type\">void</span>*&gt; e;</span><br></pre></td></tr></table></figure>\n<p>这是tuple在boost中的实现，但是这个方案的缺陷很明显：代码臃肿和潜在的正确性问题。此外，过度使用模板偏特化、大量冗余的类型参数也给编译器带来了沉重的负担。此外，boost中也还有不少类似实现，比如MPL库也使用了这个手法将boost::mpl::vector映射到boost::mpl::vector _n_上。<br>在引入了变参模板之后，tuple的模板可以被如此实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">tuple</span>;</span><br></pre></td></tr></table></figure>\n<p>这里的typename… Ts相当于一个声明，是说Ts不是一个类型，而是一个不定常的类型列表。需要注意的是，因为C++的模板是自左向右匹配的，所以不定长参数只能结尾。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模板的原型</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts, <span class=\"keyword\">typename</span> U&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">X</span> &#123;&#125;;              <span class=\"comment\">// (1) error!</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts&gt;             <span class=\"keyword\">class</span> <span class=\"title class_\">Y</span> &#123;&#125;;              <span class=\"comment\">// (2)</span></span><br><span class=\"line\"><span class=\"comment\">//偏特化时，模板参数列表并不代表匹配顺序，</span></span><br><span class=\"line\"><span class=\"comment\">//它们只是为偏特化的模式提供的声明</span></span><br><span class=\"line\"><span class=\"comment\">//它们的匹配顺序，只是按照&lt;U, Ts...&gt;来</span></span><br><span class=\"line\"><span class=\"comment\">//而之前的参数只是声明Ts是一个类型列表，而U是一个类型，排名不分先后</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts, <span class=\"keyword\">typename</span> U&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">Y</span>&lt;U, Ts...&gt; &#123;&#125;;    <span class=\"comment\">// (3)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts, <span class=\"keyword\">typename</span> U&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">Y</span>&lt;Ts..., U&gt; &#123;&#125;;    <span class=\"comment\">// (4) error!</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://sg-first.gitbooks.io/cpp-template-tutorial/content/\">https://sg-first.gitbooks.io/cpp-template-tutorial/content/</a><br><a href=\"https://www.cnblogs.com/liangliangh/p/4219879.html\">https://www.cnblogs.com/liangliangh/p/4219879.html</a></p>\n<p>编程范式1：是一种编程风格或方法论，这个概念并没有一个确切的起源，它是随着计算机科学和软件工程的发展逐渐演变和形成的，它描述了解决问题和构建软件的基本方式。不同的编程范式强调不同的原则、思想和实践，影响着程序的结构和组织方式。常见的编程范式包括<strong>命令式编程、声明式编程、函数式编程、面向对象编程、泛型编程等</strong>。</p>\n<p>tuple代码2 ：这段代码来自于Boost库中的tuple实现，具体代码位置：<a href=\"https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp\">https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp</a> </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1>","site":{"data":{}},"excerpt":"","more":"<p>这是模板编程系列的第一篇，主要回顾了模板的基础和特化与偏特化的实现语法。</p>\n<h1 id=\"模版的介绍\"><a href=\"#模版的介绍\" class=\"headerlink\" title=\"模版的介绍\"></a>模版的介绍</h1><h2 id=\"模板的基本概念\"><a href=\"#模板的基本概念\" class=\"headerlink\" title=\"模板的基本概念\"></a>模板的基本概念</h2><p>模板（Templates）是编程语言提供的一种泛型编程机制，允许程序员编写通用的代码，而不需要指定具体数据类型，使得可以处理多种数据类型而不必为每种类型编写特定的代码。<br>在C++中，可以通过 template 这个关键字来定义和实现基础的模板编程。</p>\n<h2 id=\"模板的本质——从运行期到编译期\"><a href=\"#模板的本质——从运行期到编译期\" class=\"headerlink\" title=\"模板的本质——从运行期到编译期\"></a>模板的本质——从运行期到编译期</h2><p>模板的功能看起来非常吸引人，编译器智能地根据输入的类型选择对应的对该类型的处理逻辑，似乎是一种非常理想的<strong>编程范式1</strong>，在这种范式之下，我们的代码优雅得可以消灭一切对类型判断的if-else分支。那么编译器的这种智能的表象下的本质是什么：</p>\n<blockquote>\n<p>在我看来，模板的本质是代码枚举，将代码在运行期间的可能性，转移到编译期间通过编译器对代码的枚举进行覆盖。</p>\n</blockquote>\n<p>上面的本质是我对模板的一种粗暴的、不准确的、但是易于理解的总结，姑且写在文章开头，可以留待之后的文章中继续讨论。</p>\n<h1 id=\"模板的基础语法\"><a href=\"#模板的基础语法\" class=\"headerlink\" title=\"模板的基础语法\"></a>模板的基础语法</h1><p>在开始实践之前，先简单回顾一下模板的基础语法和一些编程规则。</p>\n<h2 id=\"模板类和模板函数\"><a href=\"#模板类和模板函数\" class=\"headerlink\" title=\"模板类和模板函数\"></a>模板类和模板函数</h2><p>模板类和模板函数是模板的最基础的应用，也是平常使用中接触的最多的使用方式。<br>在模板类中，传入的模板参数一般被用来替换类中元素的类型，使得同一个类在模板的帮助下表现出泛化的特性。<br>平时基于可读性和分离编译考虑，如下面的示例，我一般会更喜欢把模板类内的函数实现放在类的外部。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">vector</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 这里只有声明</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;            </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* elements;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 函数的实现放在这里</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> vector&lt;T&gt;::<span class=\"built_in\">clear</span>()        </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Function body</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相较于模板类的模板参数的占位对象的统一，模板函数的占位对象会显得更多五花八门。<br>在模板函数中，除了函数名和形参之外，函数签名之中其他部分都可以用占位符代替。甚至函数内的对象的类型也可以是占位符，这就导致模板函数的形式很多样化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(T <span class=\"type\">const</span>&amp; v)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt; </span><br><span class=\"line\"><span class=\"function\">U <span class=\"title\">foo</span><span class=\"params\">(T <span class=\"type\">const</span>&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    T var;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事实上，除了typename关键字外，还有一种模板整型的应用场景，在这种场景下，整型模版参数的作用，就是定义一个常数，替一个常数占位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"type\">int</span> Size&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Array</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data[Size];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Array&lt;<span class=\"number\">16</span>&gt; arr;</span><br></pre></td></tr></table></figure>\n<h1 id=\"模板特化与偏特化\"><a href=\"#模板特化与偏特化\" class=\"headerlink\" title=\"模板特化与偏特化\"></a>模板特化与偏特化</h1><blockquote>\n<p>所谓模板特例化即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization），另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization）。<br>用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。</p>\n</blockquote>\n<p>当然，其实如果把模板当作是一门独立的图灵完备的编程语言的话，那么模板的特化与偏特化其实是这个语言中“if else then”的逻辑判断语句，实现了根据“入参”进行判断从而走向不同的分支，这也是模板元编程的基础之一，当然这一点会在之后的篇章详细展开。</p>\n<h2 id=\"模板特化\"><a href=\"#模板特化\" class=\"headerlink\" title=\"模板特化\"></a>模板特化</h2><p>如果说，模板提供给了我们很好的对公共特性的抽象能力，那么，模版的特化，就是给予我们针对一些非公共特性进行特殊化的处理。类比成面向对象的抽象，基类可以类比为模板抽象出了最大公约数的能力，那么部分特殊的能力就由继承基类的派生类来实现。<br>最基本的代码示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模板的一般形式（原型）</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">AddFloatOrMulInt</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> T <span class=\"title\">Do</span><span class=\"params\">(T a, T b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">T</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定T是int时候的特化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">AddFloatOrMulInt</span>&lt;<span class=\"type\">int</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">Do</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定T是float时候的特化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">AddFloatOrMulInt</span>&lt;<span class=\"type\">float</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">float</span> <span class=\"title\">Do</span><span class=\"params\">(<span class=\"type\">float</span> a, <span class=\"type\">float</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，模板函数除了针对泛化的类型提供了能力之外，还对int或者float两种类型进行了特化处理，自定义了一些操作以应对他们所需要的区别性。</p>\n<h2 id=\"模板偏特化\"><a href=\"#模板偏特化\" class=\"headerlink\" title=\"模板偏特化\"></a>模板偏特化</h2><p>如果说模板的特化是对某个固定的类型进行特化处理，那么偏特化可以理解为批量特化，即对批量符合特征的类型进行特化处理：比如说如果传入指针则进行特化处理。<br>如下面的示例所示，该模版的偏特化实现了对所有传入类型是指针的批量特化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Generic Template&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板偏特化：当传入类型是指针时</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span>&lt;T*&gt; &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Partial Specialization for Pointers&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>或者如下的另外一个例子，实现了对传入的两个类型相同时候的批量特化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Generic Template&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板偏特化：当两个模板参数相同时</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyTemplate</span>&lt;T, T&gt; &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Partial Specialization for T and T&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不定长模板参数\"><a href=\"#不定长模板参数\" class=\"headerlink\" title=\"不定长模板参数\"></a>不定长模板参数</h2><p>在C++11中，引入了变参模板（Variadic Template），这一特性拓展了模板的参数的自由度，我们可以通过tuple在C++11标准发布前后的变更来了解变参模板的使用。<br>引入变参模板之前，<strong>tuple代码2</strong>如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tuple 的声明，来自 boost</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">null_type</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;</span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">T0</span> = null_type, <span class=\"keyword\">class</span> T1 = null_type, <span class=\"keyword\">class</span> T2 = null_type,</span><br><span class=\"line\">  <span class=\"keyword\">class</span> T3 = null_type, <span class=\"keyword\">class</span> T4 = null_type, <span class=\"keyword\">class</span> T5 = null_type,</span><br><span class=\"line\">  <span class=\"keyword\">class</span> T6 = null_type, <span class=\"keyword\">class</span> T7 = null_type, <span class=\"keyword\">class</span> T8 = null_type,</span><br><span class=\"line\">  <span class=\"keyword\">class</span> T9 = null_type&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> tuple;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Tuple的一些用例</span></span><br><span class=\"line\">tuple&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\">tuple&lt;<span class=\"type\">double</span>&amp;, <span class=\"type\">const</span> <span class=\"type\">double</span>&amp;, <span class=\"type\">const</span> <span class=\"type\">double</span>, <span class=\"type\">double</span>*, <span class=\"type\">const</span> <span class=\"type\">double</span>*&gt; b;</span><br><span class=\"line\">tuple&lt;A, <span class=\"type\">int</span>(*)(<span class=\"type\">char</span>, <span class=\"type\">int</span>), B(A::*)(C&amp;), C&gt; c;</span><br><span class=\"line\">tuple&lt;std::string, std::pair&lt;A, B&gt; &gt; d;</span><br><span class=\"line\">tuple&lt;A*, tuple&lt;<span class=\"type\">const</span> A*, <span class=\"type\">const</span> B&amp;, C&gt;, <span class=\"type\">bool</span>, <span class=\"type\">void</span>*&gt; e;</span><br></pre></td></tr></table></figure>\n<p>这是tuple在boost中的实现，但是这个方案的缺陷很明显：代码臃肿和潜在的正确性问题。此外，过度使用模板偏特化、大量冗余的类型参数也给编译器带来了沉重的负担。此外，boost中也还有不少类似实现，比如MPL库也使用了这个手法将boost::mpl::vector映射到boost::mpl::vector _n_上。<br>在引入了变参模板之后，tuple的模板可以被如此实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">tuple</span>;</span><br></pre></td></tr></table></figure>\n<p>这里的typename… Ts相当于一个声明，是说Ts不是一个类型，而是一个不定常的类型列表。需要注意的是，因为C++的模板是自左向右匹配的，所以不定长参数只能结尾。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模板的原型</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts, <span class=\"keyword\">typename</span> U&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">X</span> &#123;&#125;;              <span class=\"comment\">// (1) error!</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts&gt;             <span class=\"keyword\">class</span> <span class=\"title class_\">Y</span> &#123;&#125;;              <span class=\"comment\">// (2)</span></span><br><span class=\"line\"><span class=\"comment\">//偏特化时，模板参数列表并不代表匹配顺序，</span></span><br><span class=\"line\"><span class=\"comment\">//它们只是为偏特化的模式提供的声明</span></span><br><span class=\"line\"><span class=\"comment\">//它们的匹配顺序，只是按照&lt;U, Ts...&gt;来</span></span><br><span class=\"line\"><span class=\"comment\">//而之前的参数只是声明Ts是一个类型列表，而U是一个类型，排名不分先后</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts, <span class=\"keyword\">typename</span> U&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">Y</span>&lt;U, Ts...&gt; &#123;&#125;;    <span class=\"comment\">// (3)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Ts, <span class=\"keyword\">typename</span> U&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">Y</span>&lt;Ts..., U&gt; &#123;&#125;;    <span class=\"comment\">// (4) error!</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://sg-first.gitbooks.io/cpp-template-tutorial/content/\">https://sg-first.gitbooks.io/cpp-template-tutorial/content/</a><br><a href=\"https://www.cnblogs.com/liangliangh/p/4219879.html\">https://www.cnblogs.com/liangliangh/p/4219879.html</a></p>\n<p>编程范式1：是一种编程风格或方法论，这个概念并没有一个确切的起源，它是随着计算机科学和软件工程的发展逐渐演变和形成的，它描述了解决问题和构建软件的基本方式。不同的编程范式强调不同的原则、思想和实践，影响着程序的结构和组织方式。常见的编程范式包括<strong>命令式编程、声明式编程、函数式编程、面向对象编程、泛型编程等</strong>。</p>\n<p>tuple代码2 ：这段代码来自于Boost库中的tuple实现，具体代码位置：<a href=\"https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp\">https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp</a> </p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1>"},{"title":"模板编程（三）：CRTP","date":"2024-02-12T12:59:40.000Z","_content":"这是模板编程的第三篇，主要聊一下CRTP（Curiously Recurring Template Pattern）的模板编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。\n# 基于虚函数实现的动态多态\n如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。\n```\n// 基类\nclass Shape {\npublic:\n    // 虚函数，实现多态\n    virtual void printArea() const {\n        std::cout << \"Shape Area\" << std::endl;\n    }\n\n    // 基类可能包含其他的成员函数或数据成员\n};\n\n// 派生类1\nclass Circle : public Shape {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape {\npublic:\n    Square(double side) : side(side) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\nprivate:\n    double side;\n};\n```\n但是问题是在每次执行 shape->printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。\n因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。\n# 基于模板实现的静态多态\n为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。\n```\n#include <iostream>\n\n// 基类模板\ntemplate <typename T>\nclass Shape {\npublic:\n    // 模板函数，实现静态多态\n    void printArea() const {\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n\n    // 重载++运算符，用于对派生类中的参数进行自增\n    T& operator++() {\n        static_cast<T*>(this)->increment();\n        return *static_cast<T*>(this);\n    }\n};\n\n// 派生类1\nclass Circle : public Shape<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\n    // 自增半径\n    void increment() {\n        ++radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\n    // 自增边长\n    void increment() {\n        ++side;\n    }\n\nprivate:\n    double side;\n};\n\nint main() {\n    Circle circle(5.0);\n    Square square(4.0);\n\n    // 调用基类模板函数，实现静态多态\n    circle.printArea();\n    square.printArea();\n\n    // 使用++运算符对派生类中的参数进行自增\n    ++circle;\n    ++square;\n\n    // 再次调用基类模板函数，查看自增后的结果\n    circle.printArea();\n    square.printArea();\n\n    return 0;\n}\n\n```\n\n在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。\n# 基于虚函数和模板混合的多态实现\n虽然上文基于模版也实现了可用的静态多态，但是还存在问题。\n如果是基于虚函数实现的多态，由于不同的子类指针，Circle*，Square*等指针可以很轻易地传给基类Shape*，这样可以在容器中vector<Shape*>很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。\n事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。\n在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。\n```\n#include <iostream>\n#include <vector>\n\nusing std::cout; \nusing std::endl;\nusing std::vector;\n\nclass Shape {\n public:\n    virtual void printArea () const = 0;\n    virtual ~Shape() {}\n};\n\ntemplate <typename T>\nclass Shape_CRTP: public Shape {\n public:\n    void printArea() const override{\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n    \n};\n\nclass Circle: public Shape_CRTP<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape_CRTP<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\nprivate:\n    double side;\n};\n\nint main () {\n    vector<Shape*> list;\n    list.push_back(new Circle(1));\n    list.push_back(new Square(1));\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        (*iter)->printArea();\n    }\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        delete (*iter);\n    }\n    return 0;\n}\n```\n","source":"_posts/Template-programming-3.md","raw":"---\ntitle: 模板编程（三）：CRTP\ndate: 2024-02-12 20:59:40\ntags: 模板编程\n---\n这是模板编程的第三篇，主要聊一下CRTP（Curiously Recurring Template Pattern）的模板编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。\n# 基于虚函数实现的动态多态\n如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。\n```\n// 基类\nclass Shape {\npublic:\n    // 虚函数，实现多态\n    virtual void printArea() const {\n        std::cout << \"Shape Area\" << std::endl;\n    }\n\n    // 基类可能包含其他的成员函数或数据成员\n};\n\n// 派生类1\nclass Circle : public Shape {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape {\npublic:\n    Square(double side) : side(side) {}\n\n    // 重写基类的虚函数\n    void printArea() const override {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\nprivate:\n    double side;\n};\n```\n但是问题是在每次执行 shape->printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。\n因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。\n# 基于模板实现的静态多态\n为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。\n```\n#include <iostream>\n\n// 基类模板\ntemplate <typename T>\nclass Shape {\npublic:\n    // 模板函数，实现静态多态\n    void printArea() const {\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n\n    // 重载++运算符，用于对派生类中的参数进行自增\n    T& operator++() {\n        static_cast<T*>(this)->increment();\n        return *static_cast<T*>(this);\n    }\n};\n\n// 派生类1\nclass Circle : public Shape<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\n\n    // 自增半径\n    void increment() {\n        ++radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\n\n    // 自增边长\n    void increment() {\n        ++side;\n    }\n\nprivate:\n    double side;\n};\n\nint main() {\n    Circle circle(5.0);\n    Square square(4.0);\n\n    // 调用基类模板函数，实现静态多态\n    circle.printArea();\n    square.printArea();\n\n    // 使用++运算符对派生类中的参数进行自增\n    ++circle;\n    ++square;\n\n    // 再次调用基类模板函数，查看自增后的结果\n    circle.printArea();\n    square.printArea();\n\n    return 0;\n}\n\n```\n\n在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。\n# 基于虚函数和模板混合的多态实现\n虽然上文基于模版也实现了可用的静态多态，但是还存在问题。\n如果是基于虚函数实现的多态，由于不同的子类指针，Circle*，Square*等指针可以很轻易地传给基类Shape*，这样可以在容器中vector<Shape*>很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。\n事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。\n在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。\n```\n#include <iostream>\n#include <vector>\n\nusing std::cout; \nusing std::endl;\nusing std::vector;\n\nclass Shape {\n public:\n    virtual void printArea () const = 0;\n    virtual ~Shape() {}\n};\n\ntemplate <typename T>\nclass Shape_CRTP: public Shape {\n public:\n    void printArea() const override{\n        static_cast<T const*>(this)->printAreaImpl();\n    }\n    \n};\n\nclass Circle: public Shape_CRTP<Circle> {\npublic:\n    Circle(double radius) : radius(radius) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Circle Area: \" << 3.14159 * radius * radius << std::endl;\n    }\nprivate:\n    double radius;\n};\n\n// 派生类2\nclass Square : public Shape_CRTP<Square> {\npublic:\n    Square(double side) : side(side) {}\n\n    // 派生类实现具体的printArea函数\n    void printAreaImpl() const {\n        std::cout << \"Square Area: \" << side * side << std::endl;\n    }\nprivate:\n    double side;\n};\n\nint main () {\n    vector<Shape*> list;\n    list.push_back(new Circle(1));\n    list.push_back(new Square(1));\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        (*iter)->printArea();\n    }\n    for (auto iter{list.begin()}; iter != list.end(); ++iter) {\n        delete (*iter);\n    }\n    return 0;\n}\n```\n","slug":"Template-programming-3","published":1,"updated":"2024-02-12T12:39:38.258Z","_id":"clsdhw2xz0000jrx5fr979q3f","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是模板编程的第三篇，主要聊一下CRTP（Curiously Recurring Template Pattern）的模板编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。</p>\n<h1 id=\"基于虚函数实现的动态多态\"><a href=\"#基于虚函数实现的动态多态\" class=\"headerlink\" title=\"基于虚函数实现的动态多态\"></a>基于虚函数实现的动态多态</h1><p>如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基类</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 虚函数，实现多态</span><br><span class=\"line\">    virtual void printArea() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Shape Area&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 基类可能包含其他的成员函数或数据成员</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是问题是在每次执行 shape-&gt;printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。<br>因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。</p>\n<h1 id=\"基于模板实现的静态多态\"><a href=\"#基于模板实现的静态多态\" class=\"headerlink\" title=\"基于模板实现的静态多态\"></a>基于模板实现的静态多态</h1><p>为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 基类模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 模板函数，实现静态多态</span><br><span class=\"line\">    void printArea() const &#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重载++运算符，用于对派生类中的参数进行自增</span><br><span class=\"line\">    T&amp; operator++() &#123;</span><br><span class=\"line\">        static_cast&lt;T*&gt;(this)-&gt;increment();</span><br><span class=\"line\">        return *static_cast&lt;T*&gt;(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增半径</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增边长</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++side;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Circle circle(5.0);</span><br><span class=\"line\">    Square square(4.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用基类模板函数，实现静态多态</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用++运算符对派生类中的参数进行自增</span><br><span class=\"line\">    ++circle;</span><br><span class=\"line\">    ++square;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 再次调用基类模板函数，查看自增后的结果</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。</p>\n<h1 id=\"基于虚函数和模板混合的多态实现\"><a href=\"#基于虚函数和模板混合的多态实现\" class=\"headerlink\" title=\"基于虚函数和模板混合的多态实现\"></a>基于虚函数和模板混合的多态实现</h1><p>虽然上文基于模版也实现了可用的静态多态，但是还存在问题。<br>如果是基于虚函数实现的多态，由于不同的子类指针，Circle<em>，Square</em>等指针可以很轻易地传给基类Shape*，这样可以在容器中vector&lt;Shape*&gt;很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。<br>事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。<br>在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using std::cout; </span><br><span class=\"line\">using std::endl;</span><br><span class=\"line\">using std::vector;</span><br><span class=\"line\"></span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    virtual void printArea () const = 0;</span><br><span class=\"line\">    virtual ~Shape() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape_CRTP: public Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    void printArea() const override&#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Circle: public Shape_CRTP&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape_CRTP&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\">    vector&lt;Shape*&gt; list;</span><br><span class=\"line\">    list.push_back(new Circle(1));</span><br><span class=\"line\">    list.push_back(new Square(1));</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        (*iter)-&gt;printArea();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        delete (*iter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这是模板编程的第三篇，主要聊一下CRTP（Curiously Recurring Template Pattern）的模板编程模式，基本思想是在一个类模板中将派生类作为模板参数传递给基类，从而实现多态的编程技巧。</p>\n<h1 id=\"基于虚函数实现的动态多态\"><a href=\"#基于虚函数实现的动态多态\" class=\"headerlink\" title=\"基于虚函数实现的动态多态\"></a>基于虚函数实现的动态多态</h1><p>如下面的代码所示，C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Shape 的基类，以及 Square, Circle 等子类，并通过在子类中重载虚函数 printArea，实现不同形状的面积输出。而后我们可以通过访问 Shape_List 类的实例中存有 Shape 指针的数组，让所有形状都打印一遍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基类</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 虚函数，实现多态</span><br><span class=\"line\">    virtual void printArea() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Shape Area&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 基类可能包含其他的成员函数或数据成员</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重写基类的虚函数</span><br><span class=\"line\">    void printArea() const override &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是问题是在每次执行 shape-&gt;printArea() 的时候，系统会检查 shape 指向的实例实际的类型，然后调用对应类型的 printArea 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 shape 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。<br>因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，于是使用Curiously Recurring Template Pattern 这一概念改写程序。</p>\n<h1 id=\"基于模板实现的静态多态\"><a href=\"#基于模板实现的静态多态\" class=\"headerlink\" title=\"基于模板实现的静态多态\"></a>基于模板实现的静态多态</h1><p>为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类，因此，我们需要用到 C++ 的模板。所以概括的说，静态多态的核心思路是用模板在静态编译期获得子类的类名以避开查虚函数表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 基类模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    // 模板函数，实现静态多态</span><br><span class=\"line\">    void printArea() const &#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 重载++运算符，用于对派生类中的参数进行自增</span><br><span class=\"line\">    T&amp; operator++() &#123;</span><br><span class=\"line\">        static_cast&lt;T*&gt;(this)-&gt;increment();</span><br><span class=\"line\">        return *static_cast&lt;T*&gt;(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类1</span><br><span class=\"line\">class Circle : public Shape&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增半径</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自增边长</span><br><span class=\"line\">    void increment() &#123;</span><br><span class=\"line\">        ++side;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Circle circle(5.0);</span><br><span class=\"line\">    Square square(4.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用基类模板函数，实现静态多态</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用++运算符对派生类中的参数进行自增</span><br><span class=\"line\">    ++circle;</span><br><span class=\"line\">    ++square;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 再次调用基类模板函数，查看自增后的结果</span><br><span class=\"line\">    circle.printArea();</span><br><span class=\"line\">    square.printArea();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，Shape 是一个模板类，它有一个模板函数 printArea。然后，Circle 和 Square 分别是 Shape 的派生类，并在各自的类中实现了 printAreaImpl 函数并且重载了 ++ 运算符。通过CRTP，Shape 的模板函数 printArea 能够调用正确的实现，++ 运算符也能正确的调用，实现了静态多态。在运行时，不需要虚函数表，而是在编译时就完成了函数调用的解析。</p>\n<h1 id=\"基于虚函数和模板混合的多态实现\"><a href=\"#基于虚函数和模板混合的多态实现\" class=\"headerlink\" title=\"基于虚函数和模板混合的多态实现\"></a>基于虚函数和模板混合的多态实现</h1><p>虽然上文基于模版也实现了可用的静态多态，但是还存在问题。<br>如果是基于虚函数实现的多态，由于不同的子类指针，Circle<em>，Square</em>等指针可以很轻易地传给基类Shape*，这样可以在容器中vector&lt;Shape*&gt;很容易存下一系列子类指针，但是在CRTP模式下则不行，Shape<Circle>*，Shape<Square>*完全是不同类型的指针，是无法在一个容器中存放他们的。<br>事实上， CRTP 本质上是为了解决多态存在的要查虚函数表的慢动态绑定而引入的，而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。<br>在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。这样就可以兼顾多态的抽象性和动态绑定的性能性，具体的示例如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using std::cout; </span><br><span class=\"line\">using std::endl;</span><br><span class=\"line\">using std::vector;</span><br><span class=\"line\"></span><br><span class=\"line\">class Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    virtual void printArea () const = 0;</span><br><span class=\"line\">    virtual ~Shape() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Shape_CRTP: public Shape &#123;</span><br><span class=\"line\"> public:</span><br><span class=\"line\">    void printArea() const override&#123;</span><br><span class=\"line\">        static_cast&lt;T const*&gt;(this)-&gt;printAreaImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Circle: public Shape_CRTP&lt;Circle&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Circle(double radius) : radius(radius) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Circle Area: &quot; &lt;&lt; 3.14159 * radius * radius &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double radius;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 派生类2</span><br><span class=\"line\">class Square : public Shape_CRTP&lt;Square&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Square(double side) : side(side) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 派生类实现具体的printArea函数</span><br><span class=\"line\">    void printAreaImpl() const &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;Square Area: &quot; &lt;&lt; side * side &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    double side;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\">    vector&lt;Shape*&gt; list;</span><br><span class=\"line\">    list.push_back(new Circle(1));</span><br><span class=\"line\">    list.push_back(new Square(1));</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        (*iter)-&gt;printArea();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (auto iter&#123;list.begin()&#125;; iter != list.end(); ++iter) &#123;</span><br><span class=\"line\">        delete (*iter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"模板编程（二）：SFINAE","date":"2024-02-12T12:38:49.000Z","_content":"在C++模板编程中，SFINAE（Substitution Failure Is Not An Error）是处理模板参数推导失败的时选择替换方案（例如控制编译器重载函数或者是进行模版特化）的一项重要机制。\n# SFINAE的原理\nSFINAE机制源于C++模板参数推导失败时的编译器行为。当编译器在实例化模板时遇到模板参数推导失败的情况时，并不会报错，而是会尝试继续寻找其他可行的实例化方式。如果找到了替代方案，则继续编译；如果找不到，则会报错。\n它的这一行为在我的理解中，有着两方面的作用，一方面是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断；另一方面是这一个特性可以在元编程中实现部分的编译期自省和反射机制。\n# SFINAE的代码示例\n当编译器在实例化模板时尝试用某些类型替换模板参数时，如果替换导致了编译错误，SFINAE机制会使编译器选择另一种模板，而不是产生编译错误。\n```cpp\nstruct X {\n    typedef int type;\n};\n\nstruct Y {\n    typedef int type2;\n};\n\ntemplate <typename T> void foo(typename T::type);    // Foo0\ntemplate <typename T> void foo(typename T::type2);   // Foo1\ntemplate <typename T> void foo(T);                   // Foo2\n\nvoid callFoo() {\n    foo<X>(5);    // Foo0: Succeed, Foo1: Failed,  Foo2: Failed\n    foo<Y>(10);   // Foo0: Failed,  Foo1: Succeed, Foo2: Failed\n    foo<int>(15); // Foo0: Failed,  Foo1: Failed,  Foo2: Succeed\n}\n```\n在这个例子中，就展示了SFIAE机制如何选择模板进行匹配的机制，当发现某个模版难以匹配上的时候，会选择其他可匹配的模板进行匹配，由此衍生出一个问题，就是当如果有多个模板可以被匹配的情况下，编译器如何决定被匹配的优先级？\n事实上，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A，如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系），则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数。\n# SFINAE的应用\nSFINAE的主要应用之一是在模板编程中实现条件编译。通过合理地设计模板参数，我们可以利用SFINAE机制来选择性地启用或禁用模板的特定实例化版本。\n通过下面这个函数，我们借助了SFINAE机制实现了一个类模板，并借此对对象中是否有foo这一成员函数进行判断。\n```\n#include <iostream>\n\n// 检查是否有名为foo的成员函数的函数模板\ntemplate <typename T>\nclass has_foo {\n    // 检查是否有foo成员函数的辅助模板\n    template <typename U>\n    static char test(decltype(&U::foo));\n\n    template <typename U>\n    static long test(...);\n\npublic:\n    static constexpr bool value = sizeof(test<T>(nullptr)) == sizeof(char);\n};\n\n// 示例类型\nstruct A {\n    void foo() {}\n};\n\nstruct B {\n    // 没有foo成员函数\n};\n\nint main() {\n    std::cout << \"A has foo member function: \" << has_foo<A>::value << std::endl; // 输出true\n    std::cout << \"B has foo member function: \" << has_foo<B>::value << std::endl; // 输出false\n\n    return 0;\n}\n\n```\n上文中的例子就是被用以实现了部分的编译期自省（反射的一种）机制。\n\n","source":"_posts/Template-programming-2.md","raw":"---\ntitle: 模板编程（二）：SFINAE\ndate: 2024-02-12 20:38:49\ntags: 模板编程\n---\n在C++模板编程中，SFINAE（Substitution Failure Is Not An Error）是处理模板参数推导失败的时选择替换方案（例如控制编译器重载函数或者是进行模版特化）的一项重要机制。\n# SFINAE的原理\nSFINAE机制源于C++模板参数推导失败时的编译器行为。当编译器在实例化模板时遇到模板参数推导失败的情况时，并不会报错，而是会尝试继续寻找其他可行的实例化方式。如果找到了替代方案，则继续编译；如果找不到，则会报错。\n它的这一行为在我的理解中，有着两方面的作用，一方面是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断；另一方面是这一个特性可以在元编程中实现部分的编译期自省和反射机制。\n# SFINAE的代码示例\n当编译器在实例化模板时尝试用某些类型替换模板参数时，如果替换导致了编译错误，SFINAE机制会使编译器选择另一种模板，而不是产生编译错误。\n```cpp\nstruct X {\n    typedef int type;\n};\n\nstruct Y {\n    typedef int type2;\n};\n\ntemplate <typename T> void foo(typename T::type);    // Foo0\ntemplate <typename T> void foo(typename T::type2);   // Foo1\ntemplate <typename T> void foo(T);                   // Foo2\n\nvoid callFoo() {\n    foo<X>(5);    // Foo0: Succeed, Foo1: Failed,  Foo2: Failed\n    foo<Y>(10);   // Foo0: Failed,  Foo1: Succeed, Foo2: Failed\n    foo<int>(15); // Foo0: Failed,  Foo1: Failed,  Foo2: Succeed\n}\n```\n在这个例子中，就展示了SFIAE机制如何选择模板进行匹配的机制，当发现某个模版难以匹配上的时候，会选择其他可匹配的模板进行匹配，由此衍生出一个问题，就是当如果有多个模板可以被匹配的情况下，编译器如何决定被匹配的优先级？\n事实上，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A，如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系），则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数。\n# SFINAE的应用\nSFINAE的主要应用之一是在模板编程中实现条件编译。通过合理地设计模板参数，我们可以利用SFINAE机制来选择性地启用或禁用模板的特定实例化版本。\n通过下面这个函数，我们借助了SFINAE机制实现了一个类模板，并借此对对象中是否有foo这一成员函数进行判断。\n```\n#include <iostream>\n\n// 检查是否有名为foo的成员函数的函数模板\ntemplate <typename T>\nclass has_foo {\n    // 检查是否有foo成员函数的辅助模板\n    template <typename U>\n    static char test(decltype(&U::foo));\n\n    template <typename U>\n    static long test(...);\n\npublic:\n    static constexpr bool value = sizeof(test<T>(nullptr)) == sizeof(char);\n};\n\n// 示例类型\nstruct A {\n    void foo() {}\n};\n\nstruct B {\n    // 没有foo成员函数\n};\n\nint main() {\n    std::cout << \"A has foo member function: \" << has_foo<A>::value << std::endl; // 输出true\n    std::cout << \"B has foo member function: \" << has_foo<B>::value << std::endl; // 输出false\n\n    return 0;\n}\n\n```\n上文中的例子就是被用以实现了部分的编译期自省（反射的一种）机制。\n\n","slug":"Template-programming-2","published":1,"updated":"2024-02-12T18:29:54.499Z","_id":"clsixc4fq000027x56w108spz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在C++模板编程中，SFINAE（Substitution Failure Is Not An Error）是处理模板参数推导失败的时选择替换方案（例如控制编译器重载函数或者是进行模版特化）的一项重要机制。</p>\n<h1 id=\"SFINAE的原理\"><a href=\"#SFINAE的原理\" class=\"headerlink\" title=\"SFINAE的原理\"></a>SFINAE的原理</h1><p>SFINAE机制源于C++模板参数推导失败时的编译器行为。当编译器在实例化模板时遇到模板参数推导失败的情况时，并不会报错，而是会尝试继续寻找其他可行的实例化方式。如果找到了替代方案，则继续编译；如果找不到，则会报错。<br>它的这一行为在我的理解中，有着两方面的作用，一方面是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断；另一方面是这一个特性可以在元编程中实现部分的编译期自省和反射机制。</p>\n<h1 id=\"SFINAE的代码示例\"><a href=\"#SFINAE的代码示例\" class=\"headerlink\" title=\"SFINAE的代码示例\"></a>SFINAE的代码示例</h1><p>当编译器在实例化模板时尝试用某些类型替换模板参数时，如果替换导致了编译错误，SFINAE机制会使编译器选择另一种模板，而不是产生编译错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">X</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"type\">int</span> type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Y</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"type\">int</span> type2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::type)</span></span>;    <span class=\"comment\">// Foo0</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::type2)</span></span>;   <span class=\"comment\">// Foo1</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(T)</span></span>;                   <span class=\"comment\">// Foo2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">callFoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">foo</span>&lt;X&gt;(<span class=\"number\">5</span>);    <span class=\"comment\">// Foo0: Succeed, Foo1: Failed,  Foo2: Failed</span></span><br><span class=\"line\">    <span class=\"built_in\">foo</span>&lt;Y&gt;(<span class=\"number\">10</span>);   <span class=\"comment\">// Foo0: Failed,  Foo1: Succeed, Foo2: Failed</span></span><br><span class=\"line\">    <span class=\"built_in\">foo</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">15</span>); <span class=\"comment\">// Foo0: Failed,  Foo1: Failed,  Foo2: Succeed</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，就展示了SFIAE机制如何选择模板进行匹配的机制，当发现某个模版难以匹配上的时候，会选择其他可匹配的模板进行匹配，由此衍生出一个问题，就是当如果有多个模板可以被匹配的情况下，编译器如何决定被匹配的优先级？<br>事实上，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A，如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系），则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数。</p>\n<h1 id=\"SFINAE的应用\"><a href=\"#SFINAE的应用\" class=\"headerlink\" title=\"SFINAE的应用\"></a>SFINAE的应用</h1><p>SFINAE的主要应用之一是在模板编程中实现条件编译。通过合理地设计模板参数，我们可以利用SFINAE机制来选择性地启用或禁用模板的特定实例化版本。<br>通过下面这个函数，我们借助了SFINAE机制实现了一个类模板，并借此对对象中是否有foo这一成员函数进行判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检查是否有名为foo的成员函数的函数模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class has_foo &#123;</span><br><span class=\"line\">    // 检查是否有foo成员函数的辅助模板</span><br><span class=\"line\">    template &lt;typename U&gt;</span><br><span class=\"line\">    static char test(decltype(&amp;U::foo));</span><br><span class=\"line\"></span><br><span class=\"line\">    template &lt;typename U&gt;</span><br><span class=\"line\">    static long test(...);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static constexpr bool value = sizeof(test&lt;T&gt;(nullptr)) == sizeof(char);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 示例类型</span><br><span class=\"line\">struct A &#123;</span><br><span class=\"line\">    void foo() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct B &#123;</span><br><span class=\"line\">    // 没有foo成员函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;A has foo member function: &quot; &lt;&lt; has_foo&lt;A&gt;::value &lt;&lt; std::endl; // 输出true</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;B has foo member function: &quot; &lt;&lt; has_foo&lt;B&gt;::value &lt;&lt; std::endl; // 输出false</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上文中的例子就是被用以实现了部分的编译期自省（反射的一种）机制。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在C++模板编程中，SFINAE（Substitution Failure Is Not An Error）是处理模板参数推导失败的时选择替换方案（例如控制编译器重载函数或者是进行模版特化）的一项重要机制。</p>\n<h1 id=\"SFINAE的原理\"><a href=\"#SFINAE的原理\" class=\"headerlink\" title=\"SFINAE的原理\"></a>SFINAE的原理</h1><p>SFINAE机制源于C++模板参数推导失败时的编译器行为。当编译器在实例化模板时遇到模板参数推导失败的情况时，并不会报错，而是会尝试继续寻找其他可行的实例化方式。如果找到了替代方案，则继续编译；如果找不到，则会报错。<br>它的这一行为在我的理解中，有着两方面的作用，一方面是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断；另一方面是这一个特性可以在元编程中实现部分的编译期自省和反射机制。</p>\n<h1 id=\"SFINAE的代码示例\"><a href=\"#SFINAE的代码示例\" class=\"headerlink\" title=\"SFINAE的代码示例\"></a>SFINAE的代码示例</h1><p>当编译器在实例化模板时尝试用某些类型替换模板参数时，如果替换导致了编译错误，SFINAE机制会使编译器选择另一种模板，而不是产生编译错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">X</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"type\">int</span> type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Y</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"type\">int</span> type2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::type)</span></span>;    <span class=\"comment\">// Foo0</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::type2)</span></span>;   <span class=\"comment\">// Foo1</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(T)</span></span>;                   <span class=\"comment\">// Foo2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">callFoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">foo</span>&lt;X&gt;(<span class=\"number\">5</span>);    <span class=\"comment\">// Foo0: Succeed, Foo1: Failed,  Foo2: Failed</span></span><br><span class=\"line\">    <span class=\"built_in\">foo</span>&lt;Y&gt;(<span class=\"number\">10</span>);   <span class=\"comment\">// Foo0: Failed,  Foo1: Succeed, Foo2: Failed</span></span><br><span class=\"line\">    <span class=\"built_in\">foo</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">15</span>); <span class=\"comment\">// Foo0: Failed,  Foo1: Failed,  Foo2: Succeed</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，就展示了SFIAE机制如何选择模板进行匹配的机制，当发现某个模版难以匹配上的时候，会选择其他可匹配的模板进行匹配，由此衍生出一个问题，就是当如果有多个模板可以被匹配的情况下，编译器如何决定被匹配的优先级？<br>事实上，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A，如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系），则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数。</p>\n<h1 id=\"SFINAE的应用\"><a href=\"#SFINAE的应用\" class=\"headerlink\" title=\"SFINAE的应用\"></a>SFINAE的应用</h1><p>SFINAE的主要应用之一是在模板编程中实现条件编译。通过合理地设计模板参数，我们可以利用SFINAE机制来选择性地启用或禁用模板的特定实例化版本。<br>通过下面这个函数，我们借助了SFINAE机制实现了一个类模板，并借此对对象中是否有foo这一成员函数进行判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检查是否有名为foo的成员函数的函数模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class has_foo &#123;</span><br><span class=\"line\">    // 检查是否有foo成员函数的辅助模板</span><br><span class=\"line\">    template &lt;typename U&gt;</span><br><span class=\"line\">    static char test(decltype(&amp;U::foo));</span><br><span class=\"line\"></span><br><span class=\"line\">    template &lt;typename U&gt;</span><br><span class=\"line\">    static long test(...);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static constexpr bool value = sizeof(test&lt;T&gt;(nullptr)) == sizeof(char);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 示例类型</span><br><span class=\"line\">struct A &#123;</span><br><span class=\"line\">    void foo() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct B &#123;</span><br><span class=\"line\">    // 没有foo成员函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;A has foo member function: &quot; &lt;&lt; has_foo&lt;A&gt;::value &lt;&lt; std::endl; // 输出true</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;B has foo member function: &quot; &lt;&lt; has_foo&lt;B&gt;::value &lt;&lt; std::endl; // 输出false</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上文中的例子就是被用以实现了部分的编译期自省（反射的一种）机制。</p>\n"},{"title":"模板编程（四）：元模板","date":"2024-02-12T18:30:31.000Z","_content":"这篇作为模板编程的第四篇，主要讲述一下一些元模板编程的特性。\n# 模板元编程概念\nC++ 模板的特性最早是为了支撑泛型，所谓的模板元编程其实是由于意外发现C++ 模板是图灵完备的（Turing-complete)后的一个衍生物。如果C++模板语法可以模拟图灵机的话，那么理论上来说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度，C++11 要求最多1024，C++98 要求最多 17）。\nC++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。\nC++ 模板是图灵完备的，这使得 C++ 成为两层次语言（two-level languages），其中，执行编译计算的代码称为静态代码（static code），执行运行期计算的代码称为动态代码（dynamic code），C++ 的静态代码由模板实现。\n具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义，而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）。编译期计算在编译过程中的位置请见下图，可以看到关键是模板的机制在编译具体代码（模板实例）前执行。\n![image.png](images/template-programming/1.png)\n\n# 模板元编程范式\n从编程范型（programming paradigm）上来说，C++ 模板是函数式编程（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储），用递归形式实现循环结构的功能。C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。\n从编程形式来看，模板的“<>”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。代码示意如下：\n```cpp\n#include <iostream>\n\ntemplate<typename T, int i=1>\nclass someComputing {\npublic:\ntypedef volatile T* retType; // 类型计算\nenum { retValume = i + someComputing<T, i-1>::retValume }; // 数值计算，递归\nstatic void f() { std::cout << \"someComputing: i=\" << i << '\\n'; }\n};\n\ntemplate<typename T> // 模板特例，递归终止条件\nclass someComputing<T, 0> {\npublic:\nenum { retValume = 0 };\n};\n\ntemplate<typename T>\nclass codeComputing {\npublic:\nstatic void f() { T::f(); } // 根据类型调用函数，代码计算\n};\n\nint main(){\n    someComputing<int>::retType a=0;\n    std::cout << sizeof(a) << '\\n'; // 64-bit 程序指针\n    std::cout << someComputing<int, 500>::retValume << '\\n'; // 1+2+...+500\n    codeComputing<someComputing<int, 99>>::f();\n    std::cin.get(); return 0;\n}\n```\n编程的概览图如下：\n![image.png](images/template-programming/2.png)\n# 模板元编程应用\n## 编译期间数值计算\n前面已经有了利用模板实现阶乘的示例代码，下面给出一份更简单的用模板实现求和的示例代码来说明模板在编译期间实现数值计算的具体原理。\n```cpp\n#include <iostream>\n\ntemplate<int N>\nclass sumt{\npublic: static const int ret = sumt<N-1>::ret + N;\n};\ntemplate<>\nclass sumt<0>{\npublic: static const int ret = 0;\n};\n\nint main() {\n    std::cout << sumt<5>::ret << '\\n';\n    std::cin.get(); return 0;\n}\n```\n当编译器遇到 sumt<5> 时，试图实例化之，sumt<5> 引用了 sumt<5-1> 即 sumt<4>，试图实例化 sumt<4>，以此类推，直到 sumt<0>，sumt<0> 匹配模板特例，sumt<0>::ret 为 0，sumt<1>::ret 为 sumt<0>::ret+1 为 1，以此类推，sumt<5>::ret 为 15。值得一提的是，虽然对用户来说程序只是输出了一个编译期常量 sumt<5>::ret，但在背后，编译器其实至少处理了 sumt<0> 到 sumt<5> 共 6 个类型。\n从这个例子我们也可以窥探 C++ 模板元编程的函数式编程范型，对比结构化求和程序：for(i=0,sum=0; i<=N; ++i) sum+=i; 用逐步改变存储（即变量 sum）的方式来对计算过程进行编程，模板元程序没有可变的存储（都是编译期常量，是不可变的变量），要表达求和过程就要用很多个常量：sumt<0>::ret，sumt<1>::ret，...，sumt<5>::ret 。函数式编程看上去似乎效率低下（因为它和数学接近，而不是和硬件工作方式接近），但有自己的优势：描述问题更加简洁清晰（前提是熟悉这种方式），没有可变的变量就没有数据依赖，方便进行并行化。\n## 循环展开\n部分古早的观点会认为，模板元编程会在循环展开中起到作用，例如一篇早期的测试：\n[http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html](http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html)\n其中提到了如以下代码以冒泡排序进行的示例：\n```cpp\n#include <utility>  // std::swap\n\n// dynamic code, 普通函数版本\nvoid bubbleSort(int* data, int n)\n{\n    for(int i=n-1; i>0; --i) {\n        for(int j=0; j<i; ++j)\n            if (data[j]>data[j+1]) std::swap(data[j], data[j+1]);\n    }\n}\n// 数据长度为 4 时，手动循环展开\ninline void bubbleSort4(int* data)\n{\n#define COMP_SWAP(i, j) if(data[i]>data[j]) std::swap(data[i], data[j])\n    COMP_SWAP(0, 1); COMP_SWAP(1, 2); COMP_SWAP(2, 3);\n    COMP_SWAP(0, 1); COMP_SWAP(1, 2);\n    COMP_SWAP(0, 1);\n}\n\n// 递归函数版本，指导模板思路，最后一个参数是哑参数（dummy parameter），仅为分辨重载函数\nclass recursion { };\nvoid bubbleSort(int* data, int n, recursion)\n{\n    if(n<=1) return;\n    for(int j=0; j<n-1; ++j) if(data[j]>data[j+1]) std::swap(data[j], data[j+1]);\n    bubbleSort(data, n-1, recursion());\n}\n\n// static code, 模板元编程版本\ntemplate<int i, int j>\ninline void IntSwap(int* data) { // 比较和交换两个相邻元素\n    if(data[i]>data[j]) std::swap(data[i], data[j]);\n}\n\ntemplate<int i, int j>\ninline void IntBubbleSortLoop(int* data) { // 一次冒泡，将前 i 个元素中最大的置换到最后\n    IntSwap<j, j+1>(data);\n    IntBubbleSortLoop<j<i-1?i:0, j<i-1?(j+1):0>(data);\n}\ntemplate<>\ninline void IntBubbleSortLoop<0, 0>(int*) { }\n\ntemplate<int n>\ninline void IntBubbleSort(int* data) { // 模板冒泡排序循环展开\n    IntBubbleSortLoop<n-1, 0>(data);\n    IntBubbleSort<n-1>(data);\n}\ntemplate<>\ninline void IntBubbleSort<1>(int* data) { }\n```\n我复现了该程序，并且使用了如下代码进行测试：\n```cpp\nint main() {\n    const int num=100000000;\n    int data[4]; int inidata[4]={3,4,2,1};\n    auto t1 = std::chrono::high_resolution_clock::now();\n    for(int i=0; i<num; ++i) { memcpy(data, inidata, 4); bubbleSort(data, 4); }\n    std::chrono::duration<double, std::milli> t1_cost = std::chrono::high_resolution_clock::now() - t1;\n    auto t2 = std::chrono::high_resolution_clock::now();\n    for(int i=0; i<num; ++i) { memcpy(data, inidata, 4); bubbleSort4(data); }\n    std::chrono::duration<double, std::milli> t2_cost = std::chrono::high_resolution_clock::now()-t2;\n    auto t3 = std::chrono::high_resolution_clock::now();\n    for(int i=0; i<num; ++i) { memcpy(data, inidata, 4); IntBubbleSort<4>(data); }\n    std::chrono::duration<double, std::milli> t3_cost = std::chrono::high_resolution_clock::now()-t3;\n\n    std::cout << \"迭代/模板 = \" <<t1_cost/t3_cost << '\\t' << \"迭代展开/模板 = \" <<t2_cost/t3_cost << '\\n';\n    std::cin.get();\n    return 0;\n}\n```\n对此，在没有开启编译器优化的情况下，我的复现结果如下：\n```cpp\n迭代/模板 = 0.347768\t迭代展开/模板 = 0.144893\n```\n可见，我们得到了超出预期的结果，不管是普通的迭代，还是手动的循环展开，在没有编译器优化的情况下都超过了通过模板进行展开的效率，这部分的差异应该是近十几年编译器的优化更新造成的，更具体的原因需要留待进一步的探索。\n\n# 参考链接\n[https://www.cnblogs.com/liangliangh/p/4219879.html](https://www.cnblogs.com/liangliangh/p/4219879.html)\n","source":"_posts/Template-programming-4.md","raw":"---\ntitle: 模板编程（四）：元模板\ndate: 2024-02-13 02:30:31\ntags: 模板编程\n---\n这篇作为模板编程的第四篇，主要讲述一下一些元模板编程的特性。\n# 模板元编程概念\nC++ 模板的特性最早是为了支撑泛型，所谓的模板元编程其实是由于意外发现C++ 模板是图灵完备的（Turing-complete)后的一个衍生物。如果C++模板语法可以模拟图灵机的话，那么理论上来说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度，C++11 要求最多1024，C++98 要求最多 17）。\nC++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。\nC++ 模板是图灵完备的，这使得 C++ 成为两层次语言（two-level languages），其中，执行编译计算的代码称为静态代码（static code），执行运行期计算的代码称为动态代码（dynamic code），C++ 的静态代码由模板实现。\n具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义，而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）。编译期计算在编译过程中的位置请见下图，可以看到关键是模板的机制在编译具体代码（模板实例）前执行。\n![image.png](images/template-programming/1.png)\n\n# 模板元编程范式\n从编程范型（programming paradigm）上来说，C++ 模板是函数式编程（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储），用递归形式实现循环结构的功能。C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。\n从编程形式来看，模板的“<>”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。代码示意如下：\n```cpp\n#include <iostream>\n\ntemplate<typename T, int i=1>\nclass someComputing {\npublic:\ntypedef volatile T* retType; // 类型计算\nenum { retValume = i + someComputing<T, i-1>::retValume }; // 数值计算，递归\nstatic void f() { std::cout << \"someComputing: i=\" << i << '\\n'; }\n};\n\ntemplate<typename T> // 模板特例，递归终止条件\nclass someComputing<T, 0> {\npublic:\nenum { retValume = 0 };\n};\n\ntemplate<typename T>\nclass codeComputing {\npublic:\nstatic void f() { T::f(); } // 根据类型调用函数，代码计算\n};\n\nint main(){\n    someComputing<int>::retType a=0;\n    std::cout << sizeof(a) << '\\n'; // 64-bit 程序指针\n    std::cout << someComputing<int, 500>::retValume << '\\n'; // 1+2+...+500\n    codeComputing<someComputing<int, 99>>::f();\n    std::cin.get(); return 0;\n}\n```\n编程的概览图如下：\n![image.png](images/template-programming/2.png)\n# 模板元编程应用\n## 编译期间数值计算\n前面已经有了利用模板实现阶乘的示例代码，下面给出一份更简单的用模板实现求和的示例代码来说明模板在编译期间实现数值计算的具体原理。\n```cpp\n#include <iostream>\n\ntemplate<int N>\nclass sumt{\npublic: static const int ret = sumt<N-1>::ret + N;\n};\ntemplate<>\nclass sumt<0>{\npublic: static const int ret = 0;\n};\n\nint main() {\n    std::cout << sumt<5>::ret << '\\n';\n    std::cin.get(); return 0;\n}\n```\n当编译器遇到 sumt<5> 时，试图实例化之，sumt<5> 引用了 sumt<5-1> 即 sumt<4>，试图实例化 sumt<4>，以此类推，直到 sumt<0>，sumt<0> 匹配模板特例，sumt<0>::ret 为 0，sumt<1>::ret 为 sumt<0>::ret+1 为 1，以此类推，sumt<5>::ret 为 15。值得一提的是，虽然对用户来说程序只是输出了一个编译期常量 sumt<5>::ret，但在背后，编译器其实至少处理了 sumt<0> 到 sumt<5> 共 6 个类型。\n从这个例子我们也可以窥探 C++ 模板元编程的函数式编程范型，对比结构化求和程序：for(i=0,sum=0; i<=N; ++i) sum+=i; 用逐步改变存储（即变量 sum）的方式来对计算过程进行编程，模板元程序没有可变的存储（都是编译期常量，是不可变的变量），要表达求和过程就要用很多个常量：sumt<0>::ret，sumt<1>::ret，...，sumt<5>::ret 。函数式编程看上去似乎效率低下（因为它和数学接近，而不是和硬件工作方式接近），但有自己的优势：描述问题更加简洁清晰（前提是熟悉这种方式），没有可变的变量就没有数据依赖，方便进行并行化。\n## 循环展开\n部分古早的观点会认为，模板元编程会在循环展开中起到作用，例如一篇早期的测试：\n[http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html](http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html)\n其中提到了如以下代码以冒泡排序进行的示例：\n```cpp\n#include <utility>  // std::swap\n\n// dynamic code, 普通函数版本\nvoid bubbleSort(int* data, int n)\n{\n    for(int i=n-1; i>0; --i) {\n        for(int j=0; j<i; ++j)\n            if (data[j]>data[j+1]) std::swap(data[j], data[j+1]);\n    }\n}\n// 数据长度为 4 时，手动循环展开\ninline void bubbleSort4(int* data)\n{\n#define COMP_SWAP(i, j) if(data[i]>data[j]) std::swap(data[i], data[j])\n    COMP_SWAP(0, 1); COMP_SWAP(1, 2); COMP_SWAP(2, 3);\n    COMP_SWAP(0, 1); COMP_SWAP(1, 2);\n    COMP_SWAP(0, 1);\n}\n\n// 递归函数版本，指导模板思路，最后一个参数是哑参数（dummy parameter），仅为分辨重载函数\nclass recursion { };\nvoid bubbleSort(int* data, int n, recursion)\n{\n    if(n<=1) return;\n    for(int j=0; j<n-1; ++j) if(data[j]>data[j+1]) std::swap(data[j], data[j+1]);\n    bubbleSort(data, n-1, recursion());\n}\n\n// static code, 模板元编程版本\ntemplate<int i, int j>\ninline void IntSwap(int* data) { // 比较和交换两个相邻元素\n    if(data[i]>data[j]) std::swap(data[i], data[j]);\n}\n\ntemplate<int i, int j>\ninline void IntBubbleSortLoop(int* data) { // 一次冒泡，将前 i 个元素中最大的置换到最后\n    IntSwap<j, j+1>(data);\n    IntBubbleSortLoop<j<i-1?i:0, j<i-1?(j+1):0>(data);\n}\ntemplate<>\ninline void IntBubbleSortLoop<0, 0>(int*) { }\n\ntemplate<int n>\ninline void IntBubbleSort(int* data) { // 模板冒泡排序循环展开\n    IntBubbleSortLoop<n-1, 0>(data);\n    IntBubbleSort<n-1>(data);\n}\ntemplate<>\ninline void IntBubbleSort<1>(int* data) { }\n```\n我复现了该程序，并且使用了如下代码进行测试：\n```cpp\nint main() {\n    const int num=100000000;\n    int data[4]; int inidata[4]={3,4,2,1};\n    auto t1 = std::chrono::high_resolution_clock::now();\n    for(int i=0; i<num; ++i) { memcpy(data, inidata, 4); bubbleSort(data, 4); }\n    std::chrono::duration<double, std::milli> t1_cost = std::chrono::high_resolution_clock::now() - t1;\n    auto t2 = std::chrono::high_resolution_clock::now();\n    for(int i=0; i<num; ++i) { memcpy(data, inidata, 4); bubbleSort4(data); }\n    std::chrono::duration<double, std::milli> t2_cost = std::chrono::high_resolution_clock::now()-t2;\n    auto t3 = std::chrono::high_resolution_clock::now();\n    for(int i=0; i<num; ++i) { memcpy(data, inidata, 4); IntBubbleSort<4>(data); }\n    std::chrono::duration<double, std::milli> t3_cost = std::chrono::high_resolution_clock::now()-t3;\n\n    std::cout << \"迭代/模板 = \" <<t1_cost/t3_cost << '\\t' << \"迭代展开/模板 = \" <<t2_cost/t3_cost << '\\n';\n    std::cin.get();\n    return 0;\n}\n```\n对此，在没有开启编译器优化的情况下，我的复现结果如下：\n```cpp\n迭代/模板 = 0.347768\t迭代展开/模板 = 0.144893\n```\n可见，我们得到了超出预期的结果，不管是普通的迭代，还是手动的循环展开，在没有编译器优化的情况下都超过了通过模板进行展开的效率，这部分的差异应该是近十几年编译器的优化更新造成的，更具体的原因需要留待进一步的探索。\n\n# 参考链接\n[https://www.cnblogs.com/liangliangh/p/4219879.html](https://www.cnblogs.com/liangliangh/p/4219879.html)\n","slug":"Template-programming-4","published":1,"updated":"2024-02-12T18:34:50.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsj9yi2k000060x59c25ar4g","content":"<p>这篇作为模板编程的第四篇，主要讲述一下一些元模板编程的特性。</p>\n<h1 id=\"模板元编程概念\"><a href=\"#模板元编程概念\" class=\"headerlink\" title=\"模板元编程概念\"></a>模板元编程概念</h1><p>C++ 模板的特性最早是为了支撑泛型，所谓的模板元编程其实是由于意外发现C++ 模板是图灵完备的（Turing-complete)后的一个衍生物。如果C++模板语法可以模拟图灵机的话，那么理论上来说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度，C++11 要求最多1024，C++98 要求最多 17）。<br>C++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。<br>C++ 模板是图灵完备的，这使得 C++ 成为两层次语言（two-level languages），其中，执行编译计算的代码称为静态代码（static code），执行运行期计算的代码称为动态代码（dynamic code），C++ 的静态代码由模板实现。<br>具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义，而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）。编译期计算在编译过程中的位置请见下图，可以看到关键是模板的机制在编译具体代码（模板实例）前执行。<br><img src=\"/images/template-programming/1.png\" alt=\"image.png\"></p>\n<h1 id=\"模板元编程范式\"><a href=\"#模板元编程范式\" class=\"headerlink\" title=\"模板元编程范式\"></a>模板元编程范式</h1><p>从编程范型（programming paradigm）上来说，C++ 模板是函数式编程（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储），用递归形式实现循环结构的功能。C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。<br>从编程形式来看，模板的“&lt;&gt;”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。代码示意如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> i=<span class=\"number\">1</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> someComputing &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">volatile</span> T* retType; <span class=\"comment\">// 类型计算</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123; retValume = i + someComputing&lt;T, i<span class=\"number\">-1</span>&gt;::retValume &#125;; <span class=\"comment\">// 数值计算，递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;someComputing: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"comment\">// 模板特例，递归终止条件</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">someComputing</span>&lt;T, <span class=\"number\">0</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123; retValume = <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">codeComputing</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; T::<span class=\"built_in\">f</span>(); &#125; <span class=\"comment\">// 根据类型调用函数，代码计算</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    someComputing&lt;<span class=\"type\">int</span>&gt;::retType a=<span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">sizeof</span>(a) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// 64-bit 程序指针</span></span><br><span class=\"line\">    std::cout &lt;&lt; someComputing&lt;<span class=\"type\">int</span>, <span class=\"number\">500</span>&gt;::retValume &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// 1+2+...+500</span></span><br><span class=\"line\">    codeComputing&lt;someComputing&lt;<span class=\"type\">int</span>, <span class=\"number\">99</span>&gt;&gt;::<span class=\"built_in\">f</span>();</span><br><span class=\"line\">    std::cin.<span class=\"built_in\">get</span>(); <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编程的概览图如下：<br><img src=\"/images/template-programming/2.png\" alt=\"image.png\"></p>\n<h1 id=\"模板元编程应用\"><a href=\"#模板元编程应用\" class=\"headerlink\" title=\"模板元编程应用\"></a>模板元编程应用</h1><h2 id=\"编译期间数值计算\"><a href=\"#编译期间数值计算\" class=\"headerlink\" title=\"编译期间数值计算\"></a>编译期间数值计算</h2><p>前面已经有了利用模板实现阶乘的示例代码，下面给出一份更简单的用模板实现求和的示例代码来说明模板在编译期间实现数值计算的具体原理。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> N&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">sumt</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> ret = sumt&lt;N<span class=\"number\">-1</span>&gt;::ret + N;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">sumt</span>&lt;<span class=\"number\">0</span>&gt;&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; sumt&lt;<span class=\"number\">5</span>&gt;::ret &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cin.<span class=\"built_in\">get</span>(); <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当编译器遇到 sumt&lt;5&gt; 时，试图实例化之，sumt&lt;5&gt; 引用了 sumt&lt;5-1&gt; 即 sumt&lt;4&gt;，试图实例化 sumt&lt;4&gt;，以此类推，直到 sumt&lt;0&gt;，sumt&lt;0&gt; 匹配模板特例，sumt&lt;0&gt;::ret 为 0，sumt&lt;1&gt;::ret 为 sumt&lt;0&gt;::ret+1 为 1，以此类推，sumt&lt;5&gt;::ret 为 15。值得一提的是，虽然对用户来说程序只是输出了一个编译期常量 sumt&lt;5&gt;::ret，但在背后，编译器其实至少处理了 sumt&lt;0&gt; 到 sumt&lt;5&gt; 共 6 个类型。<br>从这个例子我们也可以窥探 C++ 模板元编程的函数式编程范型，对比结构化求和程序：for(i&#x3D;0,sum&#x3D;0; i&lt;&#x3D;N; ++i) sum+&#x3D;i; 用逐步改变存储（即变量 sum）的方式来对计算过程进行编程，模板元程序没有可变的存储（都是编译期常量，是不可变的变量），要表达求和过程就要用很多个常量：sumt&lt;0&gt;::ret，sumt&lt;1&gt;::ret，…，sumt&lt;5&gt;::ret 。函数式编程看上去似乎效率低下（因为它和数学接近，而不是和硬件工作方式接近），但有自己的优势：描述问题更加简洁清晰（前提是熟悉这种方式），没有可变的变量就没有数据依赖，方便进行并行化。</p>\n<h2 id=\"循环展开\"><a href=\"#循环展开\" class=\"headerlink\" title=\"循环展开\"></a>循环展开</h2><p>部分古早的观点会认为，模板元编程会在循环展开中起到作用，例如一篇早期的测试：<br><a href=\"http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html\">http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui&#x2F;papers&#x2F;Template-Metaprograms&#x2F;meta-art.html</a><br>其中提到了如以下代码以冒泡排序进行的示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span>  <span class=\"comment\">// std::swap</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dynamic code, 普通函数版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* data, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>; i&gt;<span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;i; ++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[j]&gt;data[j+<span class=\"number\">1</span>]) std::<span class=\"built_in\">swap</span>(data[j], data[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 数据长度为 4 时，手动循环展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">bubbleSort4</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMP_SWAP(i, j) <span class=\"keyword\">if</span>(data[i]&gt;data[j]) std::swap(data[i], data[j])</span></span><br><span class=\"line\">    <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归函数版本，指导模板思路，最后一个参数是哑参数（dummy parameter），仅为分辨重载函数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">recursion</span> &#123; &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* data, <span class=\"type\">int</span> n, recursion)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;n<span class=\"number\">-1</span>; ++j) <span class=\"keyword\">if</span>(data[j]&gt;data[j+<span class=\"number\">1</span>]) std::<span class=\"built_in\">swap</span>(data[j], data[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">bubbleSort</span>(data, n<span class=\"number\">-1</span>, <span class=\"built_in\">recursion</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// static code, 模板元编程版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> i, <span class=\"type\">int</span> j&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">IntSwap</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span> </span>&#123; <span class=\"comment\">// 比较和交换两个相邻元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(data[i]&gt;data[j]) std::<span class=\"built_in\">swap</span>(data[i], data[j]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> i, <span class=\"type\">int</span> j&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">IntBubbleSortLoop</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span> </span>&#123; <span class=\"comment\">// 一次冒泡，将前 i 个元素中最大的置换到最后</span></span><br><span class=\"line\">    <span class=\"built_in\">IntSwap</span>&lt;j, j+<span class=\"number\">1</span>&gt;(data);</span><br><span class=\"line\">    IntBubbleSortLoop&lt;j&lt;i<span class=\"number\">-1</span>?i:<span class=\"number\">0</span>, <span class=\"built_in\">j</span>&lt;i<span class=\"number\">-1</span>?(j+<span class=\"number\">1</span>):<span class=\"number\">0</span>&gt;(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"built_in\">IntBubbleSortLoop</span>&lt;<span class=\"number\">0</span>, <span class=\"number\">0</span>&gt;(<span class=\"type\">int</span>*) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> n&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">IntBubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span> </span>&#123; <span class=\"comment\">// 模板冒泡排序循环展开</span></span><br><span class=\"line\">    <span class=\"built_in\">IntBubbleSortLoop</span>&lt;n<span class=\"number\">-1</span>, <span class=\"number\">0</span>&gt;(data);</span><br><span class=\"line\">    <span class=\"built_in\">IntBubbleSort</span>&lt;n<span class=\"number\">-1</span>&gt;(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"built_in\">IntBubbleSort</span>&lt;<span class=\"number\">1</span>&gt;(<span class=\"type\">int</span>* data) &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>我复现了该程序，并且使用了如下代码进行测试：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> num=<span class=\"number\">100000000</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> data[<span class=\"number\">4</span>]; <span class=\"type\">int</span> inidata[<span class=\"number\">4</span>]=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> t1 = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;num; ++i) &#123; <span class=\"built_in\">memcpy</span>(data, inidata, <span class=\"number\">4</span>); <span class=\"built_in\">bubbleSort</span>(data, <span class=\"number\">4</span>); &#125;</span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::milli&gt; t1_cost = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>() - t1;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> t2 = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;num; ++i) &#123; <span class=\"built_in\">memcpy</span>(data, inidata, <span class=\"number\">4</span>); <span class=\"built_in\">bubbleSort4</span>(data); &#125;</span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::milli&gt; t2_cost = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>()-t2;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> t3 = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;num; ++i) &#123; <span class=\"built_in\">memcpy</span>(data, inidata, <span class=\"number\">4</span>); <span class=\"built_in\">IntBubbleSort</span>&lt;<span class=\"number\">4</span>&gt;(data); &#125;</span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::milli&gt; t3_cost = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>()-t3;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;迭代/模板 = &quot;</span> &lt;&lt;t1_cost/t3_cost &lt;&lt; <span class=\"string\">&#x27;\\t&#x27;</span> &lt;&lt; <span class=\"string\">&quot;迭代展开/模板 = &quot;</span> &lt;&lt;t2_cost/t3_cost &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cin.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对此，在没有开启编译器优化的情况下，我的复现结果如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">迭代/模板 = <span class=\"number\">0.347768</span>\t迭代展开/模板 = <span class=\"number\">0.144893</span></span><br></pre></td></tr></table></figure>\n<p>可见，我们得到了超出预期的结果，不管是普通的迭代，还是手动的循环展开，在没有编译器优化的情况下都超过了通过模板进行展开的效率，这部分的差异应该是近十几年编译器的优化更新造成的，更具体的原因需要留待进一步的探索。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.cnblogs.com/liangliangh/p/4219879.html\">https://www.cnblogs.com/liangliangh/p/4219879.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇作为模板编程的第四篇，主要讲述一下一些元模板编程的特性。</p>\n<h1 id=\"模板元编程概念\"><a href=\"#模板元编程概念\" class=\"headerlink\" title=\"模板元编程概念\"></a>模板元编程概念</h1><p>C++ 模板的特性最早是为了支撑泛型，所谓的模板元编程其实是由于意外发现C++ 模板是图灵完备的（Turing-complete)后的一个衍生物。如果C++模板语法可以模拟图灵机的话，那么理论上来说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度，C++11 要求最多1024，C++98 要求最多 17）。<br>C++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。<br>C++ 模板是图灵完备的，这使得 C++ 成为两层次语言（two-level languages），其中，执行编译计算的代码称为静态代码（static code），执行运行期计算的代码称为动态代码（dynamic code），C++ 的静态代码由模板实现。<br>具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义，而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）。编译期计算在编译过程中的位置请见下图，可以看到关键是模板的机制在编译具体代码（模板实例）前执行。<br><img src=\"/images/template-programming/1.png\" alt=\"image.png\"></p>\n<h1 id=\"模板元编程范式\"><a href=\"#模板元编程范式\" class=\"headerlink\" title=\"模板元编程范式\"></a>模板元编程范式</h1><p>从编程范型（programming paradigm）上来说，C++ 模板是函数式编程（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储），用递归形式实现循环结构的功能。C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。<br>从编程形式来看，模板的“&lt;&gt;”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。代码示意如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> i=<span class=\"number\">1</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> someComputing &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">volatile</span> T* retType; <span class=\"comment\">// 类型计算</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123; retValume = i + someComputing&lt;T, i<span class=\"number\">-1</span>&gt;::retValume &#125;; <span class=\"comment\">// 数值计算，递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;someComputing: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"comment\">// 模板特例，递归终止条件</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">someComputing</span>&lt;T, <span class=\"number\">0</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123; retValume = <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">codeComputing</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; T::<span class=\"built_in\">f</span>(); &#125; <span class=\"comment\">// 根据类型调用函数，代码计算</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    someComputing&lt;<span class=\"type\">int</span>&gt;::retType a=<span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">sizeof</span>(a) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// 64-bit 程序指针</span></span><br><span class=\"line\">    std::cout &lt;&lt; someComputing&lt;<span class=\"type\">int</span>, <span class=\"number\">500</span>&gt;::retValume &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// 1+2+...+500</span></span><br><span class=\"line\">    codeComputing&lt;someComputing&lt;<span class=\"type\">int</span>, <span class=\"number\">99</span>&gt;&gt;::<span class=\"built_in\">f</span>();</span><br><span class=\"line\">    std::cin.<span class=\"built_in\">get</span>(); <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编程的概览图如下：<br><img src=\"/images/template-programming/2.png\" alt=\"image.png\"></p>\n<h1 id=\"模板元编程应用\"><a href=\"#模板元编程应用\" class=\"headerlink\" title=\"模板元编程应用\"></a>模板元编程应用</h1><h2 id=\"编译期间数值计算\"><a href=\"#编译期间数值计算\" class=\"headerlink\" title=\"编译期间数值计算\"></a>编译期间数值计算</h2><p>前面已经有了利用模板实现阶乘的示例代码，下面给出一份更简单的用模板实现求和的示例代码来说明模板在编译期间实现数值计算的具体原理。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> N&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">sumt</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> ret = sumt&lt;N<span class=\"number\">-1</span>&gt;::ret + N;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">sumt</span>&lt;<span class=\"number\">0</span>&gt;&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; sumt&lt;<span class=\"number\">5</span>&gt;::ret &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cin.<span class=\"built_in\">get</span>(); <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当编译器遇到 sumt&lt;5&gt; 时，试图实例化之，sumt&lt;5&gt; 引用了 sumt&lt;5-1&gt; 即 sumt&lt;4&gt;，试图实例化 sumt&lt;4&gt;，以此类推，直到 sumt&lt;0&gt;，sumt&lt;0&gt; 匹配模板特例，sumt&lt;0&gt;::ret 为 0，sumt&lt;1&gt;::ret 为 sumt&lt;0&gt;::ret+1 为 1，以此类推，sumt&lt;5&gt;::ret 为 15。值得一提的是，虽然对用户来说程序只是输出了一个编译期常量 sumt&lt;5&gt;::ret，但在背后，编译器其实至少处理了 sumt&lt;0&gt; 到 sumt&lt;5&gt; 共 6 个类型。<br>从这个例子我们也可以窥探 C++ 模板元编程的函数式编程范型，对比结构化求和程序：for(i&#x3D;0,sum&#x3D;0; i&lt;&#x3D;N; ++i) sum+&#x3D;i; 用逐步改变存储（即变量 sum）的方式来对计算过程进行编程，模板元程序没有可变的存储（都是编译期常量，是不可变的变量），要表达求和过程就要用很多个常量：sumt&lt;0&gt;::ret，sumt&lt;1&gt;::ret，…，sumt&lt;5&gt;::ret 。函数式编程看上去似乎效率低下（因为它和数学接近，而不是和硬件工作方式接近），但有自己的优势：描述问题更加简洁清晰（前提是熟悉这种方式），没有可变的变量就没有数据依赖，方便进行并行化。</p>\n<h2 id=\"循环展开\"><a href=\"#循环展开\" class=\"headerlink\" title=\"循环展开\"></a>循环展开</h2><p>部分古早的观点会认为，模板元编程会在循环展开中起到作用，例如一篇早期的测试：<br><a href=\"http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html\">http://web.archive.org/web/20050310091456/http://osl.iu.edu/~tveldhui&#x2F;papers&#x2F;Template-Metaprograms&#x2F;meta-art.html</a><br>其中提到了如以下代码以冒泡排序进行的示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span>  <span class=\"comment\">// std::swap</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dynamic code, 普通函数版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* data, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>; i&gt;<span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;i; ++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[j]&gt;data[j+<span class=\"number\">1</span>]) std::<span class=\"built_in\">swap</span>(data[j], data[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 数据长度为 4 时，手动循环展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">bubbleSort4</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMP_SWAP(i, j) <span class=\"keyword\">if</span>(data[i]&gt;data[j]) std::swap(data[i], data[j])</span></span><br><span class=\"line\">    <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">COMP_SWAP</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归函数版本，指导模板思路，最后一个参数是哑参数（dummy parameter），仅为分辨重载函数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">recursion</span> &#123; &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* data, <span class=\"type\">int</span> n, recursion)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;n<span class=\"number\">-1</span>; ++j) <span class=\"keyword\">if</span>(data[j]&gt;data[j+<span class=\"number\">1</span>]) std::<span class=\"built_in\">swap</span>(data[j], data[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">bubbleSort</span>(data, n<span class=\"number\">-1</span>, <span class=\"built_in\">recursion</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// static code, 模板元编程版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> i, <span class=\"type\">int</span> j&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">IntSwap</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span> </span>&#123; <span class=\"comment\">// 比较和交换两个相邻元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(data[i]&gt;data[j]) std::<span class=\"built_in\">swap</span>(data[i], data[j]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> i, <span class=\"type\">int</span> j&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">IntBubbleSortLoop</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span> </span>&#123; <span class=\"comment\">// 一次冒泡，将前 i 个元素中最大的置换到最后</span></span><br><span class=\"line\">    <span class=\"built_in\">IntSwap</span>&lt;j, j+<span class=\"number\">1</span>&gt;(data);</span><br><span class=\"line\">    IntBubbleSortLoop&lt;j&lt;i<span class=\"number\">-1</span>?i:<span class=\"number\">0</span>, <span class=\"built_in\">j</span>&lt;i<span class=\"number\">-1</span>?(j+<span class=\"number\">1</span>):<span class=\"number\">0</span>&gt;(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"built_in\">IntBubbleSortLoop</span>&lt;<span class=\"number\">0</span>, <span class=\"number\">0</span>&gt;(<span class=\"type\">int</span>*) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">int</span> n&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">IntBubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* data)</span> </span>&#123; <span class=\"comment\">// 模板冒泡排序循环展开</span></span><br><span class=\"line\">    <span class=\"built_in\">IntBubbleSortLoop</span>&lt;n<span class=\"number\">-1</span>, <span class=\"number\">0</span>&gt;(data);</span><br><span class=\"line\">    <span class=\"built_in\">IntBubbleSort</span>&lt;n<span class=\"number\">-1</span>&gt;(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"built_in\">IntBubbleSort</span>&lt;<span class=\"number\">1</span>&gt;(<span class=\"type\">int</span>* data) &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>我复现了该程序，并且使用了如下代码进行测试：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> num=<span class=\"number\">100000000</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> data[<span class=\"number\">4</span>]; <span class=\"type\">int</span> inidata[<span class=\"number\">4</span>]=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> t1 = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;num; ++i) &#123; <span class=\"built_in\">memcpy</span>(data, inidata, <span class=\"number\">4</span>); <span class=\"built_in\">bubbleSort</span>(data, <span class=\"number\">4</span>); &#125;</span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::milli&gt; t1_cost = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>() - t1;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> t2 = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;num; ++i) &#123; <span class=\"built_in\">memcpy</span>(data, inidata, <span class=\"number\">4</span>); <span class=\"built_in\">bubbleSort4</span>(data); &#125;</span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::milli&gt; t2_cost = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>()-t2;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> t3 = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;num; ++i) &#123; <span class=\"built_in\">memcpy</span>(data, inidata, <span class=\"number\">4</span>); <span class=\"built_in\">IntBubbleSort</span>&lt;<span class=\"number\">4</span>&gt;(data); &#125;</span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::milli&gt; t3_cost = std::chrono::high_resolution_clock::<span class=\"built_in\">now</span>()-t3;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;迭代/模板 = &quot;</span> &lt;&lt;t1_cost/t3_cost &lt;&lt; <span class=\"string\">&#x27;\\t&#x27;</span> &lt;&lt; <span class=\"string\">&quot;迭代展开/模板 = &quot;</span> &lt;&lt;t2_cost/t3_cost &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cin.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对此，在没有开启编译器优化的情况下，我的复现结果如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">迭代/模板 = <span class=\"number\">0.347768</span>\t迭代展开/模板 = <span class=\"number\">0.144893</span></span><br></pre></td></tr></table></figure>\n<p>可见，我们得到了超出预期的结果，不管是普通的迭代，还是手动的循环展开，在没有编译器优化的情况下都超过了通过模板进行展开的效率，这部分的差异应该是近十几年编译器的优化更新造成的，更具体的原因需要留待进一步的探索。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.cnblogs.com/liangliangh/p/4219879.html\">https://www.cnblogs.com/liangliangh/p/4219879.html</a></p>\n"},{"title":"性能优化（三）：无锁与CAS指令","date":"2024-02-13T16:19:58.000Z","_content":"之前在聊到性能优化的时候，非常泛泛而谈得聊了一些技巧，在接下来几篇博客中，打算专门细化一下，当然也不是从头开始，算是整合之前的一些散落的随记吧。\n这篇是关于无锁编程的原理介绍，在开篇的时候，我先阐述一下我的理解：\n> 真正的无锁编程并不存在，它只是无限地将锁的颗粒度降低。\n\n# 无锁编程的背景\n## 需要互斥锁的原因\n在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。\n在本质上，可以归结为两种原因：\n\n- 需要安全地并发访问共享资源。\n- 需要在共享资源上控制访问顺序。\n\n它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。\n## 互斥锁存在的问题\n### 互斥锁的本质\n互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。\n```cpp\nstruct mutex_lock{\n\tatomic_t state;\n\tobject owner;\n\tqueue waiting_threads;\n}\n```\n在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：\n\n1. 如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；\n2. 如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。\n\n在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“**线程切换**”。\n### 互斥锁带来的开销\n#### 互斥锁本身的开销\n使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。\n#### 线程切换的开销\n一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）\n**直接开销：**\n\n1. 切换页表全局目录\n2. 切换内核态堆栈\n3. 切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）\n4. 刷新TLB（在切换后进行页表查询时将全部击穿TLB）\n\n**间接开销：**\n间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 \n\n感兴趣的同学可以参考这篇文章：\n[https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf](https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf)\n# 无锁编程原理\n继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。\n所以，身为程序开发者，只能从另外的角度来消除锁的影响。\n## 从自旋锁说起\n直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。\n那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：\n```cpp\natomic<bool> isLock = false;\nvoid ThreadFunc(){\n\tbool expect = flase;\n\twhile(!isLock.compare_exchange_weak(expect,true)){\n    \texpect = false;\n    }\n\t//do something\n    isLock.store(false);\n}\n\n```\n这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。\n## atomic凭什么保证原子性?\n上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？\n事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。\n在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock = xx 这个操作不被打断或者穿插。\n## 如果多核条件下原子性还存在吗？\n但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？\n### 单核心CPU的写策略\n先简单回顾一下单核心CPU的两种写策略：\n\n- **写直达**：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持**强一致性**，这种做法影响写操作的性能。\n- **写回**：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：\n   - 如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。\n   - 如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：\n      - **若该缓存行被标记为已修改**，读写操作都会将缓存行中现存的数据**写回**内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；\n      - **若该缓存行未被标记为已修改**，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。\n### 多核心CPU的写策略\n早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。\n\n- **写传播：**CPU进行缓存数据更新时需要告知其他CPU\n\n如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务**串行化**，否则会出现问题。\n举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。\nCPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。\nMESI首先规定了缓存的四种状态：\n\n- _Modified_，已修改\n- _Exclusive_，独占\n- _Shared_，共享\n- _Invalidated_，已失效\n\n![image.png](images/preformance-optimize-overview/2.png)\n### 一些其他的引申\n缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，暂时只对这边做一个简单介绍，留待之后进行详细展开。\n#### Store Buffer\nCPU进行写传播的时候，为了实现异步性而引入的一个写缓冲区。\n#### Invalidate Queue\n对于Store Buffer中异步发送的指令，Invalidate Queue用队列的结构对指令得到的响应进行接收，并且根据先入先出的顺序进行消费。\n## 是否可能存在指令乱序的问题？\n### 跨线程的无依赖指令可能存在乱序\n到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1;  //1\n    b = a;  //2\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    assert(b == 1); //5\n}\n```\n由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。\n### 指令重排的本质原因\n指令重排的有两个层次的原因，一个是编译器对无依赖性的语句进行优化，一个是CPU的指令执行时候在流水线上的并发结构。\n### 通过内存屏障解决指令乱序问题\n#### 内存屏障概念\n内存屏障就是将内存/缓存的读写操作过程进行分隔。\n缓存和内存之间的操作分为 Store 和 Load 两种。\n\n- Store：将处理器缓存的数据刷新到内存中。\n- Load：将内存存储的数据拷贝到处理器的缓存中。\n\n![image.png](images/preformance-optimize-overview/3.png)\n从上表中可以看出来，内存屏障的主要作用就是通过**强制读写内存来间接避免指令重排**。\n**_在本质上是说是强制消费完了__tore Buffer和Invalidate Queue中的内容。_**\n所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1//1\n    b = a;  //2\n    StoreStoreBarriers();\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    LoadLoadBarriers();\n    assert(b == 1); //5\n}\n```\n#### C++对内存屏障提供的接口\n假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。\n因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。\nC++提供了六种严格度不同的内存序：\n```cpp\ntypedef enum memory_order\n{\n    memory_order_relaxed,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_consume,\n    memory_order_acq_rel,\n    memory_order_seq_cst,\n} memory_oder;\n```\n**memory_order_relaxed**是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。\n在以下代码的示例中，使用了**memory_order_relaxed**内存序，执行顺序有可能是0或者42\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;//1\n    guard.store(1, std::memory_order_relaxed);//2\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_relaxed) != 0)//3\n    {\n        p = payload;//4\n    }\n}\n```\n**memory_order_seq_cst**在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_seq_cst);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_seq_cst) != 0)\n    {\n        p = payload;\n    }\n}\n```\n**memory_order_release** 和 **memory_order_acquire**是释放和获取序列。\nrelease 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。\nacquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。\n使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。\n这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。\n在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_release);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_acquire) != 0)\n    {\n        p = payload;\n    }\n}\n\n```\n**memory_order_release** 和 **memory_order_consume **是数据依赖序列。\nmemory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。\n在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。\n# 其他想说的事情\n因为这个是我整合了几篇杂乱随记出来的内容，虽然经过我对主线的梳理，但还是感觉内容的破碎感很强，我写到六种内存序后戛然而止，颇有种意犹未尽之感。\n我感觉还有很多东西可以补充在这篇博客上面，包括CPU的流水线结构，Store Buffer和Invalidate Queue机制，CPU多核心进行同步的细节等，这些我自觉是与无锁编程相关的内容之后都会逐步在这篇的基础上继续补充，希望它越来越完善。\n\n","source":"_posts/Preformance-optimize-3.md","raw":"---\ntitle: 性能优化（三）：无锁与CAS指令\ndate: 2024-02-14 00:19:58\ntags: 性能优化\n---\n之前在聊到性能优化的时候，非常泛泛而谈得聊了一些技巧，在接下来几篇博客中，打算专门细化一下，当然也不是从头开始，算是整合之前的一些散落的随记吧。\n这篇是关于无锁编程的原理介绍，在开篇的时候，我先阐述一下我的理解：\n> 真正的无锁编程并不存在，它只是无限地将锁的颗粒度降低。\n\n# 无锁编程的背景\n## 需要互斥锁的原因\n在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。\n在本质上，可以归结为两种原因：\n\n- 需要安全地并发访问共享资源。\n- 需要在共享资源上控制访问顺序。\n\n它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。\n## 互斥锁存在的问题\n### 互斥锁的本质\n互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。\n```cpp\nstruct mutex_lock{\n\tatomic_t state;\n\tobject owner;\n\tqueue waiting_threads;\n}\n```\n在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：\n\n1. 如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；\n2. 如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。\n\n在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“**线程切换**”。\n### 互斥锁带来的开销\n#### 互斥锁本身的开销\n使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。\n#### 线程切换的开销\n一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）\n**直接开销：**\n\n1. 切换页表全局目录\n2. 切换内核态堆栈\n3. 切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）\n4. 刷新TLB（在切换后进行页表查询时将全部击穿TLB）\n\n**间接开销：**\n间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 \n\n感兴趣的同学可以参考这篇文章：\n[https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf](https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf)\n# 无锁编程原理\n继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。\n所以，身为程序开发者，只能从另外的角度来消除锁的影响。\n## 从自旋锁说起\n直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。\n那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：\n```cpp\natomic<bool> isLock = false;\nvoid ThreadFunc(){\n\tbool expect = flase;\n\twhile(!isLock.compare_exchange_weak(expect,true)){\n    \texpect = false;\n    }\n\t//do something\n    isLock.store(false);\n}\n\n```\n这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。\n## atomic凭什么保证原子性?\n上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？\n事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。\n在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock = xx 这个操作不被打断或者穿插。\n## 如果多核条件下原子性还存在吗？\n但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？\n### 单核心CPU的写策略\n先简单回顾一下单核心CPU的两种写策略：\n\n- **写直达**：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持**强一致性**，这种做法影响写操作的性能。\n- **写回**：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：\n   - 如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。\n   - 如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：\n      - **若该缓存行被标记为已修改**，读写操作都会将缓存行中现存的数据**写回**内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；\n      - **若该缓存行未被标记为已修改**，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。\n### 多核心CPU的写策略\n早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。\n\n- **写传播：**CPU进行缓存数据更新时需要告知其他CPU\n\n如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务**串行化**，否则会出现问题。\n举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。\nCPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。\nMESI首先规定了缓存的四种状态：\n\n- _Modified_，已修改\n- _Exclusive_，独占\n- _Shared_，共享\n- _Invalidated_，已失效\n\n![image.png](images/preformance-optimize-overview/2.png)\n### 一些其他的引申\n缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，暂时只对这边做一个简单介绍，留待之后进行详细展开。\n#### Store Buffer\nCPU进行写传播的时候，为了实现异步性而引入的一个写缓冲区。\n#### Invalidate Queue\n对于Store Buffer中异步发送的指令，Invalidate Queue用队列的结构对指令得到的响应进行接收，并且根据先入先出的顺序进行消费。\n## 是否可能存在指令乱序的问题？\n### 跨线程的无依赖指令可能存在乱序\n到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1;  //1\n    b = a;  //2\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    assert(b == 1); //5\n}\n```\n由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。\n### 指令重排的本质原因\n指令重排的有两个层次的原因，一个是编译器对无依赖性的语句进行优化，一个是CPU的指令执行时候在流水线上的并发结构。\n### 通过内存屏障解决指令乱序问题\n#### 内存屏障概念\n内存屏障就是将内存/缓存的读写操作过程进行分隔。\n缓存和内存之间的操作分为 Store 和 Load 两种。\n\n- Store：将处理器缓存的数据刷新到内存中。\n- Load：将内存存储的数据拷贝到处理器的缓存中。\n\n![image.png](images/preformance-optimize-overview/3.png)\n从上表中可以看出来，内存屏障的主要作用就是通过**强制读写内存来间接避免指令重排**。\n**_在本质上是说是强制消费完了__tore Buffer和Invalidate Queue中的内容。_**\n所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：\n```cpp\n//共享变量\nint a, b, c = 0;\n\nvoid thread1() {\n    a = 1//1\n    b = a;  //2\n    StoreStoreBarriers();\n    c = 1;  //3\n}\n\nvoid thread2() {\n    while(c == 0) continue; //4 \n    LoadLoadBarriers();\n    assert(b == 1); //5\n}\n```\n#### C++对内存屏障提供的接口\n假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。\n因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。\nC++提供了六种严格度不同的内存序：\n```cpp\ntypedef enum memory_order\n{\n    memory_order_relaxed,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_consume,\n    memory_order_acq_rel,\n    memory_order_seq_cst,\n} memory_oder;\n```\n**memory_order_relaxed**是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。\n在以下代码的示例中，使用了**memory_order_relaxed**内存序，执行顺序有可能是0或者42\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;//1\n    guard.store(1, std::memory_order_relaxed);//2\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_relaxed) != 0)//3\n    {\n        p = payload;//4\n    }\n}\n```\n**memory_order_seq_cst**在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_seq_cst);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_seq_cst) != 0)\n    {\n        p = payload;\n    }\n}\n```\n**memory_order_release** 和 **memory_order_acquire**是释放和获取序列。\nrelease 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。\nacquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。\n使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。\n这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。\n在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。\n```cpp\natomic<int> guard(0);\nint payload = 0;\n\n// 在线程1运行的函数\nvoid thread1()\n{\n    payload = 42;\n    guard.store(1, std::memory_order_release);\n}\n\n// 在线程2运行的函数\nvoid thread2()\n{\n    if (guard.load(std::memory_order_acquire) != 0)\n    {\n        p = payload;\n    }\n}\n\n```\n**memory_order_release** 和 **memory_order_consume **是数据依赖序列。\nmemory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。\n在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。\n# 其他想说的事情\n因为这个是我整合了几篇杂乱随记出来的内容，虽然经过我对主线的梳理，但还是感觉内容的破碎感很强，我写到六种内存序后戛然而止，颇有种意犹未尽之感。\n我感觉还有很多东西可以补充在这篇博客上面，包括CPU的流水线结构，Store Buffer和Invalidate Queue机制，CPU多核心进行同步的细节等，这些我自觉是与无锁编程相关的内容之后都会逐步在这篇的基础上继续补充，希望它越来越完善。\n\n","slug":"Preformance-optimize-3","published":1,"updated":"2024-02-13T16:22:35.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clskkngde00005fx5gubog2bh","content":"<p>之前在聊到性能优化的时候，非常泛泛而谈得聊了一些技巧，在接下来几篇博客中，打算专门细化一下，当然也不是从头开始，算是整合之前的一些散落的随记吧。<br>这篇是关于无锁编程的原理介绍，在开篇的时候，我先阐述一下我的理解：</p>\n<blockquote>\n<p>真正的无锁编程并不存在，它只是无限地将锁的颗粒度降低。</p>\n</blockquote>\n<h1 id=\"无锁编程的背景\"><a href=\"#无锁编程的背景\" class=\"headerlink\" title=\"无锁编程的背景\"></a>无锁编程的背景</h1><h2 id=\"需要互斥锁的原因\"><a href=\"#需要互斥锁的原因\" class=\"headerlink\" title=\"需要互斥锁的原因\"></a>需要互斥锁的原因</h2><p>在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。<br>在本质上，可以归结为两种原因：</p>\n<ul>\n<li>需要安全地并发访问共享资源。</li>\n<li>需要在共享资源上控制访问顺序。</li>\n</ul>\n<p>它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。</p>\n<h2 id=\"互斥锁存在的问题\"><a href=\"#互斥锁存在的问题\" class=\"headerlink\" title=\"互斥锁存在的问题\"></a>互斥锁存在的问题</h2><h3 id=\"互斥锁的本质\"><a href=\"#互斥锁的本质\" class=\"headerlink\" title=\"互斥锁的本质\"></a>互斥锁的本质</h3><p>互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mutex_lock</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">atomic_t</span> state;</span><br><span class=\"line\">\tobject owner;</span><br><span class=\"line\">\tqueue waiting_threads;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：</p>\n<ol>\n<li>如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；</li>\n<li>如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。</li>\n</ol>\n<p>在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“<strong>线程切换</strong>”。</p>\n<h3 id=\"互斥锁带来的开销\"><a href=\"#互斥锁带来的开销\" class=\"headerlink\" title=\"互斥锁带来的开销\"></a>互斥锁带来的开销</h3><h4 id=\"互斥锁本身的开销\"><a href=\"#互斥锁本身的开销\" class=\"headerlink\" title=\"互斥锁本身的开销\"></a>互斥锁本身的开销</h4><p>使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。</p>\n<h4 id=\"线程切换的开销\"><a href=\"#线程切换的开销\" class=\"headerlink\" title=\"线程切换的开销\"></a>线程切换的开销</h4><p>一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）<br><strong>直接开销：</strong></p>\n<ol>\n<li>切换页表全局目录</li>\n<li>切换内核态堆栈</li>\n<li>切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）</li>\n<li>刷新TLB（在切换后进行页表查询时将全部击穿TLB）</li>\n</ol>\n<p><strong>间接开销：</strong><br>间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 </p>\n<p>感兴趣的同学可以参考这篇文章：<br><a href=\"https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf\">https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf</a></p>\n<h1 id=\"无锁编程原理\"><a href=\"#无锁编程原理\" class=\"headerlink\" title=\"无锁编程原理\"></a>无锁编程原理</h1><p>继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。<br>所以，身为程序开发者，只能从另外的角度来消除锁的影响。</p>\n<h2 id=\"从自旋锁说起\"><a href=\"#从自旋锁说起\" class=\"headerlink\" title=\"从自旋锁说起\"></a>从自旋锁说起</h2><p>直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。<br>那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">atomic&lt;<span class=\"type\">bool</span>&gt; isLock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> expect = flase;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!isLock.<span class=\"built_in\">compare_exchange_weak</span>(expect,<span class=\"literal\">true</span>))&#123;</span><br><span class=\"line\">    \texpect = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//do something</span></span><br><span class=\"line\">    isLock.<span class=\"built_in\">store</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。</p>\n<h2 id=\"atomic凭什么保证原子性\"><a href=\"#atomic凭什么保证原子性\" class=\"headerlink\" title=\"atomic凭什么保证原子性?\"></a>atomic凭什么保证原子性?</h2><p>上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？<br>事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。<br>在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock &#x3D; xx 这个操作不被打断或者穿插。</p>\n<h2 id=\"如果多核条件下原子性还存在吗？\"><a href=\"#如果多核条件下原子性还存在吗？\" class=\"headerlink\" title=\"如果多核条件下原子性还存在吗？\"></a>如果多核条件下原子性还存在吗？</h2><p>但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？</p>\n<h3 id=\"单核心CPU的写策略\"><a href=\"#单核心CPU的写策略\" class=\"headerlink\" title=\"单核心CPU的写策略\"></a>单核心CPU的写策略</h3><p>先简单回顾一下单核心CPU的两种写策略：</p>\n<ul>\n<li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li>\n<li><strong>写回</strong>：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：<ul>\n<li>如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。</li>\n<li>如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：<ul>\n<li><strong>若该缓存行被标记为已修改</strong>，读写操作都会将缓存行中现存的数据<strong>写回</strong>内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；</li>\n<li><strong>若该缓存行未被标记为已修改</strong>，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"多核心CPU的写策略\"><a href=\"#多核心CPU的写策略\" class=\"headerlink\" title=\"多核心CPU的写策略\"></a>多核心CPU的写策略</h3><p>早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。</p>\n<ul>\n<li><strong>写传播：</strong>CPU进行缓存数据更新时需要告知其他CPU</li>\n</ul>\n<p>如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务<strong>串行化</strong>，否则会出现问题。<br>举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。<br>CPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。<br>MESI首先规定了缓存的四种状态：</p>\n<ul>\n<li>_Modified_，已修改</li>\n<li>_Exclusive_，独占</li>\n<li>_Shared_，共享</li>\n<li>_Invalidated_，已失效</li>\n</ul>\n<p><img src=\"/images/preformance-optimize-overview/2.png\" alt=\"image.png\"></p>\n<h3 id=\"一些其他的引申\"><a href=\"#一些其他的引申\" class=\"headerlink\" title=\"一些其他的引申\"></a>一些其他的引申</h3><p>缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，暂时只对这边做一个简单介绍，留待之后进行详细展开。</p>\n<h4 id=\"Store-Buffer\"><a href=\"#Store-Buffer\" class=\"headerlink\" title=\"Store Buffer\"></a>Store Buffer</h4><p>CPU进行写传播的时候，为了实现异步性而引入的一个写缓冲区。</p>\n<h4 id=\"Invalidate-Queue\"><a href=\"#Invalidate-Queue\" class=\"headerlink\" title=\"Invalidate Queue\"></a>Invalidate Queue</h4><p>对于Store Buffer中异步发送的指令，Invalidate Queue用队列的结构对指令得到的响应进行接收，并且根据先入先出的顺序进行消费。</p>\n<h2 id=\"是否可能存在指令乱序的问题？\"><a href=\"#是否可能存在指令乱序的问题？\" class=\"headerlink\" title=\"是否可能存在指令乱序的问题？\"></a>是否可能存在指令乱序的问题？</h2><h3 id=\"跨线程的无依赖指令可能存在乱序\"><a href=\"#跨线程的无依赖指令可能存在乱序\" class=\"headerlink\" title=\"跨线程的无依赖指令可能存在乱序\"></a>跨线程的无依赖指令可能存在乱序</h3><p>到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;  <span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。</p>\n<h3 id=\"指令重排的本质原因\"><a href=\"#指令重排的本质原因\" class=\"headerlink\" title=\"指令重排的本质原因\"></a>指令重排的本质原因</h3><p>指令重排的有两个层次的原因，一个是编译器对无依赖性的语句进行优化，一个是CPU的指令执行时候在流水线上的并发结构。</p>\n<h3 id=\"通过内存屏障解决指令乱序问题\"><a href=\"#通过内存屏障解决指令乱序问题\" class=\"headerlink\" title=\"通过内存屏障解决指令乱序问题\"></a>通过内存屏障解决指令乱序问题</h3><h4 id=\"内存屏障概念\"><a href=\"#内存屏障概念\" class=\"headerlink\" title=\"内存屏障概念\"></a>内存屏障概念</h4><p>内存屏障就是将内存&#x2F;缓存的读写操作过程进行分隔。<br>缓存和内存之间的操作分为 Store 和 Load 两种。</p>\n<ul>\n<li>Store：将处理器缓存的数据刷新到内存中。</li>\n<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>\n</ul>\n<p><img src=\"/images/preformance-optimize-overview/3.png\" alt=\"image.png\"><br>从上表中可以看出来，内存屏障的主要作用就是通过<strong>强制读写内存来间接避免指令重排</strong>。<br><strong><em>在本质上是说是强制消费完了__tore Buffer和Invalidate Queue中的内容。</em></strong><br>所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span><span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    <span class=\"built_in\">StoreStoreBarriers</span>();</span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">LoadLoadBarriers</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-对内存屏障提供的接口\"><a href=\"#C-对内存屏障提供的接口\" class=\"headerlink\" title=\"C++对内存屏障提供的接口\"></a>C++对内存屏障提供的接口</h4><p>假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。<br>因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。<br>C++提供了六种严格度不同的内存序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">memory_order</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    memory_order_relaxed,</span><br><span class=\"line\">    memory_order_acquire,</span><br><span class=\"line\">    memory_order_release,</span><br><span class=\"line\">    memory_order_consume,</span><br><span class=\"line\">    memory_order_acq_rel,</span><br><span class=\"line\">    memory_order_seq_cst,</span><br><span class=\"line\">&#125; memory_oder;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_relaxed</strong>是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。<br>在以下代码的示例中，使用了<strong>memory_order_relaxed</strong>内存序，执行顺序有可能是0或者42</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;<span class=\"comment\">//1</span></span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);<span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_relaxed) != <span class=\"number\">0</span>)<span class=\"comment\">//3</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;<span class=\"comment\">//4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_seq_cst</strong>在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_seq_cst);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_seq_cst) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 <strong>memory_order_acquire</strong>是释放和获取序列。<br>release 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。<br>acquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。<br>使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。<br>这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。<br>在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_acquire) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 **memory_order_consume **是数据依赖序列。<br>memory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。<br>在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。</p>\n<h1 id=\"其他想说的事情\"><a href=\"#其他想说的事情\" class=\"headerlink\" title=\"其他想说的事情\"></a>其他想说的事情</h1><p>因为这个是我整合了几篇杂乱随记出来的内容，虽然经过我对主线的梳理，但还是感觉内容的破碎感很强，我写到六种内存序后戛然而止，颇有种意犹未尽之感。<br>我感觉还有很多东西可以补充在这篇博客上面，包括CPU的流水线结构，Store Buffer和Invalidate Queue机制，CPU多核心进行同步的细节等，这些我自觉是与无锁编程相关的内容之后都会逐步在这篇的基础上继续补充，希望它越来越完善。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前在聊到性能优化的时候，非常泛泛而谈得聊了一些技巧，在接下来几篇博客中，打算专门细化一下，当然也不是从头开始，算是整合之前的一些散落的随记吧。<br>这篇是关于无锁编程的原理介绍，在开篇的时候，我先阐述一下我的理解：</p>\n<blockquote>\n<p>真正的无锁编程并不存在，它只是无限地将锁的颗粒度降低。</p>\n</blockquote>\n<h1 id=\"无锁编程的背景\"><a href=\"#无锁编程的背景\" class=\"headerlink\" title=\"无锁编程的背景\"></a>无锁编程的背景</h1><h2 id=\"需要互斥锁的原因\"><a href=\"#需要互斥锁的原因\" class=\"headerlink\" title=\"需要互斥锁的原因\"></a>需要互斥锁的原因</h2><p>在传统的多线程、多进程的编程模式中，互斥锁是一种不可或缺的工具。<br>在本质上，可以归结为两种原因：</p>\n<ul>\n<li>需要安全地并发访问共享资源。</li>\n<li>需要在共享资源上控制访问顺序。</li>\n</ul>\n<p>它们都将确保代码在的某些线程不安全部分不会并发执行或者以错误的顺序执行。</p>\n<h2 id=\"互斥锁存在的问题\"><a href=\"#互斥锁存在的问题\" class=\"headerlink\" title=\"互斥锁存在的问题\"></a>互斥锁存在的问题</h2><h3 id=\"互斥锁的本质\"><a href=\"#互斥锁的本质\" class=\"headerlink\" title=\"互斥锁的本质\"></a>互斥锁的本质</h3><p>互斥锁本质上作为一个状态值，本身和一个共享资源绑定在一起，逻辑上可以简单将互斥锁理解为如下结构。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mutex_lock</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">atomic_t</span> state;</span><br><span class=\"line\">\tobject owner;</span><br><span class=\"line\">\tqueue waiting_threads;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 CPU 的其中一个核上的线程在执行到加锁逻辑时，会根据这个锁的 owner 找到其对应的状态 state 值，会根据当前状态会有两种可能：</p>\n<ol>\n<li>如果 state 是未被锁的状态，则当前 CPU 核正常执行该线程接下来的代码，同时修改 state 值为已被锁的状态，并将状态同步给其他 CPU 核；</li>\n<li>如果 state 是已被锁的状态，则当前 CPU 核不再继续往下执行该线程代码，而是将线程加入等待队列wait_threads，等待互斥锁退出后重新被调度。</li>\n</ol>\n<p>在第二种情况中，由于state 被锁，所以导致了当前CPU正在执行的线程被挂起，操作系统会给核分配其他活动着的线程的代码来执行，也就产生了“<strong>线程切换</strong>”。</p>\n<h3 id=\"互斥锁带来的开销\"><a href=\"#互斥锁带来的开销\" class=\"headerlink\" title=\"互斥锁带来的开销\"></a>互斥锁带来的开销</h3><h4 id=\"互斥锁本身的开销\"><a href=\"#互斥锁本身的开销\" class=\"headerlink\" title=\"互斥锁本身的开销\"></a>互斥锁本身的开销</h4><p>使用锁需要额外的资源，例如锁的内存空间，以及用于初始化、销毁、获取和释放锁的 CPU 资源。我们使用锁来保护对共享资源的访问的任何地方，都会有额外的开销。</p>\n<h4 id=\"线程切换的开销\"><a href=\"#线程切换的开销\" class=\"headerlink\" title=\"线程切换的开销\"></a>线程切换的开销</h4><p>一次线程切换意味着3us左右的开销（粗略数据，根据不同的CPU规格存在差异）<br><strong>直接开销：</strong></p>\n<ol>\n<li>切换页表全局目录</li>\n<li>切换内核态堆栈</li>\n<li>切换硬件上下文（寄存器内数据，包括下一条指令地址，执行中函数栈顶、栈底地址等）</li>\n<li>刷新TLB（在切换后进行页表查询时将全部击穿TLB）</li>\n</ol>\n<p><strong>间接开销：</strong><br>间接开销主要在于切换之后，各种缓存并不热，速度运行会变慢慢一些。如果始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 </p>\n<p>感兴趣的同学可以参考这篇文章：<br><a href=\"https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf\">https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf</a></p>\n<h1 id=\"无锁编程原理\"><a href=\"#无锁编程原理\" class=\"headerlink\" title=\"无锁编程原理\"></a>无锁编程原理</h1><p>继续回到上文的需要互斥锁的原因往下说，想要完全不存在锁的话，那就要从根源上保证访问共享资源时候不会冲突，这显然是无法做到的。<br>所以，身为程序开发者，只能从另外的角度来消除锁的影响。</p>\n<h2 id=\"从自旋锁说起\"><a href=\"#从自旋锁说起\" class=\"headerlink\" title=\"从自旋锁说起\"></a>从自旋锁说起</h2><p>直接针对上面问题出发，我们已经得到了互斥锁的开销来自于线程切换的结论。<br>那么如果针对线程切换的开销的话，那就用自旋锁来代替互斥锁。当发生无法抢占锁的时候，拒绝被操作系统调度，用死循环占用核资源。下面是一把非常简单粗暴的自旋锁：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">atomic&lt;<span class=\"type\">bool</span>&gt; isLock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ThreadFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> expect = flase;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!isLock.<span class=\"built_in\">compare_exchange_weak</span>(expect,<span class=\"literal\">true</span>))&#123;</span><br><span class=\"line\">    \texpect = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//do something</span></span><br><span class=\"line\">    isLock.<span class=\"built_in\">store</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这种设计存在着一些问题，比如自旋时浪费资源过多等等，但是这些先不重要。重要的是可以先探究一下它作为一把自旋锁，能保证安全的合理性在哪里。</p>\n<h2 id=\"atomic凭什么保证原子性\"><a href=\"#atomic凭什么保证原子性\" class=\"headerlink\" title=\"atomic凭什么保证原子性?\"></a>atomic凭什么保证原子性?</h2><p>上面的自旋锁的粗暴实现，有一个很基础的前提，就是 isLock.compare_exchange_weak (expect,true) 这个操作对于多线程的并发操作来说是原子的，是多线程中最小的且不可并行化的操作。C++ 11宣称atomic类型的变量保证了该对象的原子性，那么具体在操作系统层面的实现基础是什么？<br>事实上，操作系统对原子性的操作保障无能为力，原子性的保障是来自于硬件层的支持。<br>在传统的CPU中，执行一条普通的指令是需要取指、译码、执行、写回结果等许多步骤的，这些指令是可以打断，可以相互穿插的，为了多线程的编程，CPU不得不专门提供一条Test and Exchange指令，把“检测内容，等于xx则修改其值”这样必须两三条指令才能完成的操作整合进一条指令来保障这个 isLock &#x3D; xx 这个操作不被打断或者穿插。</p>\n<h2 id=\"如果多核条件下原子性还存在吗？\"><a href=\"#如果多核条件下原子性还存在吗？\" class=\"headerlink\" title=\"如果多核条件下原子性还存在吗？\"></a>如果多核条件下原子性还存在吗？</h2><p>但是现代化的CPU都不能单核那么简单的，基本上都是多CPU在并发处理指令，并发处理指令则必定会遇到缓存数据与内存数据之间可能存在不一致的情况：如果线程a和b位于两个不同的CPU核上，那么确定保障了对同一个变量写的原子性吗？</p>\n<h3 id=\"单核心CPU的写策略\"><a href=\"#单核心CPU的写策略\" class=\"headerlink\" title=\"单核心CPU的写策略\"></a>单核心CPU的写策略</h3><p>先简单回顾一下单核心CPU的两种写策略：</p>\n<ul>\n<li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li>\n<li><strong>写回</strong>：为了避免每次写操作都要进行数据同步带来的性能损失，写回策略里发生读写操作时：<ul>\n<li>如果缓存行中命中了数据，写操作对缓存行中数据进行更新，并标记该缓存行为已修改。</li>\n<li>如果缓存中未命中数据，且数据所对应的缓存行中存放了其他数据：<ul>\n<li><strong>若该缓存行被标记为已修改</strong>，读写操作都会将缓存行中现存的数据<strong>写回</strong>内存中，再将当前要获取的数据从内存读到缓存行，写操作对数据进行更新后标记该缓存行为已修改；</li>\n<li><strong>若该缓存行未被标记为已修改</strong>，读写操作都直接将当前要获取的数据从内存读到缓存行。写操作对数据进行更新后标记该缓存行为已修改。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"多核心CPU的写策略\"><a href=\"#多核心CPU的写策略\" class=\"headerlink\" title=\"多核心CPU的写策略\"></a>多核心CPU的写策略</h3><p>早年的多核CPU是通过锁总线来保障缓存的一致性的，这显然是不太合理的，其他CPU都只能进行等待，过于宽泛的颗粒度导致这个锁效率低下。之后逐渐进化成了写传播模式。</p>\n<ul>\n<li><strong>写传播：</strong>CPU进行缓存数据更新时需要告知其他CPU</li>\n</ul>\n<p>如果出现了多个CPU对同一个数据操作的告知，则要求CPU对同一数据的修改应当保证事务<strong>串行化</strong>，否则会出现问题。<br>举个例子：CPU1、CPU2同时修改了数据A，CPU1把修改数据广播给CPU2、CPU3、CPU4，CPU2将修改数据广播给了CPU1、CPU3、CPU4，如果CPU3先接收到了CPU1的修改后接收到了CPU2的修改，而CPU4的接收顺序与3相反，此时3、4中A数据的值就可能不一致了，CPU1、CPU2互相接收对方的修改数据也会导致数据不一致的情况。<br>CPU的写传播是通过总线进行传播的，单纯的总线传播是无法保障事务的串行化的，需要依赖于缓存一致性协议（MESI）。<br>MESI首先规定了缓存的四种状态：</p>\n<ul>\n<li>_Modified_，已修改</li>\n<li>_Exclusive_，独占</li>\n<li>_Shared_，共享</li>\n<li>_Invalidated_，已失效</li>\n</ul>\n<p><img src=\"/images/preformance-optimize-overview/2.png\" alt=\"image.png\"></p>\n<h3 id=\"一些其他的引申\"><a href=\"#一些其他的引申\" class=\"headerlink\" title=\"一些其他的引申\"></a>一些其他的引申</h3><p>缓存一致性协议确实可以保障多核CPU缓存一致性，但是由于需要广播所以过于低效，所以实际CPU并不会遵守这个协议，为了提高性能CPU实际上存在着 Store Buffer和Invalidate Queue这两个机制，暂时只对这边做一个简单介绍，留待之后进行详细展开。</p>\n<h4 id=\"Store-Buffer\"><a href=\"#Store-Buffer\" class=\"headerlink\" title=\"Store Buffer\"></a>Store Buffer</h4><p>CPU进行写传播的时候，为了实现异步性而引入的一个写缓冲区。</p>\n<h4 id=\"Invalidate-Queue\"><a href=\"#Invalidate-Queue\" class=\"headerlink\" title=\"Invalidate Queue\"></a>Invalidate Queue</h4><p>对于Store Buffer中异步发送的指令，Invalidate Queue用队列的结构对指令得到的响应进行接收，并且根据先入先出的顺序进行消费。</p>\n<h2 id=\"是否可能存在指令乱序的问题？\"><a href=\"#是否可能存在指令乱序的问题？\" class=\"headerlink\" title=\"是否可能存在指令乱序的问题？\"></a>是否可能存在指令乱序的问题？</h2><h3 id=\"跨线程的无依赖指令可能存在乱序\"><a href=\"#跨线程的无依赖指令可能存在乱序\" class=\"headerlink\" title=\"跨线程的无依赖指令可能存在乱序\"></a>跨线程的无依赖指令可能存在乱序</h3><p>到目前为止，我们已经从捋清楚了在多核CPU的情况下，对某个atomic变量进行修改操作是原子性的这一事件的声明。接下来我们需要面对另外一个问题：指令乱序。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;  <span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于指令重排的存在可能导致1、3、4、5、2的执行顺序的出现。这将超出我们对共享资源上访问顺序的控制。</p>\n<h3 id=\"指令重排的本质原因\"><a href=\"#指令重排的本质原因\" class=\"headerlink\" title=\"指令重排的本质原因\"></a>指令重排的本质原因</h3><p>指令重排的有两个层次的原因，一个是编译器对无依赖性的语句进行优化，一个是CPU的指令执行时候在流水线上的并发结构。</p>\n<h3 id=\"通过内存屏障解决指令乱序问题\"><a href=\"#通过内存屏障解决指令乱序问题\" class=\"headerlink\" title=\"通过内存屏障解决指令乱序问题\"></a>通过内存屏障解决指令乱序问题</h3><h4 id=\"内存屏障概念\"><a href=\"#内存屏障概念\" class=\"headerlink\" title=\"内存屏障概念\"></a>内存屏障概念</h4><p>内存屏障就是将内存&#x2F;缓存的读写操作过程进行分隔。<br>缓存和内存之间的操作分为 Store 和 Load 两种。</p>\n<ul>\n<li>Store：将处理器缓存的数据刷新到内存中。</li>\n<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>\n</ul>\n<p><img src=\"/images/preformance-optimize-overview/3.png\" alt=\"image.png\"><br>从上表中可以看出来，内存屏障的主要作用就是通过<strong>强制读写内存来间接避免指令重排</strong>。<br><strong><em>在本质上是说是强制消费完了__tore Buffer和Invalidate Queue中的内容。</em></strong><br>所以，在之前那个程序中进行如下更改就可以避免指令重排，强制保障执行顺序为12345：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//共享变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> a, b, c = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span><span class=\"comment\">//1</span></span><br><span class=\"line\">    b = a;  <span class=\"comment\">//2</span></span><br><span class=\"line\">    <span class=\"built_in\">StoreStoreBarriers</span>();</span><br><span class=\"line\">    c = <span class=\"number\">1</span>;  <span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">//4 </span></span><br><span class=\"line\">    <span class=\"built_in\">LoadLoadBarriers</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(b == <span class=\"number\">1</span>); <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"C-对内存屏障提供的接口\"><a href=\"#C-对内存屏障提供的接口\" class=\"headerlink\" title=\"C++对内存屏障提供的接口\"></a>C++对内存屏障提供的接口</h4><p>假设在编程过程中存在大量原子读写操作，如果全部操作都不允许指令重排，也就是严格保证顺序一致性，虽然运行结果很容易符合开发者编程预期，降低了开发难度，但是这样会很大程度影响 CPU 执行性能。<br>因此C++ 通过引入内存序接口，提供了控制 CPU 缓存同步的能力给开发者，让内存读写的顺序更加灵活可控。C++ 的内存序允许按照批次保证内存读写顺序，而不必对每一个读写操作保证，也就是说批次和批次之间保持顺序一致性，批次内部保持松散顺序就行。<br>C++提供了六种严格度不同的内存序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">memory_order</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    memory_order_relaxed,</span><br><span class=\"line\">    memory_order_acquire,</span><br><span class=\"line\">    memory_order_release,</span><br><span class=\"line\">    memory_order_consume,</span><br><span class=\"line\">    memory_order_acq_rel,</span><br><span class=\"line\">    memory_order_seq_cst,</span><br><span class=\"line\">&#125; memory_oder;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_relaxed</strong>是最松散的内存序，使用这种内存序的多个内存操作之间同一个线程里还是按照happens-before（happens-before 指的是内存模型中两项操作的顺序关系。例如说操作 A 先于操作 B，也就是说操作 A 发生在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。这里的「影响」包括：内存中共享变量的值、发送了消息、调用了方法等）的关系执行，但是不同线程之间的执行关系是任意的。<br>在以下代码的示例中，使用了<strong>memory_order_relaxed</strong>内存序，执行顺序有可能是0或者42</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;<span class=\"comment\">//1</span></span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);<span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_relaxed) != <span class=\"number\">0</span>)<span class=\"comment\">//3</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;<span class=\"comment\">//4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_seq_cst</strong>在底层同时使用了 StoreStore 屏障和 LoadLoad 屏障来实现，因此保证了内存读写顺序和指令顺序一是致的。这种内存序要严格控制每一次内存读写的顺序，所以执行效率是所有内程序里最低的。顺序一致性序列是完全保证内存读写顺序和指令顺序一致的，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_seq_cst);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_seq_cst) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 <strong>memory_order_acquire</strong>是释放和获取序列。<br>release 底层使用了 StoreStore 屏障，保证在此内存操作之前的所有 Store 操作都不可能重排到此操作之后；也可以理解为这个操作使 CPU 将所有缓存写入了内存，使其他缓存可见。<br>acquire 底层使用了 LoadLoad 屏障，保存在此内存操作之后的所有 Load 操作都不可能重排到此操作之前；也可以理解为这个操作使 CPU 将所有抛弃了所有缓存，重新从内存读取数据。<br>使用这种内存序，保证了 std::memory_order_release 之前的 Store 操作按一个批次同步到其他缓存，同时 std::memory_order_acquire 之后的 Load 操作按一个批次从内存加载数据到缓存，保证了局部的一致性。<br>这种内存序因为是按批次来同步缓存的，所以性能优于顺序一致性序列，但是又没有松散序列高效。<br>在下面代码中，就是保证写线程写完之后，读线程才开始读的局部一致性，所以最终的 p 值为 42。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">guard</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> payload = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程1运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    payload = <span class=\"number\">42</span>;</span><br><span class=\"line\">    guard.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线程2运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">thread2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guard.<span class=\"built_in\">load</span>(std::memory_order_acquire) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = payload;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>memory_order_release</strong> 和 **memory_order_consume **是数据依赖序列。<br>memory_order_consume 的底层实现并不使用内存屏障，而是分析数据依赖来保证数据依赖链上的指令的顺序一致性。<br>在从内存加载数据到缓存的时候，根据数据依赖链的顺序去加载。写入内存还是使用 memory_order_release 的策略不变。这种内存序在多平台方面，支持不是很好，有一些硬件设备并不支持这种内存序列，因此它会被退化成获取-释放序列。</p>\n<h1 id=\"其他想说的事情\"><a href=\"#其他想说的事情\" class=\"headerlink\" title=\"其他想说的事情\"></a>其他想说的事情</h1><p>因为这个是我整合了几篇杂乱随记出来的内容，虽然经过我对主线的梳理，但还是感觉内容的破碎感很强，我写到六种内存序后戛然而止，颇有种意犹未尽之感。<br>我感觉还有很多东西可以补充在这篇博客上面，包括CPU的流水线结构，Store Buffer和Invalidate Queue机制，CPU多核心进行同步的细节等，这些我自觉是与无锁编程相关的内容之后都会逐步在这篇的基础上继续补充，希望它越来越完善。</p>\n"},{"title":"性能优化（四）：缓存命中","date":"2024-02-13T16:46:45.000Z","_content":"这一篇主要介绍了缓存友好编程的一些基本原则和使用中需要注意的点。\n# 局部性原理\n在编程过程中，局部性原理的存在是缓存友好编程这一概念存在的基础。局部性原理一般可分为时间局部性和空间局部性。\n时间局部性指的是被引用过一次的内存位置很可能在不远的将来再被多次引用。空间局部性指的是如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。\n在我们编程中，大量的数据结构存在顺序引用模式，如数组，列表等，这些顺序的数据结构就是空间局部性的主要来源。如果存在循环语句的话，就会对同一指令进行多次执行，这是时间局部性的主要来源。\n# 缓存行结构\n继续说空间局部性，为什么会出现空间局部性，是因为处理器存在缓存行的概念。\n缓存行是处理器一次缓存读写操作的最小长度单位。当我们的CPU试图访问一个int类型（4字节）的内存地址时，包含该地址的整个缓存行（32字节）将被加载进我们的Cache。也就是说，一次缓存行的读取相对于我们一个变量的读取，完全是有空间冗余的操作。如果我们在接下来试图访问连续的下一个int值时，可以跳过将缓存行从内存中加载到缓存中中的这个步骤，直接命中缓存。\n这一部分的开销的节省是否有必要，可以从下表发现，从寄存器到主存的逐级cache，访问速度是指数级变化的，极端情况下直接在L1命中缓存和到内存中寻址，相差100倍的时钟周期。\n![image.png](images/preformance-optimize-overview/4.png)\n\n# 缓存命中的问题\n## 代码示例\n在冷缓存，32位机器，32字节缓存行大小的机器下，如下两种代码的便利方式有着大相径庭的缓存命中率。\n```cpp\n//缓存命中率7/8\nint sumarrayrows(int a[M][N])\n{\n\tint i, j, sum = 0;\n\tfor (i = 0; i < M; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tsum += a[i][j];\n\treturn sum;\n}\n\n//缓存命中率0\nint sumarraycols(int a[M][N])\n{\n\tint i, j, sum = 0;\n\tfor (j = 0; j < N; j++)\n\t\tfor (i = 0; i < M; i++)\n\t\t\tsum += a[i][j];\n\treturn sum;\n}\n```\n## 编程原则\n\n- 保持尽可能小的工作集（时间局部性）\n- 使用小步幅连续寻址（空间局部性）\n## 缓存优化技巧\n\n- 当获取线性数据时，尽量使用vector和array\n- 经常访问的数据，在内存中应当是相邻的\n- 使用数据数组替换指针数组\n- 类的大小需要是cache line大小的倍数：手动的填充使其满足cache line 或者告诉编译器自动帮我们填充\n- 有效地访问你的矩阵中的数据\n# 反直觉的False Sharing\n在之前提到的内容中，把数据尽可能地连续放入缓存行，似乎是一种非常高效的便于访问的方法。\n但是事实上，如果不合理地使用缓存，将会出现反直觉地false sharing的问题。\n## false sharing的成因\n![image.png](images/preformance-optimize-overview/5.png)\n如图所示，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送Request For Owner消息（写请求之前的独占声明），占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。\n表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。\n## false sharing的解法\n一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。\n具体方法就是缓存行填充（Padding） 。我们使得可能产生写冲突的对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。\n\n","source":"_posts/Preformance-optimize-4.md","raw":"---\ntitle: 性能优化（四）：缓存命中\ndate: 2024-02-14 00:46:45\ntags: 性能优化\n---\n这一篇主要介绍了缓存友好编程的一些基本原则和使用中需要注意的点。\n# 局部性原理\n在编程过程中，局部性原理的存在是缓存友好编程这一概念存在的基础。局部性原理一般可分为时间局部性和空间局部性。\n时间局部性指的是被引用过一次的内存位置很可能在不远的将来再被多次引用。空间局部性指的是如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。\n在我们编程中，大量的数据结构存在顺序引用模式，如数组，列表等，这些顺序的数据结构就是空间局部性的主要来源。如果存在循环语句的话，就会对同一指令进行多次执行，这是时间局部性的主要来源。\n# 缓存行结构\n继续说空间局部性，为什么会出现空间局部性，是因为处理器存在缓存行的概念。\n缓存行是处理器一次缓存读写操作的最小长度单位。当我们的CPU试图访问一个int类型（4字节）的内存地址时，包含该地址的整个缓存行（32字节）将被加载进我们的Cache。也就是说，一次缓存行的读取相对于我们一个变量的读取，完全是有空间冗余的操作。如果我们在接下来试图访问连续的下一个int值时，可以跳过将缓存行从内存中加载到缓存中中的这个步骤，直接命中缓存。\n这一部分的开销的节省是否有必要，可以从下表发现，从寄存器到主存的逐级cache，访问速度是指数级变化的，极端情况下直接在L1命中缓存和到内存中寻址，相差100倍的时钟周期。\n![image.png](images/preformance-optimize-overview/4.png)\n\n# 缓存命中的问题\n## 代码示例\n在冷缓存，32位机器，32字节缓存行大小的机器下，如下两种代码的便利方式有着大相径庭的缓存命中率。\n```cpp\n//缓存命中率7/8\nint sumarrayrows(int a[M][N])\n{\n\tint i, j, sum = 0;\n\tfor (i = 0; i < M; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tsum += a[i][j];\n\treturn sum;\n}\n\n//缓存命中率0\nint sumarraycols(int a[M][N])\n{\n\tint i, j, sum = 0;\n\tfor (j = 0; j < N; j++)\n\t\tfor (i = 0; i < M; i++)\n\t\t\tsum += a[i][j];\n\treturn sum;\n}\n```\n## 编程原则\n\n- 保持尽可能小的工作集（时间局部性）\n- 使用小步幅连续寻址（空间局部性）\n## 缓存优化技巧\n\n- 当获取线性数据时，尽量使用vector和array\n- 经常访问的数据，在内存中应当是相邻的\n- 使用数据数组替换指针数组\n- 类的大小需要是cache line大小的倍数：手动的填充使其满足cache line 或者告诉编译器自动帮我们填充\n- 有效地访问你的矩阵中的数据\n# 反直觉的False Sharing\n在之前提到的内容中，把数据尽可能地连续放入缓存行，似乎是一种非常高效的便于访问的方法。\n但是事实上，如果不合理地使用缓存，将会出现反直觉地false sharing的问题。\n## false sharing的成因\n![image.png](images/preformance-optimize-overview/5.png)\n如图所示，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送Request For Owner消息（写请求之前的独占声明），占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。\n表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。\n## false sharing的解法\n一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。\n具体方法就是缓存行填充（Padding） 。我们使得可能产生写冲突的对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。\n\n","slug":"Preformance-optimize-4","published":1,"updated":"2024-02-13T16:56:51.463Z","_id":"clsklndue0000apx54qov5yh9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这一篇主要介绍了缓存友好编程的一些基本原则和使用中需要注意的点。</p>\n<h1 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h1><p>在编程过程中，局部性原理的存在是缓存友好编程这一概念存在的基础。局部性原理一般可分为时间局部性和空间局部性。<br>时间局部性指的是被引用过一次的内存位置很可能在不远的将来再被多次引用。空间局部性指的是如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。<br>在我们编程中，大量的数据结构存在顺序引用模式，如数组，列表等，这些顺序的数据结构就是空间局部性的主要来源。如果存在循环语句的话，就会对同一指令进行多次执行，这是时间局部性的主要来源。</p>\n<h1 id=\"缓存行结构\"><a href=\"#缓存行结构\" class=\"headerlink\" title=\"缓存行结构\"></a>缓存行结构</h1><p>继续说空间局部性，为什么会出现空间局部性，是因为处理器存在缓存行的概念。<br>缓存行是处理器一次缓存读写操作的最小长度单位。当我们的CPU试图访问一个int类型（4字节）的内存地址时，包含该地址的整个缓存行（32字节）将被加载进我们的Cache。也就是说，一次缓存行的读取相对于我们一个变量的读取，完全是有空间冗余的操作。如果我们在接下来试图访问连续的下一个int值时，可以跳过将缓存行从内存中加载到缓存中中的这个步骤，直接命中缓存。<br>这一部分的开销的节省是否有必要，可以从下表发现，从寄存器到主存的逐级cache，访问速度是指数级变化的，极端情况下直接在L1命中缓存和到内存中寻址，相差100倍的时钟周期。<br><img src=\"/images/preformance-optimize-overview/4.png\" alt=\"image.png\"></p>\n<h1 id=\"缓存命中的问题\"><a href=\"#缓存命中的问题\" class=\"headerlink\" title=\"缓存命中的问题\"></a>缓存命中的问题</h1><h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><p>在冷缓存，32位机器，32字节缓存行大小的机器下，如下两种代码的便利方式有着大相径庭的缓存命中率。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缓存命中率7/8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumarrayrows</span><span class=\"params\">(<span class=\"type\">int</span> a[M][N])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; M; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; N; j++)</span><br><span class=\"line\">\t\t\tsum += a[i][j];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存命中率0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumarraycols</span><span class=\"params\">(<span class=\"type\">int</span> a[M][N])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; N; j++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; M; i++)</span><br><span class=\"line\">\t\t\tsum += a[i][j];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编程原则\"><a href=\"#编程原则\" class=\"headerlink\" title=\"编程原则\"></a>编程原则</h2><ul>\n<li>保持尽可能小的工作集（时间局部性）</li>\n<li>使用小步幅连续寻址（空间局部性）</li>\n</ul>\n<h2 id=\"缓存优化技巧\"><a href=\"#缓存优化技巧\" class=\"headerlink\" title=\"缓存优化技巧\"></a>缓存优化技巧</h2><ul>\n<li>当获取线性数据时，尽量使用vector和array</li>\n<li>经常访问的数据，在内存中应当是相邻的</li>\n<li>使用数据数组替换指针数组</li>\n<li>类的大小需要是cache line大小的倍数：手动的填充使其满足cache line 或者告诉编译器自动帮我们填充</li>\n<li>有效地访问你的矩阵中的数据</li>\n</ul>\n<h1 id=\"反直觉的False-Sharing\"><a href=\"#反直觉的False-Sharing\" class=\"headerlink\" title=\"反直觉的False Sharing\"></a>反直觉的False Sharing</h1><p>在之前提到的内容中，把数据尽可能地连续放入缓存行，似乎是一种非常高效的便于访问的方法。<br>但是事实上，如果不合理地使用缓存，将会出现反直觉地false sharing的问题。</p>\n<h2 id=\"false-sharing的成因\"><a href=\"#false-sharing的成因\" class=\"headerlink\" title=\"false sharing的成因\"></a>false sharing的成因</h2><p><img src=\"/images/preformance-optimize-overview/5.png\" alt=\"image.png\"><br>如图所示，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送Request For Owner消息（写请求之前的独占声明），占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。<br>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>\n<h2 id=\"false-sharing的解法\"><a href=\"#false-sharing的解法\" class=\"headerlink\" title=\"false sharing的解法\"></a>false sharing的解法</h2><p>一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。<br>具体方法就是缓存行填充（Padding） 。我们使得可能产生写冲突的对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这一篇主要介绍了缓存友好编程的一些基本原则和使用中需要注意的点。</p>\n<h1 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h1><p>在编程过程中，局部性原理的存在是缓存友好编程这一概念存在的基础。局部性原理一般可分为时间局部性和空间局部性。<br>时间局部性指的是被引用过一次的内存位置很可能在不远的将来再被多次引用。空间局部性指的是如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。<br>在我们编程中，大量的数据结构存在顺序引用模式，如数组，列表等，这些顺序的数据结构就是空间局部性的主要来源。如果存在循环语句的话，就会对同一指令进行多次执行，这是时间局部性的主要来源。</p>\n<h1 id=\"缓存行结构\"><a href=\"#缓存行结构\" class=\"headerlink\" title=\"缓存行结构\"></a>缓存行结构</h1><p>继续说空间局部性，为什么会出现空间局部性，是因为处理器存在缓存行的概念。<br>缓存行是处理器一次缓存读写操作的最小长度单位。当我们的CPU试图访问一个int类型（4字节）的内存地址时，包含该地址的整个缓存行（32字节）将被加载进我们的Cache。也就是说，一次缓存行的读取相对于我们一个变量的读取，完全是有空间冗余的操作。如果我们在接下来试图访问连续的下一个int值时，可以跳过将缓存行从内存中加载到缓存中中的这个步骤，直接命中缓存。<br>这一部分的开销的节省是否有必要，可以从下表发现，从寄存器到主存的逐级cache，访问速度是指数级变化的，极端情况下直接在L1命中缓存和到内存中寻址，相差100倍的时钟周期。<br><img src=\"/images/preformance-optimize-overview/4.png\" alt=\"image.png\"></p>\n<h1 id=\"缓存命中的问题\"><a href=\"#缓存命中的问题\" class=\"headerlink\" title=\"缓存命中的问题\"></a>缓存命中的问题</h1><h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><p>在冷缓存，32位机器，32字节缓存行大小的机器下，如下两种代码的便利方式有着大相径庭的缓存命中率。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缓存命中率7/8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumarrayrows</span><span class=\"params\">(<span class=\"type\">int</span> a[M][N])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; M; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; N; j++)</span><br><span class=\"line\">\t\t\tsum += a[i][j];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存命中率0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumarraycols</span><span class=\"params\">(<span class=\"type\">int</span> a[M][N])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; N; j++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; M; i++)</span><br><span class=\"line\">\t\t\tsum += a[i][j];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编程原则\"><a href=\"#编程原则\" class=\"headerlink\" title=\"编程原则\"></a>编程原则</h2><ul>\n<li>保持尽可能小的工作集（时间局部性）</li>\n<li>使用小步幅连续寻址（空间局部性）</li>\n</ul>\n<h2 id=\"缓存优化技巧\"><a href=\"#缓存优化技巧\" class=\"headerlink\" title=\"缓存优化技巧\"></a>缓存优化技巧</h2><ul>\n<li>当获取线性数据时，尽量使用vector和array</li>\n<li>经常访问的数据，在内存中应当是相邻的</li>\n<li>使用数据数组替换指针数组</li>\n<li>类的大小需要是cache line大小的倍数：手动的填充使其满足cache line 或者告诉编译器自动帮我们填充</li>\n<li>有效地访问你的矩阵中的数据</li>\n</ul>\n<h1 id=\"反直觉的False-Sharing\"><a href=\"#反直觉的False-Sharing\" class=\"headerlink\" title=\"反直觉的False Sharing\"></a>反直觉的False Sharing</h1><p>在之前提到的内容中，把数据尽可能地连续放入缓存行，似乎是一种非常高效的便于访问的方法。<br>但是事实上，如果不合理地使用缓存，将会出现反直觉地false sharing的问题。</p>\n<h2 id=\"false-sharing的成因\"><a href=\"#false-sharing的成因\" class=\"headerlink\" title=\"false sharing的成因\"></a>false sharing的成因</h2><p><img src=\"/images/preformance-optimize-overview/5.png\" alt=\"image.png\"><br>如图所示，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送Request For Owner消息（写请求之前的独占声明），占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。<br>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>\n<h2 id=\"false-sharing的解法\"><a href=\"#false-sharing的解法\" class=\"headerlink\" title=\"false sharing的解法\"></a>false sharing的解法</h2><p>一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。<br>具体方法就是缓存行填充（Padding） 。我们使得可能产生写冲突的对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cls482gg500006lx5024naovq","tag_id":"cls482gga00016lx5c2r4g1oa","_id":"cls482ggd00026lx5g45b54my"},{"post_id":"cls48hpdw0000ecx576pb11hl","tag_id":"cls482gga00016lx5c2r4g1oa","_id":"cls48hpe30001ecx58yuk7frs"},{"post_id":"cls4a5r4h0000pjx585w7f6ng","tag_id":"cls4a5r4o0002pjx5b5bbhnnj","_id":"cls4a5r4s0004pjx5gzer5dsf"},{"post_id":"cls4a5r4m0001pjx5g5thd3g9","tag_id":"cls4a5r4o0002pjx5b5bbhnnj","_id":"cls4a5r4t0005pjx5d2znhkar"},{"post_id":"clrhz6rwf00010ox533q1ciw5","tag_id":"cls4a9oa20000clx59j5v5qhg","_id":"cls4a9oa50001clx527pfcbkv"},{"post_id":"cls8hy75u0000czx5b01l49t8","tag_id":"cls49d61400016lx5329xb3nk","_id":"cls8hy75z0001czx5coqz2y4m"},{"post_id":"cls8ihuyg0000icx5gxv6hdkd","tag_id":"cls8ihuyn0001icx5bwk3deat","_id":"cls8ihuyq0002icx5213hain0"},{"post_id":"cls8itme40000i2x55kln7r1i","tag_id":"cls49d61400016lx5329xb3nk","_id":"cls8itmeg0001i2x50fmrfmyf"},{"post_id":"cls8jg44f0000pxx5c6qtaeda","tag_id":"cls8jg44l0002pxx56cw33hym","_id":"cls8jg44s0004pxx56olz47qk"},{"post_id":"cls8jg44j0001pxx5gg823l2o","tag_id":"cls8jg44l0002pxx56cw33hym","_id":"cls8jg44s0005pxx5h29v6nzh"},{"post_id":"cls8l6zba0000xqx5gbvb5dgi","tag_id":"cls49d61400016lx5329xb3nk","_id":"cls8l6zbm0001xqx5aja992wb"},{"post_id":"cls01gnk000001ax57sxn64hc","tag_id":"cls49d61400016lx5329xb3nk","_id":"cls9po6xe0000ffx54wzhejpo"},{"post_id":"clsdhsxsw0000aox5hi21hy3d","tag_id":"clsdhsxt20001aox5czile6mw","_id":"clsdhsxuf0002aox5hnpwh95k"},{"post_id":"clsdhw2xz0000jrx5fr979q3f","tag_id":"clsdhsxt20001aox5czile6mw","_id":"clsdhw2y40001jrx524v1dgvd"},{"post_id":"clsixc4fq000027x56w108spz","tag_id":"clsdhsxt20001aox5czile6mw","_id":"clsixc4fv000127x535mogzgg"},{"post_id":"clsj9yi2k000060x59c25ar4g","tag_id":"clsdhsxt20001aox5czile6mw","_id":"clsj9yi2n000160x5cwf79pcx"},{"post_id":"cls34916b0000ynx57dh67tl8","tag_id":"cls49d61400016lx5329xb3nk","_id":"clsk1aox60000azx5cf1yhybh"},{"post_id":"cls3f5xxq0000r4x54i19cger","tag_id":"cls49d61400016lx5329xb3nk","_id":"clsk1aox90001azx5bmj3e1y0"},{"post_id":"clskkngde00005fx5gubog2bh","tag_id":"cls8jg44l0002pxx56cw33hym","_id":"clskkngdj00015fx57naoh3s4"},{"post_id":"clsklndue0000apx54qov5yh9","tag_id":"cls8jg44l0002pxx56cw33hym","_id":"clsklndul0001apx5d0ijgkto"}],"Tag":[{"name":"design pattern","_id":"clrhz6rwk00030ox5fj28fcof"},{"name":"Cpp","_id":"clrhz6rwp00070ox59wtr7non"},{"name":"Gpt","_id":"clrhz6rx3000o0ox53fm0aedb"},{"name":"Plan","_id":"clrhz6rx4000r0ox56u9g5wdy"},{"name":"学习杂记","_id":"cls34916n0001ynx5fvzbhfmb"},{"name":"工具集合","_id":"cls482gga00016lx5c2r4g1oa"},{"name":"随感杂记","_id":"cls49d61400016lx5329xb3nk"},{"name":"共享内存","_id":"cls4a5r4o0002pjx5b5bbhnnj"},{"name":"设计模式","_id":"cls4a9oa20000clx59j5v5qhg"},{"name":"学习笔记","_id":"cls8ihuyn0001icx5bwk3deat"},{"name":"性能优化","_id":"cls8jg44l0002pxx56cw33hym"},{"name":"模板编程","_id":"clsdhsxt20001aox5czile6mw"}]}}