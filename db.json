{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1701323793515},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701324224526},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1701324224526},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1701324224526},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1701324224526},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1701324224526},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1701324224526},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1701324224526},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1701324224526},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1701324224526},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1701324224526},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1701324224526},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1701324224526},{"_id":"themes/archer/_config.yml","hash":"874750cd5a75a69543e7658316ea1f6092f5f852","modified":1701532326684},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1701324224526},{"_id":"themes/archer/package.json","hash":"81af75826e854ac80f6337dc4f1ce4b51f066b0b","modified":1701324224530},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1701324224562},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1701324224562},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1701324224562},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1701324224526},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1701324224526},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1701324224526},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1701324224526},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1701324224526},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1701324224526},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1701324224526},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1701324224526},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1701324224526},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1701324224526},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1701324224526},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1701324224526},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1701324224526},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1701324224526},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1701324224526},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1701324224526},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"d8f4236166d058421c2e4ff00660be75a3494704","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"687c08823e7ce43e6ebb44f2fb4b75549abfed29","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1701324224526},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1701324224526},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1701324224526},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1701324224526},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1701324224530},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1701324224530},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1701324224530},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1701324224530},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1701324224530},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1701331873778},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1701324224530},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1701324224530},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1701324224530},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1701324224534},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1701324224534},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1701324224534},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1701324224534},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1701324224538},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1701324224538},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1701324224538},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1701324224538},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1701324224538},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1701324224546},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1701324224554},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1701324224562},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1701324224562},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1701324224562},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1701324224562},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1701324224562},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1701324224562},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1701324224562},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1701324224562},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1701324224562},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1701324224562},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1701324224562},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1701324224562},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1701324224562},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1701324224562},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1701324224562},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1701324224562},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1701324224562},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1701324224562},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1701324224562},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1701324224562},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1701324224562},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1701324224562},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1701324224562},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1701324224562},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1701324224526},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1701324224526},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1701324224526},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1701324224526},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1701324224526},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1701324224526},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1701324224562},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1701324224562},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1701324224562},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1701324224562},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1701324224562},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1701324224562},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1701324224534},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1701324224534},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1701324224534},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1701324224534},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1701324224534},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1701324224538},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1701324224534},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1701324224538},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1701324224554},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1701324224562},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1701324224526},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1701324224538},{"_id":"themes/archer/package-lock.json","hash":"400ab1cc2a2f1380a5e9ab69abe3a5b93f923d8d","modified":1701324224530},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1701324224558},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1701324224546},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1701324224554},{"_id":"public/2023/11/30/hello-world/index.html","hash":"4667deaed6d0ddfb9717647c7577ee9f6e346105","modified":1701423407982},{"_id":"public/archives/index.html","hash":"17fc39f8fcebea3e38e08a9c78d7c4cceb5fec84","modified":1701614853270},{"_id":"public/archives/2023/index.html","hash":"2e091126ccfcd46ca89d0469cc3801a31f70aedd","modified":1701614853270},{"_id":"public/archives/2023/11/index.html","hash":"81ec6255bbd22d58e07ece92952735d2578a12a5","modified":1701423407982},{"_id":"public/index.html","hash":"3b68279582e3fe4199ce6f84fe44b471f687482d","modified":1701614853270},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1701328044199},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1701328044199},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1701328044199},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1701328044199},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1701328044199},{"_id":"public/avatar/Misaka.jpg","hash":"15d2a495703b4eb7f6673cb4a06b7f5731bee406","modified":1701331894451},{"_id":"public/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1701328044199},{"_id":"public/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1701328044199},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1701328044199},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1701328044199},{"_id":"public/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1701328044199},{"_id":"public/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1701328044199},{"_id":"public/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1701328044199},{"_id":"public/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1701328044199},{"_id":"public/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1701328044199},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1701328044199},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1701328044199},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1701328044199},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1701328044199},{"_id":"public/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1701328044199},{"_id":"public/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1701328044199},{"_id":"public/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1701328044199},{"_id":"public/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1701328044199},{"_id":"public/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1701328044199},{"_id":"public/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1701328044199},{"_id":"public/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1701328044199},{"_id":"public/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1701328044199},{"_id":"public/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1701328044199},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1701328044199},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1701328044199},{"_id":"public/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1701328044199},{"_id":"public/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1701328044199},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1701328044199},{"_id":"public/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1701328044199},{"_id":"public/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1701328044199},{"_id":"public/content.json","hash":"5dca7c5d53c25f38be4bdd15252727deee3934db","modified":1701614853270},{"_id":"source/_posts/C++的无锁编程.md","hash":"1170f243e2d60acb4176a5be764fb0a116b9299e","modified":1701332409838},{"_id":"source/_posts/test-article.md","hash":"d5c9d9b3ea1e4f09230feb341d389d88194d3757","modified":1701354748868},{"_id":"public/2023/11/30/C++的无锁编程/index.html","hash":"5294c5f320a51278b443eb4a273544b112076186","modified":1701332483038},{"_id":"public/2023/11/30/test-article/index.html","hash":"1b625c23fc222fffdcafcaa57d28869e2e35d4c9","modified":1701423407982},{"_id":"source/about/index.md","hash":"80ca524618bebf8ec5a572a1184ed8b2874d4b8d","modified":1701460805533},{"_id":"public/about/index.html","hash":"2b99e3170493ca742f6f6e7c813de4953e837a9f","modified":1701613242288},{"_id":"source/_posts/some-plans.md","hash":"c16282b0a564daefaa6c09f1dc2144370287d664","modified":1701459323498},{"_id":"public/2023/12/02/some-plans/index.html","hash":"00aaa9581bebf29cba9c93e3c7a14c2cb3ecacbf","modified":1701614853270},{"_id":"public/archives/2023/12/index.html","hash":"5de5d67a6007ba2549c3fdab7d0f742497de9ddd","modified":1701614853270},{"_id":"public/tags/Plan/index.html","hash":"c7e6e42c221a7502a6f13f77c78067873704b350","modified":1701614853270},{"_id":"source/_posts/Cpp-basics-1.md","hash":"533d4fef7c28e02fcb8dc5f47ad02e2d389542c8","modified":1701614117874},{"_id":"source/_posts/Cpp-basics-2.md","hash":"952bcd0fbfde035273c9b5d1d9bae6ea0ffa5d33","modified":1701612804538},{"_id":"source/_posts/Cpp-basics-3.md","hash":"cf4dc83887f5f9b268e07cffbf58c8995c9cdbb5","modified":1701612810998},{"_id":"source/_posts/Cpp-basics-4.md","hash":"54e708ac52c059cdbc4c2af295d584065a6f44dd","modified":1701612815154},{"_id":"public/2023/12/03/Cpp-basics-4/index.html","hash":"cbf661fb27a912512b738a25633b8df0fc869592","modified":1701613242288},{"_id":"public/2023/12/03/Cpp-basics-3/index.html","hash":"b15d2cc28fe8eb9e4c46ce6d4ffd0a7cbbd6b3a9","modified":1701613242288},{"_id":"public/2023/12/03/Cpp-basics-2/index.html","hash":"f23c5f1273c01e0453c645018ca20dde47f0dc80","modified":1701613242288},{"_id":"public/2023/12/03/Cpp-basics-1/index.html","hash":"fd3c0612383030d44b5888d5729ec883d38418df","modified":1701614853270},{"_id":"public/tags/Cpp/index.html","hash":"8672e276bfb53124df48971f311ffdee5dd919ea","modified":1701614853270}],"Category":[],"Data":[],"Page":[{"title":"About Me","layout":"about","date":"2023-12-01T08:44:29.000Z","_content":"\n## 教育背景\n**西安交通大学** Bachelor\n　　　　\n## 工作经历\n\n### 阿里巴巴网络技术有限公司 \n**服务端开发工程师**  2021年3月 -- 2022年7月\n在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。\n\n1. 进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。\n2. 解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。\n3. 在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。\n\n### 某量化投资有限公司\n**交易系统开发工程师**  2022年7月 -- 至今\n从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。\n\n1. 进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load/Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。\n2. 负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法/数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。\n3. 优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。\n4. 在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。\n\n## 专业技能\n\n- 熟悉C++ 20的新特性，了解模板编程\n- 了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率\n- 了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验\n- 其他语言的开发能力，包括Rust、Java、Python等\n","source":"about/index.md","raw":"---\ntitle: About Me\nlayout: about\ndate: 2023-12-01 16:44:29\n---\n\n## 教育背景\n**西安交通大学** Bachelor\n　　　　\n## 工作经历\n\n### 阿里巴巴网络技术有限公司 \n**服务端开发工程师**  2021年3月 -- 2022年7月\n在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。\n\n1. 进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。\n2. 解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。\n3. 在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。\n\n### 某量化投资有限公司\n**交易系统开发工程师**  2022年7月 -- 至今\n从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。\n\n1. 进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load/Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。\n2. 负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法/数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。\n3. 优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。\n4. 在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。\n\n## 专业技能\n\n- 熟悉C++ 20的新特性，了解模板编程\n- 了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率\n- 了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验\n- 其他语言的开发能力，包括Rust、Java、Python等\n","updated":"2023-12-01T20:00:05.533Z","path":"about/index.html","_id":"clpmegrwo0000fkx504uy240p","comments":1,"content":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p><strong>西安交通大学</strong> Bachelor\n　　　　</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"阿里巴巴网络技术有限公司\"><a href=\"#阿里巴巴网络技术有限公司\" class=\"headerlink\" title=\"阿里巴巴网络技术有限公司\"></a>阿里巴巴网络技术有限公司</h3><p><strong>服务端开发工程师</strong>  2021年3月 – 2022年7月<br>在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。</p>\n<ol>\n<li>进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。</li>\n<li>解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。</li>\n<li>在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。</li>\n</ol>\n<h3 id=\"某量化投资有限公司\"><a href=\"#某量化投资有限公司\" class=\"headerlink\" title=\"某量化投资有限公司\"></a>某量化投资有限公司</h3><p><strong>交易系统开发工程师</strong>  2022年7月 – 至今<br>从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。</p>\n<ol>\n<li>进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load&#x2F;Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。</li>\n<li>负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法&#x2F;数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。</li>\n<li>优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。</li>\n<li>在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。</li>\n</ol>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>熟悉C++ 20的新特性，了解模板编程</li>\n<li>了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率</li>\n<li>了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验</li>\n<li>其他语言的开发能力，包括Rust、Java、Python等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p><strong>西安交通大学</strong> Bachelor\n　　　　</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"阿里巴巴网络技术有限公司\"><a href=\"#阿里巴巴网络技术有限公司\" class=\"headerlink\" title=\"阿里巴巴网络技术有限公司\"></a>阿里巴巴网络技术有限公司</h3><p><strong>服务端开发工程师</strong>  2021年3月 – 2022年7月<br>在工作期间，主要负责供应链业务下商品基础模型开发，以及分布式系统一致性保障的工作。</p>\n<ol>\n<li>进行toB的商品基础模型的开发，参与基础商品与货品转换模型的重构。通过改良责任链的设计模式，在重构中降低同tracing调用链的复杂度，优化了10%的程序体积，提升了超过30%的接口响应速度。</li>\n<li>解决TB级别的数据在分布式系统中一致性问题，屏蔽了数据在分布式环境下的回流异常造成的不一致对业务的影响，优化系统可用性从99.95%优化到99.97%。</li>\n<li>在降本增效的背景下，清洗对外的同质化服务，清理下线冗余的历史rpc接口超过15%，在保证团队的服务稳定性的情况下降低所负责系统的机器成本超过20%。</li>\n</ol>\n<h3 id=\"某量化投资有限公司\"><a href=\"#某量化投资有限公司\" class=\"headerlink\" title=\"某量化投资有限公司\"></a>某量化投资有限公司</h3><p><strong>交易系统开发工程师</strong>  2022年7月 – 至今<br>从0到1参与高频交易系统的开发，负责交易链路中的通信中间件开发和系统整体的微秒级性能优化。</p>\n<ol>\n<li>进行交易系统内的IPC中间件的开发，优化了原先依赖Domain Socket的通信方式，借助Memory Fence并且合理利用CPU的Load&#x2F;Store Buffer，实现了完全基于共享内存的无锁编程来实现通信。</li>\n<li>负责交易链路中关键路径的性能优化，通过对交易主链路上的业务进行算法&#x2F;数据分离以实现模板化改造、CPU缓存友好优化，将业务逻辑内整体穿越时间从150微秒降低至20微秒内。</li>\n<li>优化了DPDK对交易行情的收取，通过实现用户态网络的零系统调用来保障网络稳定。</li>\n<li>在单机的下单算法的基础上，对多托管机的下单算法进行优化，降低了多账户多策略之间的整体交易风险和摩擦成本。</li>\n</ol>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>熟悉C++ 20的新特性，了解模板编程</li>\n<li>了解无锁编程和缓存友好编程，可以在编程中合理地设计程序以提升缓存的命中率</li>\n<li>了解程序性能优化方式，在整个系统的宏观层面优化和微观测时上都有一定的经验</li>\n<li>其他语言的开发能力，包括Rust、Java、Python等</li>\n</ul>\n"}],"Post":[{"title":"迁移计划","date":"2023-12-01T18:45:20.000Z","_content":"\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n#### C++语法方面的一些个人笔记\n\n- C++的一些基础知识回顾\n- C++ 20以上的新特性\n#### 计算机体系结构下的读书笔记\n\n- 共享内存整理\n- 异步事件框架\n- 分布式一致性协议\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n#### 探索过的编程模式\n\n- 无锁编程\n- 并发编程\n- 模版编程\n- 无分支编程\n- 缓存友好编程\n#### 工作中遇到过的因为技术层导致的问题\n\n- grafana产生的大量close_wait拖垮数据库\n- 为了效率降低分布式系统的一致性等级造成的异常\n#### 工作中部分项目的总结\n\n- 项目的稳定性治理\n- 重构项目的技巧与总结\n- 基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n#### 一些常用工具的学习和了解\n\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","source":"_posts/some-plans.md","raw":"---\ntitle: 迁移计划\ndate: 2023-12-02 02:45:20\ntags: Plan\n---\n\n由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：\n#### C++语法方面的一些个人笔记\n\n- C++的一些基础知识回顾\n- C++ 20以上的新特性\n#### 计算机体系结构下的读书笔记\n\n- 共享内存整理\n- 异步事件框架\n- 分布式一致性协议\n- rpc框架的实现\n- csapp读书笔记\n- 6.824的lab\n#### 探索过的编程模式\n\n- 无锁编程\n- 并发编程\n- 模版编程\n- 无分支编程\n- 缓存友好编程\n#### 工作中遇到过的因为技术层导致的问题\n\n- grafana产生的大量close_wait拖垮数据库\n- 为了效率降低分布式系统的一致性等级造成的异常\n#### 工作中部分项目的总结\n\n- 项目的稳定性治理\n- 重构项目的技巧与总结\n- 基于责任链的设计结构的改造\n- 交易系统的性能优化实践\n#### 一些常用工具的学习和了解\n\n- git多路merge算法的实现原理\n- docker的实现原理与使用方法\n","slug":"some-plans","published":1,"updated":"2023-12-01T19:35:23.498Z","_id":"clpn0tde6000004x529vjdu07","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>C++的一些基础知识回顾</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li>分布式一致性协议</li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>无锁编程</li>\n<li>并发编程</li>\n<li>模版编程</li>\n<li>无分支编程</li>\n<li>缓存友好编程</li>\n</ul>\n<h4 id=\"工作中遇到过的因为技术层导致的问题\"><a href=\"#工作中遇到过的因为技术层导致的问题\" class=\"headerlink\" title=\"工作中遇到过的因为技术层导致的问题\"></a>工作中遇到过的因为技术层导致的问题</h4><ul>\n<li>grafana产生的大量close_wait拖垮数据库</li>\n<li>为了效率降低分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li>项目的稳定性治理</li>\n<li>重构项目的技巧与总结</li>\n<li>基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>由于原本在云服务器上的个人博客的停用，接下来一段时间，计划把过往一段时间时间所产出的文章进行整理和迁移。我计划的迁移内容大致分为以下几个模块：</p>\n<h4 id=\"C-语法方面的一些个人笔记\"><a href=\"#C-语法方面的一些个人笔记\" class=\"headerlink\" title=\"C++语法方面的一些个人笔记\"></a>C++语法方面的一些个人笔记</h4><ul>\n<li>C++的一些基础知识回顾</li>\n<li>C++ 20以上的新特性</li>\n</ul>\n<h4 id=\"计算机体系结构下的读书笔记\"><a href=\"#计算机体系结构下的读书笔记\" class=\"headerlink\" title=\"计算机体系结构下的读书笔记\"></a>计算机体系结构下的读书笔记</h4><ul>\n<li>共享内存整理</li>\n<li>异步事件框架</li>\n<li>分布式一致性协议</li>\n<li>rpc框架的实现</li>\n<li>csapp读书笔记</li>\n<li>6.824的lab</li>\n</ul>\n<h4 id=\"探索过的编程模式\"><a href=\"#探索过的编程模式\" class=\"headerlink\" title=\"探索过的编程模式\"></a>探索过的编程模式</h4><ul>\n<li>无锁编程</li>\n<li>并发编程</li>\n<li>模版编程</li>\n<li>无分支编程</li>\n<li>缓存友好编程</li>\n</ul>\n<h4 id=\"工作中遇到过的因为技术层导致的问题\"><a href=\"#工作中遇到过的因为技术层导致的问题\" class=\"headerlink\" title=\"工作中遇到过的因为技术层导致的问题\"></a>工作中遇到过的因为技术层导致的问题</h4><ul>\n<li>grafana产生的大量close_wait拖垮数据库</li>\n<li>为了效率降低分布式系统的一致性等级造成的异常</li>\n</ul>\n<h4 id=\"工作中部分项目的总结\"><a href=\"#工作中部分项目的总结\" class=\"headerlink\" title=\"工作中部分项目的总结\"></a>工作中部分项目的总结</h4><ul>\n<li>项目的稳定性治理</li>\n<li>重构项目的技巧与总结</li>\n<li>基于责任链的设计结构的改造</li>\n<li>交易系统的性能优化实践</li>\n</ul>\n<h4 id=\"一些常用工具的学习和了解\"><a href=\"#一些常用工具的学习和了解\" class=\"headerlink\" title=\"一些常用工具的学习和了解\"></a>一些常用工具的学习和了解</h4><ul>\n<li>git多路merge算法的实现原理</li>\n<li>docker的实现原理与使用方法</li>\n</ul>\n"},{"title":"Cpp-basics-1","date":"2023-12-03T14:13:11.000Z","abstract":"Cpp语言的常用关键字","_content":"## volatile特性\n### 易变性\n在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。\n### 不可优化性\nvolatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。\n### 顺序性\n能够保证volatile变量间的顺序性，编译器不会进行乱序优化。\n### 拓展\nvolatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。\nvolatile变量间的操作，是不会被编译器交换顺序的。\n哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。\n## static特性\n静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。\n### 修饰局部变量\n一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。\n但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。\n### 修饰全局变量\n对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。\n### 修饰函数\n用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。\n### 修饰类变量\n如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。\n### 修饰类函数\n如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。\n## const特性\n### 修饰基本数据类型\n修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。\n### 修饰指针或引用\n修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。\n### 修饰函数参数\n调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。\n### 修饰函数返回值\n声明了返回值后，const按照\"修饰原则\"进行修饰，起到相应的保护作用。\n### 修饰类\n不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。\n## extern作用\n### 引用外部依赖\n#### 作用\n修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。\n#### 优势\n其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。\n### 指定调用规范\n在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。\n## final作用\n当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。\n## inline作用\ninline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。\n## explicit作用\n声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。\n## this指针作用\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## Static与Const区别\nconst强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用\n## define与Const区别\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## define与typedef区别\n#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。\n## define与inline区别\n\n1. 内联函数在编译时展开，而宏在预编译时展开。\n2. 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 \n3. 内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 \n4. 宏不是函数，而inline是函数。 \n5. 宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 \n6. inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。\n## 几个不同的函数的拷贝实现\n### strcat: char *strcat(char *dst, char const *src)\n\n- 头文件: #include <string.h>\n- 作用: 将dst和src字符串拼接起来保存在dst上\n- 注意事项:\n   - dst必须有足够的空间保存整个字符串\n   - dst和src都必须是一个由'\\0'结尾的字符串(空字符串也行)\n   - dst和src内存不能发生重叠\n- 函数实现:\n   - 首先找到dst的end\n   - 以src的'\\0'作为结束标志, 将src添加到dst的end上\n```\nchar *strcat (char * dst, const char * src){\n  assert(NULL != dst && NULL != src);   // 源码里没有断言检测\n  char * cp = dst;\n  while(*cp )\n       cp++;                      /* find end of dst */\n  while(*cp++ = *src++) ;         /* Copy src to end of dst */\n  return( dst );                  /* return dst */\n  }\n```\n### strcpy: char *strcpy(char *dst, const char *src)\n\n- 头文件:#include <string.h>\n- 作用: 将src的字符串复制到dst字符串内\n- 注意事项:\n   - src必须有结束符'\\0', 结束符也会被复制\n   - src和dst不能有内存重叠\n   - dst必须有足够的内存\n- 函数实现:\n```\nchar *strcpy(char *dst, const char *src){   // 实现src到dst的复制\n  if(dst == src) return dst;              //源码中没有此项\n  　  assert((dst != NULL) && (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性\n  　　char *cp = dst;                         //保存目标字符串的首地址\n  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下\n  　　return dst;\n  }\n```\n### strncpy: char *strncpy(char *dst, char const *src, size_t len)\n\n- 头文件: #include <string.h>\n- 作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾\n- 注意事项:\n   - strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。\n   - 如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。\n   - 如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。\n- 函数实现:\n```\nchar *strncpy(char *dst, const char *src, size_t len)\n  {\n  assert(dst != NULL && src != NULL);     //源码没有此项\n  char *cp = dst;\n  while (len-- > 0 && *src != '\\0')\n      *cp++ = *src++;\n  *cp = '\\0';                             //源码没有此项\n  return dst;\n  }\n```\n### memset: void *memset(void *a, int ch, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。\n   - 在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。\n   - 一定要保证a有这么多字节\n- 函数实现:\n```\nvoid *memset(void *a, int ch, size_t length){\n  assert(a != NULL);     \n  void *s = a;     \n  while (length--)     \n  {     \n      *(char *)s = (char) ch;     \n      s = (char *)s + 1;     \n  }     \n  return a;     \n  }\n```\n### memcpy：void *memcpy(void *dst, const void *src, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。\n   - 可以用这种方法复制任何类型的值，\n   - 如果src和dst以任何形式出现了重叠，它的结果将是未定义的。\n- 函数实现:\n```\nvoid *memcpy(void *dst, const void *src, size_t length)\n  {\n  assert((dst != NULL) && (src != NULL));\n  　　char *tempSrc= (char *)src;            //保存src首地址\n  　　char *tempDst = (char *)dst;           //保存dst首地址\n  　　while(length-- > 0)                    //循环length次，复制src的值到dst中\n     　　*tempDst++ = *tempSrc++ ;\n  　　return dst;\n  }\n```\n### strcpy 和 memcpy 的主要区别\n\n- 复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。\n- 复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符'\\0'才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到'\\0'并不结束。\n- 用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy\n## auto&decltype作用\n使用他们可以在编译期就推导出变量或者表达式的类型。\n## 强制类型转换\n### static_cast\n用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。\n特性:\n\n1. 它没有运行时类型检查，所以是有安全隐患的。\n2. 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。\n3. static_cast不能转换const，volatile等属性\n### dynamic_cast\n用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。\n### const_cast\n用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。\n### reinterpret_cast\n除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。\n","source":"_posts/Cpp-basics-1.md","raw":"---\ntitle: Cpp-basics-1\ndate: 2023-12-03 22:13:11\ntags: Cpp\nabstract: Cpp语言的常用关键字\n---\n## volatile特性\n### 易变性\n在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。\n### 不可优化性\nvolatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。\n### 顺序性\n能够保证volatile变量间的顺序性，编译器不会进行乱序优化。\n### 拓展\nvolatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。\nvolatile变量间的操作，是不会被编译器交换顺序的。\n哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。\n## static特性\n静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。\n### 修饰局部变量\n一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。\n但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。\n### 修饰全局变量\n对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。\n### 修饰函数\n用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。\n### 修饰类变量\n如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。\n### 修饰类函数\n如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。\n## const特性\n### 修饰基本数据类型\n修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。\n### 修饰指针或引用\n修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。\n### 修饰函数参数\n调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。\n### 修饰函数返回值\n声明了返回值后，const按照\"修饰原则\"进行修饰，起到相应的保护作用。\n### 修饰类\n不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。\n## extern作用\n### 引用外部依赖\n#### 作用\n修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。\n#### 优势\n其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。\n### 指定调用规范\n在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。\n## final作用\n当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。\n## inline作用\ninline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。\n## explicit作用\n声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。\n## this指针作用\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## Static与Const区别\nconst强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用\n## define与Const区别\ndefine定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。\n## define与typedef区别\n#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。\n## define与inline区别\n\n1. 内联函数在编译时展开，而宏在预编译时展开。\n2. 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 \n3. 内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 \n4. 宏不是函数，而inline是函数。 \n5. 宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 \n6. inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。\n## 几个不同的函数的拷贝实现\n### strcat: char *strcat(char *dst, char const *src)\n\n- 头文件: #include <string.h>\n- 作用: 将dst和src字符串拼接起来保存在dst上\n- 注意事项:\n   - dst必须有足够的空间保存整个字符串\n   - dst和src都必须是一个由'\\0'结尾的字符串(空字符串也行)\n   - dst和src内存不能发生重叠\n- 函数实现:\n   - 首先找到dst的end\n   - 以src的'\\0'作为结束标志, 将src添加到dst的end上\n```\nchar *strcat (char * dst, const char * src){\n  assert(NULL != dst && NULL != src);   // 源码里没有断言检测\n  char * cp = dst;\n  while(*cp )\n       cp++;                      /* find end of dst */\n  while(*cp++ = *src++) ;         /* Copy src to end of dst */\n  return( dst );                  /* return dst */\n  }\n```\n### strcpy: char *strcpy(char *dst, const char *src)\n\n- 头文件:#include <string.h>\n- 作用: 将src的字符串复制到dst字符串内\n- 注意事项:\n   - src必须有结束符'\\0', 结束符也会被复制\n   - src和dst不能有内存重叠\n   - dst必须有足够的内存\n- 函数实现:\n```\nchar *strcpy(char *dst, const char *src){   // 实现src到dst的复制\n  if(dst == src) return dst;              //源码中没有此项\n  　  assert((dst != NULL) && (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性\n  　　char *cp = dst;                         //保存目标字符串的首地址\n  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下\n  　　return dst;\n  }\n```\n### strncpy: char *strncpy(char *dst, char const *src, size_t len)\n\n- 头文件: #include <string.h>\n- 作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾\n- 注意事项:\n   - strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。\n   - 如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。\n   - 如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。\n- 函数实现:\n```\nchar *strncpy(char *dst, const char *src, size_t len)\n  {\n  assert(dst != NULL && src != NULL);     //源码没有此项\n  char *cp = dst;\n  while (len-- > 0 && *src != '\\0')\n      *cp++ = *src++;\n  *cp = '\\0';                             //源码没有此项\n  return dst;\n  }\n```\n### memset: void *memset(void *a, int ch, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。\n   - 在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。\n   - 一定要保证a有这么多字节\n- 函数实现:\n```\nvoid *memset(void *a, int ch, size_t length){\n  assert(a != NULL);     \n  void *s = a;     \n  while (length--)     \n  {     \n      *(char *)s = (char) ch;     \n      s = (char *)s + 1;     \n  }     \n  return a;     \n  }\n```\n### memcpy：void *memcpy(void *dst, const void *src, size_t length)\n\n- 头文件: #include <string.h>\n- 作用:\n   - 从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。\n   - 可以用这种方法复制任何类型的值，\n   - 如果src和dst以任何形式出现了重叠，它的结果将是未定义的。\n- 函数实现:\n```\nvoid *memcpy(void *dst, const void *src, size_t length)\n  {\n  assert((dst != NULL) && (src != NULL));\n  　　char *tempSrc= (char *)src;            //保存src首地址\n  　　char *tempDst = (char *)dst;           //保存dst首地址\n  　　while(length-- > 0)                    //循环length次，复制src的值到dst中\n     　　*tempDst++ = *tempSrc++ ;\n  　　return dst;\n  }\n```\n### strcpy 和 memcpy 的主要区别\n\n- 复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。\n- 复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符'\\0'才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到'\\0'并不结束。\n- 用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy\n## auto&decltype作用\n使用他们可以在编译期就推导出变量或者表达式的类型。\n## 强制类型转换\n### static_cast\n用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。\n特性:\n\n1. 它没有运行时类型检查，所以是有安全隐患的。\n2. 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。\n3. static_cast不能转换const，volatile等属性\n### dynamic_cast\n用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。\n### const_cast\n用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。\n### reinterpret_cast\n除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。\n","slug":"Cpp-basics-1","published":1,"updated":"2023-12-03T14:35:17.874Z","_id":"clppkl91m00000ix53f2wctgr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"volatile特性\"><a href=\"#volatile特性\" class=\"headerlink\" title=\"volatile特性\"></a>volatile特性</h2><h3 id=\"易变性\"><a href=\"#易变性\" class=\"headerlink\" title=\"易变性\"></a>易变性</h3><p>在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</p>\n<h3 id=\"不可优化性\"><a href=\"#不可优化性\" class=\"headerlink\" title=\"不可优化性\"></a>不可优化性</h3><p>volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</p>\n<h3 id=\"顺序性\"><a href=\"#顺序性\" class=\"headerlink\" title=\"顺序性\"></a>顺序性</h3><p>能够保证volatile变量间的顺序性，编译器不会进行乱序优化。</p>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><p>volatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。<br>volatile变量间的操作，是不会被编译器交换顺序的。<br>哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。</p>\n<h2 id=\"static特性\"><a href=\"#static特性\" class=\"headerlink\" title=\"static特性\"></a>static特性</h2><p>静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。</p>\n<h3 id=\"修饰局部变量\"><a href=\"#修饰局部变量\" class=\"headerlink\" title=\"修饰局部变量\"></a>修饰局部变量</h3><p>一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。<br>但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。</p>\n<h3 id=\"修饰全局变量\"><a href=\"#修饰全局变量\" class=\"headerlink\" title=\"修饰全局变量\"></a>修饰全局变量</h3><p>对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p>\n<h3 id=\"修饰函数\"><a href=\"#修饰函数\" class=\"headerlink\" title=\"修饰函数\"></a>修饰函数</h3><p>用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。</p>\n<h3 id=\"修饰类变量\"><a href=\"#修饰类变量\" class=\"headerlink\" title=\"修饰类变量\"></a>修饰类变量</h3><p>如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。</p>\n<h3 id=\"修饰类函数\"><a href=\"#修饰类函数\" class=\"headerlink\" title=\"修饰类函数\"></a>修饰类函数</h3><p>如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。</p>\n<h2 id=\"const特性\"><a href=\"#const特性\" class=\"headerlink\" title=\"const特性\"></a>const特性</h2><h3 id=\"修饰基本数据类型\"><a href=\"#修饰基本数据类型\" class=\"headerlink\" title=\"修饰基本数据类型\"></a>修饰基本数据类型</h3><p>修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。</p>\n<h3 id=\"修饰指针或引用\"><a href=\"#修饰指针或引用\" class=\"headerlink\" title=\"修饰指针或引用\"></a>修饰指针或引用</h3><p>修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p>\n<h3 id=\"修饰函数参数\"><a href=\"#修饰函数参数\" class=\"headerlink\" title=\"修饰函数参数\"></a>修饰函数参数</h3><p>调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。</p>\n<h3 id=\"修饰函数返回值\"><a href=\"#修饰函数返回值\" class=\"headerlink\" title=\"修饰函数返回值\"></a>修饰函数返回值</h3><p>声明了返回值后，const按照”修饰原则”进行修饰，起到相应的保护作用。</p>\n<h3 id=\"修饰类\"><a href=\"#修饰类\" class=\"headerlink\" title=\"修饰类\"></a>修饰类</h3><p>不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。</p>\n<h2 id=\"extern作用\"><a href=\"#extern作用\" class=\"headerlink\" title=\"extern作用\"></a>extern作用</h2><h3 id=\"引用外部依赖\"><a href=\"#引用外部依赖\" class=\"headerlink\" title=\"引用外部依赖\"></a>引用外部依赖</h3><h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p>其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。</p>\n<h3 id=\"指定调用规范\"><a href=\"#指定调用规范\" class=\"headerlink\" title=\"指定调用规范\"></a>指定调用规范</h3><p>在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</p>\n<h2 id=\"final作用\"><a href=\"#final作用\" class=\"headerlink\" title=\"final作用\"></a>final作用</h2><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p>\n<h2 id=\"inline作用\"><a href=\"#inline作用\" class=\"headerlink\" title=\"inline作用\"></a>inline作用</h2><p>inline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>\n<h2 id=\"explicit作用\"><a href=\"#explicit作用\" class=\"headerlink\" title=\"explicit作用\"></a>explicit作用</h2><p>声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。</p>\n<h2 id=\"this指针作用\"><a href=\"#this指针作用\" class=\"headerlink\" title=\"this指针作用\"></a>this指针作用</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"Static与Const区别\"><a href=\"#Static与Const区别\" class=\"headerlink\" title=\"Static与Const区别\"></a>Static与Const区别</h2><p>const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用</p>\n<h2 id=\"define与Const区别\"><a href=\"#define与Const区别\" class=\"headerlink\" title=\"define与Const区别\"></a>define与Const区别</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"define与typedef区别\"><a href=\"#define与typedef区别\" class=\"headerlink\" title=\"define与typedef区别\"></a>define与typedef区别</h2><p>#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。</p>\n<h2 id=\"define与inline区别\"><a href=\"#define与inline区别\" class=\"headerlink\" title=\"define与inline区别\"></a>define与inline区别</h2><ol>\n<li>内联函数在编译时展开，而宏在预编译时展开。</li>\n<li>在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 </li>\n<li>内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 </li>\n<li>宏不是函数，而inline是函数。 </li>\n<li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 </li>\n<li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</li>\n</ol>\n<h2 id=\"几个不同的函数的拷贝实现\"><a href=\"#几个不同的函数的拷贝实现\" class=\"headerlink\" title=\"几个不同的函数的拷贝实现\"></a>几个不同的函数的拷贝实现</h2><h3 id=\"strcat-char-strcat-char-dst-char-const-src\"><a href=\"#strcat-char-strcat-char-dst-char-const-src\" class=\"headerlink\" title=\"strcat: char *strcat(char *dst, char const *src)\"></a>strcat: char *strcat(char *dst, char const *src)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 将dst和src字符串拼接起来保存在dst上</li>\n<li>注意事项:<ul>\n<li>dst必须有足够的空间保存整个字符串</li>\n<li>dst和src都必须是一个由’\\0’结尾的字符串(空字符串也行)</li>\n<li>dst和src内存不能发生重叠</li>\n</ul>\n</li>\n<li>函数实现:<ul>\n<li>首先找到dst的end</li>\n<li>以src的’\\0’作为结束标志, 将src添加到dst的end上<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcat (char * dst, const char * src)&#123;</span><br><span class=\"line\">  assert(NULL != dst &amp;&amp; NULL != src);   // 源码里没有断言检测</span><br><span class=\"line\">  char * cp = dst;</span><br><span class=\"line\">  while(*cp )</span><br><span class=\"line\">       cp++;                      /* find end of dst */</span><br><span class=\"line\">  while(*cp++ = *src++) ;         /* Copy src to end of dst */</span><br><span class=\"line\">  return( dst );                  /* return dst */</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"strcpy-char-strcpy-char-dst-const-char-src\"><a href=\"#strcpy-char-strcpy-char-dst-const-char-src\" class=\"headerlink\" title=\"strcpy: char *strcpy(char *dst, const char *src)\"></a>strcpy: char *strcpy(char *dst, const char *src)</h3><ul>\n<li>头文件:#include &lt;string.h&gt;</li>\n<li>作用: 将src的字符串复制到dst字符串内</li>\n<li>注意事项:<ul>\n<li>src必须有结束符’\\0’, 结束符也会被复制</li>\n<li>src和dst不能有内存重叠</li>\n<li>dst必须有足够的内存</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcpy(char *dst, const char *src)&#123;   // 实现src到dst的复制</span><br><span class=\"line\">  if(dst == src) return dst;              //源码中没有此项</span><br><span class=\"line\">  　  assert((dst != NULL) &amp;&amp; (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性</span><br><span class=\"line\">  　　char *cp = dst;                         //保存目标字符串的首地址</span><br><span class=\"line\">  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strncpy-char-strncpy-char-dst-char-const-src-size-t-len\"><a href=\"#strncpy-char-strncpy-char-dst-char-const-src-size-t-len\" class=\"headerlink\" title=\"strncpy: char *strncpy(char *dst, char const *src, size_t len)\"></a>strncpy: char *strncpy(char *dst, char const *src, size_t len)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾</li>\n<li>注意事项:<ul>\n<li>strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。</li>\n<li>如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。</li>\n<li>如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strncpy(char *dst, const char *src, size_t len)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert(dst != NULL &amp;&amp; src != NULL);     //源码没有此项</span><br><span class=\"line\">  char *cp = dst;</span><br><span class=\"line\">  while (len-- &gt; 0 &amp;&amp; *src != &#x27;\\0&#x27;)</span><br><span class=\"line\">      *cp++ = *src++;</span><br><span class=\"line\">  *cp = &#x27;\\0&#x27;;                             //源码没有此项</span><br><span class=\"line\">  return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memset-void-memset-void-a-int-ch-size-t-length\"><a href=\"#memset-void-memset-void-a-int-ch-size-t-length\" class=\"headerlink\" title=\"memset: void *memset(void *a, int ch, size_t length)\"></a>memset: void *memset(void *a, int ch, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。</li>\n<li>在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。</li>\n<li>一定要保证a有这么多字节</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memset(void *a, int ch, size_t length)&#123;</span><br><span class=\"line\">  assert(a != NULL);     </span><br><span class=\"line\">  void *s = a;     </span><br><span class=\"line\">  while (length--)     </span><br><span class=\"line\">  &#123;     </span><br><span class=\"line\">      *(char *)s = (char) ch;     </span><br><span class=\"line\">      s = (char *)s + 1;     </span><br><span class=\"line\">  &#125;     </span><br><span class=\"line\">  return a;     </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memcpy：void-memcpy-void-dst-const-void-src-size-t-length\"><a href=\"#memcpy：void-memcpy-void-dst-const-void-src-size-t-length\" class=\"headerlink\" title=\"memcpy：void *memcpy(void *dst, const void *src, size_t length)\"></a>memcpy：void *memcpy(void *dst, const void *src, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。</li>\n<li>可以用这种方法复制任何类型的值，</li>\n<li>如果src和dst以任何形式出现了重叠，它的结果将是未定义的。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memcpy(void *dst, const void *src, size_t length)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert((dst != NULL) &amp;&amp; (src != NULL));</span><br><span class=\"line\">  　　char *tempSrc= (char *)src;            //保存src首地址</span><br><span class=\"line\">  　　char *tempDst = (char *)dst;           //保存dst首地址</span><br><span class=\"line\">  　　while(length-- &gt; 0)                    //循环length次，复制src的值到dst中</span><br><span class=\"line\">     　　*tempDst++ = *tempSrc++ ;</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strcpy-和-memcpy-的主要区别\"><a href=\"#strcpy-和-memcpy-的主要区别\" class=\"headerlink\" title=\"strcpy 和 memcpy 的主要区别\"></a>strcpy 和 memcpy 的主要区别</h3><ul>\n<li>复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。</li>\n<li>复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符’\\0’才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到’\\0’并不结束。</li>\n<li>用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy</li>\n</ul>\n<h2 id=\"auto-decltype作用\"><a href=\"#auto-decltype作用\" class=\"headerlink\" title=\"auto&amp;decltype作用\"></a>auto&amp;decltype作用</h2><p>使用他们可以在编译期就推导出变量或者表达式的类型。</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<br>特性:</p>\n<ol>\n<li>它没有运行时类型检查，所以是有安全隐患的。</li>\n<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>\n<li>static_cast不能转换const，volatile等属性</li>\n</ol>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。</p>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"volatile特性\"><a href=\"#volatile特性\" class=\"headerlink\" title=\"volatile特性\"></a>volatile特性</h2><h3 id=\"易变性\"><a href=\"#易变性\" class=\"headerlink\" title=\"易变性\"></a>易变性</h3><p>在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</p>\n<h3 id=\"不可优化性\"><a href=\"#不可优化性\" class=\"headerlink\" title=\"不可优化性\"></a>不可优化性</h3><p>volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</p>\n<h3 id=\"顺序性\"><a href=\"#顺序性\" class=\"headerlink\" title=\"顺序性\"></a>顺序性</h3><p>能够保证volatile变量间的顺序性，编译器不会进行乱序优化。</p>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><p>volatile变量，与非volatile变量之间的操作，是可能被编译器交换顺序的。<br>volatile变量间的操作，是不会被编译器交换顺序的。<br>哪怕将所有的变量全部都声明为volatile，杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。针对这个多线程的应用，正确的做法，是构建一个happens-before语义。</p>\n<h2 id=\"static特性\"><a href=\"#static特性\" class=\"headerlink\" title=\"static特性\"></a>static特性</h2><p>静态变量的初始化在程序启动时进行（对于全局静态变量），或在其所在函数首次被调用时进行（对于局部静态变量）。</p>\n<h3 id=\"修饰局部变量\"><a href=\"#修饰局部变量\" class=\"headerlink\" title=\"修饰局部变量\"></a>修饰局部变量</h3><p>一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。<br>但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。</p>\n<h3 id=\"修饰全局变量\"><a href=\"#修饰全局变量\" class=\"headerlink\" title=\"修饰全局变量\"></a>修饰全局变量</h3><p>对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p>\n<h3 id=\"修饰函数\"><a href=\"#修饰函数\" class=\"headerlink\" title=\"修饰函数\"></a>修饰函数</h3><p>用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。</p>\n<h3 id=\"修饰类变量\"><a href=\"#修饰类变量\" class=\"headerlink\" title=\"修饰类变量\"></a>修饰类变量</h3><p>如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有,它们在存储空间中都只存在一个副本,可以通过类和对象去调用。</p>\n<h3 id=\"修饰类函数\"><a href=\"#修饰类函数\" class=\"headerlink\" title=\"修饰类函数\"></a>修饰类函数</h3><p>如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象。因此，对静态成员的使用不需要用对象名。</p>\n<h2 id=\"const特性\"><a href=\"#const特性\" class=\"headerlink\" title=\"const特性\"></a>const特性</h2><h3 id=\"修饰基本数据类型\"><a href=\"#修饰基本数据类型\" class=\"headerlink\" title=\"修饰基本数据类型\"></a>修饰基本数据类型</h3><p>修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。</p>\n<h3 id=\"修饰指针或引用\"><a href=\"#修饰指针或引用\" class=\"headerlink\" title=\"修饰指针或引用\"></a>修饰指针或引用</h3><p>修饰原则：如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p>\n<h3 id=\"修饰函数参数\"><a href=\"#修饰函数参数\" class=\"headerlink\" title=\"修饰函数参数\"></a>修饰函数参数</h3><p>调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。</p>\n<h3 id=\"修饰函数返回值\"><a href=\"#修饰函数返回值\" class=\"headerlink\" title=\"修饰函数返回值\"></a>修饰函数返回值</h3><p>声明了返回值后，const按照”修饰原则”进行修饰，起到相应的保护作用。</p>\n<h3 id=\"修饰类\"><a href=\"#修饰类\" class=\"headerlink\" title=\"修饰类\"></a>修饰类</h3><p>不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。</p>\n<h2 id=\"extern作用\"><a href=\"#extern作用\" class=\"headerlink\" title=\"extern作用\"></a>extern作用</h2><h3 id=\"引用外部依赖\"><a href=\"#引用外部依赖\" class=\"headerlink\" title=\"引用外部依赖\"></a>引用外部依赖</h3><h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用,注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p>其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，但使用extern会加速程序的编译过程，这样能节省时间。</p>\n<h3 id=\"指定调用规范\"><a href=\"#指定调用规范\" class=\"headerlink\" title=\"指定调用规范\"></a>指定调用规范</h3><p>在C++中extern还有另外一种作用，用于指示调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</p>\n<h2 id=\"final作用\"><a href=\"#final作用\" class=\"headerlink\" title=\"final作用\"></a>final作用</h2><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p>\n<h2 id=\"inline作用\"><a href=\"#inline作用\" class=\"headerlink\" title=\"inline作用\"></a>inline作用</h2><p>inline 起到内联作用,因为在编译时函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数,编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>\n<h2 id=\"explicit作用\"><a href=\"#explicit作用\" class=\"headerlink\" title=\"explicit作用\"></a>explicit作用</h2><p>声明为explicit的构造函数不能在隐式转换中使用，explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显式的。</p>\n<h2 id=\"this指针作用\"><a href=\"#this指针作用\" class=\"headerlink\" title=\"this指针作用\"></a>this指针作用</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"Static与Const区别\"><a href=\"#Static与Const区别\" class=\"headerlink\" title=\"Static与Const区别\"></a>Static与Const区别</h2><p>const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用</p>\n<h2 id=\"define与Const区别\"><a href=\"#define与Const区别\" class=\"headerlink\" title=\"define与Const区别\"></a>define与Const区别</h2><p>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</p>\n<h2 id=\"define与typedef区别\"><a href=\"#define与typedef区别\" class=\"headerlink\" title=\"define与typedef区别\"></a>define与typedef区别</h2><p>#define 是预处理命令,只做简单的代码替换，typedef 是编译时处理,给已存在的类型一个别名。</p>\n<h2 id=\"define与inline区别\"><a href=\"#define与inline区别\" class=\"headerlink\" title=\"define与inline区别\"></a>define与inline区别</h2><ol>\n<li>内联函数在编译时展开，而宏在预编译时展开。</li>\n<li>在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 </li>\n<li>内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 </li>\n<li>宏不是函数，而inline是函数。 </li>\n<li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。 </li>\n<li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</li>\n</ol>\n<h2 id=\"几个不同的函数的拷贝实现\"><a href=\"#几个不同的函数的拷贝实现\" class=\"headerlink\" title=\"几个不同的函数的拷贝实现\"></a>几个不同的函数的拷贝实现</h2><h3 id=\"strcat-char-strcat-char-dst-char-const-src\"><a href=\"#strcat-char-strcat-char-dst-char-const-src\" class=\"headerlink\" title=\"strcat: char *strcat(char *dst, char const *src)\"></a>strcat: char *strcat(char *dst, char const *src)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 将dst和src字符串拼接起来保存在dst上</li>\n<li>注意事项:<ul>\n<li>dst必须有足够的空间保存整个字符串</li>\n<li>dst和src都必须是一个由’\\0’结尾的字符串(空字符串也行)</li>\n<li>dst和src内存不能发生重叠</li>\n</ul>\n</li>\n<li>函数实现:<ul>\n<li>首先找到dst的end</li>\n<li>以src的’\\0’作为结束标志, 将src添加到dst的end上<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcat (char * dst, const char * src)&#123;</span><br><span class=\"line\">  assert(NULL != dst &amp;&amp; NULL != src);   // 源码里没有断言检测</span><br><span class=\"line\">  char * cp = dst;</span><br><span class=\"line\">  while(*cp )</span><br><span class=\"line\">       cp++;                      /* find end of dst */</span><br><span class=\"line\">  while(*cp++ = *src++) ;         /* Copy src to end of dst */</span><br><span class=\"line\">  return( dst );                  /* return dst */</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"strcpy-char-strcpy-char-dst-const-char-src\"><a href=\"#strcpy-char-strcpy-char-dst-const-char-src\" class=\"headerlink\" title=\"strcpy: char *strcpy(char *dst, const char *src)\"></a>strcpy: char *strcpy(char *dst, const char *src)</h3><ul>\n<li>头文件:#include &lt;string.h&gt;</li>\n<li>作用: 将src的字符串复制到dst字符串内</li>\n<li>注意事项:<ul>\n<li>src必须有结束符’\\0’, 结束符也会被复制</li>\n<li>src和dst不能有内存重叠</li>\n<li>dst必须有足够的内存</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strcpy(char *dst, const char *src)&#123;   // 实现src到dst的复制</span><br><span class=\"line\">  if(dst == src) return dst;              //源码中没有此项</span><br><span class=\"line\">  　  assert((dst != NULL) &amp;&amp; (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性</span><br><span class=\"line\">  　　char *cp = dst;                         //保存目标字符串的首地址</span><br><span class=\"line\">  　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strncpy-char-strncpy-char-dst-char-const-src-size-t-len\"><a href=\"#strncpy-char-strncpy-char-dst-char-const-src-size-t-len\" class=\"headerlink\" title=\"strncpy: char *strncpy(char *dst, char const *src, size_t len)\"></a>strncpy: char *strncpy(char *dst, char const *src, size_t len)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用: 从src中复制len个字符到dst中, 如果不足len则用NULL填充, 如果src超过len, 则dst将不会以NULL结尾</li>\n<li>注意事项:<ul>\n<li>strncpy 把源字符串的字符复制到目标数组，它总是正好向 dst 写入 len 个字符。</li>\n<li>如果 strlen(src) 的值小于 len，dst 数组就用额外的 NULL 字节填充到 len 长度。</li>\n<li>如果 strlen(src)的值大于或等于 len，那么只有 len 个字符被复制到dst中。这里需要注意它的结果将不会以NULL字节结尾。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *strncpy(char *dst, const char *src, size_t len)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert(dst != NULL &amp;&amp; src != NULL);     //源码没有此项</span><br><span class=\"line\">  char *cp = dst;</span><br><span class=\"line\">  while (len-- &gt; 0 &amp;&amp; *src != &#x27;\\0&#x27;)</span><br><span class=\"line\">      *cp++ = *src++;</span><br><span class=\"line\">  *cp = &#x27;\\0&#x27;;                             //源码没有此项</span><br><span class=\"line\">  return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memset-void-memset-void-a-int-ch-size-t-length\"><a href=\"#memset-void-memset-void-a-int-ch-size-t-length\" class=\"headerlink\" title=\"memset: void *memset(void *a, int ch, size_t length)\"></a>memset: void *memset(void *a, int ch, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>将参数a所指的内存区域前length个字节以参数ch填入，然后返回指向a的指针。</li>\n<li>在编写程序的时候，若需要将某一数组作初始化，memset()会很方便。</li>\n<li>一定要保证a有这么多字节</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memset(void *a, int ch, size_t length)&#123;</span><br><span class=\"line\">  assert(a != NULL);     </span><br><span class=\"line\">  void *s = a;     </span><br><span class=\"line\">  while (length--)     </span><br><span class=\"line\">  &#123;     </span><br><span class=\"line\">      *(char *)s = (char) ch;     </span><br><span class=\"line\">      s = (char *)s + 1;     </span><br><span class=\"line\">  &#125;     </span><br><span class=\"line\">  return a;     </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"memcpy：void-memcpy-void-dst-const-void-src-size-t-length\"><a href=\"#memcpy：void-memcpy-void-dst-const-void-src-size-t-length\" class=\"headerlink\" title=\"memcpy：void *memcpy(void *dst, const void *src, size_t length)\"></a>memcpy：void *memcpy(void *dst, const void *src, size_t length)</h3><ul>\n<li>头文件: #include &lt;string.h&gt;</li>\n<li>作用:<ul>\n<li>从 src 所指的内存地址的起始位置开始，拷贝n个字节的数据到 dest 所指的内存地址的起始位置。</li>\n<li>可以用这种方法复制任何类型的值，</li>\n<li>如果src和dst以任何形式出现了重叠，它的结果将是未定义的。</li>\n</ul>\n</li>\n<li>函数实现:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *memcpy(void *dst, const void *src, size_t length)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  assert((dst != NULL) &amp;&amp; (src != NULL));</span><br><span class=\"line\">  　　char *tempSrc= (char *)src;            //保存src首地址</span><br><span class=\"line\">  　　char *tempDst = (char *)dst;           //保存dst首地址</span><br><span class=\"line\">  　　while(length-- &gt; 0)                    //循环length次，复制src的值到dst中</span><br><span class=\"line\">     　　*tempDst++ = *tempSrc++ ;</span><br><span class=\"line\">  　　return dst;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"strcpy-和-memcpy-的主要区别\"><a href=\"#strcpy-和-memcpy-的主要区别\" class=\"headerlink\" title=\"strcpy 和 memcpy 的主要区别\"></a>strcpy 和 memcpy 的主要区别</h3><ul>\n<li>复制的内容不同: strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。</li>\n<li>复制的方法不同: strcpy 不需要指定长度，它遇到被复制字符的串结束符’\\0’才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度，遇到’\\0’并不结束。</li>\n<li>用途不同: 通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy</li>\n</ul>\n<h2 id=\"auto-decltype作用\"><a href=\"#auto-decltype作用\" class=\"headerlink\" title=\"auto&amp;decltype作用\"></a>auto&amp;decltype作用</h2><p>使用他们可以在编译期就推导出变量或者表达式的类型。</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<br>特性:</p>\n<ol>\n<li>它没有运行时类型检查，所以是有安全隐患的。</li>\n<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>\n<li>static_cast不能转换const，volatile等属性</li>\n</ol>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。</p>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>除了非指针之间外几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等，但是不够安全。</p>\n"},{"title":"Cpp-basics-2","date":"2023-12-03T14:13:24.000Z","_content":"","source":"_posts/Cpp-basics-2.md","raw":"---\ntitle: Cpp-basics-2\ndate: 2023-12-03 22:13:24\ntags:\n---\n","slug":"Cpp-basics-2","published":1,"updated":"2023-12-03T14:13:24.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clppkl91r00010ix58yax4m3a","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Cpp-basics-3","date":"2023-12-03T14:13:30.000Z","_content":"","source":"_posts/Cpp-basics-3.md","raw":"---\ntitle: Cpp-basics-3\ndate: 2023-12-03 22:13:30\ntags:\n---\n","slug":"Cpp-basics-3","published":1,"updated":"2023-12-03T14:13:30.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clppkl91v00030ix5gsag2hlu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Cpp-basics-4","date":"2023-12-03T14:13:35.000Z","_content":"","source":"_posts/Cpp-basics-4.md","raw":"---\ntitle: Cpp-basics-4\ndate: 2023-12-03 22:13:35\ntags:\n---\n","slug":"Cpp-basics-4","published":1,"updated":"2023-12-03T14:13:35.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clppkl91x00040ix5bqqpcgw6","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clpn0tde6000004x529vjdu07","tag_id":"clpn0tdea000104x58cqx284n","_id":"clpn0tded000204x5452bawwz"},{"post_id":"clppkl91m00000ix53f2wctgr","tag_id":"clppkl91t00020ix53r29cxo3","_id":"clppkl91y00050ix5g7dwh16q"}],"Tag":[{"name":"Plan","_id":"clpn0tdea000104x58cqx284n"},{"name":"Cpp","_id":"clppkl91t00020ix53r29cxo3"}]}}