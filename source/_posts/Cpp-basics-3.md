---
title: Cpp-basics-3
date: 2023-12-03 22:13:30
tags: Cpp
abstract: Cpp中的内存模型
---
## 内存分类
![image.png](/images/Cpp-Basics-3-1.png)
### .text 代码区
存放程序的二进制代码。
### .data 数据段(静态存储区)
存放可执行文件中已初始化的静态变量和全局变量
### .bss
存放程序中未初始化的全局变量，在内存中bss段全部置零
### 堆区
亦称动态内存分配,可能会产生内存碎片。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。
### 栈区
在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
## 堆与栈的区别
### 速度区别
栈快。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
### 管理区别
对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
### 大小区别
一般来讲在32位系统下，堆内存可以达到4G的空间,但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。
### 碎片区别
对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出
## 类的内存占用
### 空类
1字节,在C++中空类会占1个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。
### 含普通函数的类
1字节,普通函数不占用类大小。
### 含虚函数的类
4字节,因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节。
### 含静态成员的类
1字节,静态成员存放在静态存储区，不占用类的大小。
## 操作内存关键字
### new的实现
首先会调用malloc为对象分配内存空间，然后进行强制类型转换,然后调用对象的构造函数。
### delete的实现
调用对象的析构函数，然后调用free回收内存。
### 为什么需要new/delete
在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。
### malloc和new的区别
malloc需要给定空间大小，而new只需要对象名；malloc类型不安全，new类型安全。
### delete和delete[]的区别

- delete只会调用一次析构函数，而delete[ ]会调用每个成员的析构函数。
- 用new分配的内存用delete释放，用new[ ]分配的内存用delete[ ]释放。
### free的实现细节
不会被立即返还给操作系统,被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。
## 内存泄漏
### 概念
动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存。
### 原因

1. 类的构造函数和析构函数中new和delete没有配套
2. 在释放对象数组时没有使用delete[]，使用了delete
3. 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露
4. 没有正确的清楚清除的对象指针
### 检测方法

1. 从监视工具收集一段时间内的堆栈内存信息，观测增长趋势，来确定是否有内存泄漏
2. 静态编译工具Beam
3. 动态检验工具valgrind
### 解决方法

1. malloc/free要配套
2. 使用智能指针
3. 将基类的析构函数设为虚函数
## 内存的结构对齐
### 原因
因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。
### 规则

1. 第一个成员在与结构体变量偏移量为0的地址 
2. 对齐数=Min（编译器默认的对齐数，该成员大小），linux 中默认为4，vs 中的默认值为8。
3. 其他成员变量要对齐到对齐数的整数倍的地址处
## 如何在共享内存中使用容器
问题的根源是容器内存储的是绝对地址，而不同的进程、或者相同的进程的不同的启动，都会使得共享内存映射到当前进程内的不同地址。
解决方案是三种：
一种是定制STL的容器内存分配器，一种是ACE提供的使用地址无关的分配方法，一种是BOOST的interprocess的实现。
参考链接：
[https://blog.csdn.net/fullsail/article/details/8540078](https://blog.csdn.net/fullsail/article/details/8540078)
## 垃圾回收
### Cpp为什么没有垃圾回收

- 实现一个垃圾回收器会带来额外的空间和时间开销,需要开辟一定的空间保存指针的引用计数和对他们进行标记mark,然后需要单独开辟一个线程在空闲的时候进行free操作。
- 垃圾回收会使得C++不适合进行很多底层的操作。
### 如果要为Cpp设计垃圾回收
C/C++ 中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。
首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。
其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量(包括函数内的静态变量)都是集中存在于 bss 段或 data段中。垃圾回收的时候，只需要扫描 bss 段, data 段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。
