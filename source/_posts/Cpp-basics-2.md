---
title: Cpp-basics-2
date: 2023-12-03 22:13:24
tags: Cpp
abstract: Cpp中的一些基础概念
---
## main函数执行前过程
1. 设置栈指针
2. 初始化静态static变量和global全局变量，即.data段的内容
3. 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
4. 全局对象初始化，在main之前调用构造函数
5. 将main函数的参数argc，argv等传递给main函数，真正运行main函数
## 普通函数调用过程

1. 设置栈指针，在栈中放入下一条指令的地址
2. 然后为形参和局部变量分配存储空间
3. 将实参的值复制给形参
4. 进行函数内操作
5. return 语句返回时，从栈中回收形参和局部变量占用的存储空间
6. 从栈中取出返回地址
7. 跳转到该地址继续执行
## 代码编译过程
预处理：对预处理命令进行替换等预处理操作
编译：代码优化和生成汇编代码
汇编：将汇编代码转化为机器语言
链接：将目标文件彼此链接起来
## 动态链接和静态链接
### 静态链接
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 
**空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本； 
**更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 
**运行速度快**：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
### 动态链接
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 
**共享库**：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；
**更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 
**性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
### 区别

1. 使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份
2. 使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂
3. **静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.**
## 指针与引用
### 概念

1. 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量
2. 引用是一个别名，对引用的操作就是对变量的本身进行操作
### 区别

1. 指针可以有多级，引用只有一级 
2. 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 
3. 指针可以为空，引用不可以
### 使用场景

1. 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的
2. 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小;类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。
### 引用和指针在汇编层
引用和指针在汇编层完全一样，引用就是指针。
但在开发使用过程中，引用是等效于常量指针的（指向固定的对象），意味着两者在汇编层完全相同。
借此可以推导一些const关键词的特性：如果在汇编层完全相同的话，这个在使用上隐晦存在的（const）其实是由编译器保证的，它通过静态检查的方式确保引用无法被修改。
## 声明与定义

1. 声明是告诉编译器变量的类型和名字，不会为变量分配空间
2. 定义是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。
## struct与class

1. 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的
2. struct的继承默认是public继承，而class的继承默认是private继承
3. class可以用作模板，而struct不能
## 拷贝
### 浅拷贝
将对象的指针进行简单的复制，原对象和副本指向的是相同的资源
### 深拷贝
新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址
### 深浅拷贝的区别
深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。
### 零拷贝
零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。用程序调用mmap()，磁盘上的数据会通过DMA被拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。
## 友元
### 概念
友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。
### 友元函数
友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中用friend关键字声明所有可以访问它的友元函数。
### 友元类
友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。
### 友元类的注意点

1. 友元关系不能被继承。 
2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 
3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明
## 列表成员初始化

- 赋值初始化，通过在函数体内进行赋值初始化；
- 列表初始化，在冒号后使用初始化列表进行初始化。

相对而言，列表成员初始化的效率会更高，列表初始化是给数据成员分配内存空间时就进行初始化, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数。
## 右值与移动构造

- 右值的概念: 将亡值, 不具名变量
- 右值引用
   - 概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.
   - 优点:
      - 转移语意
      - 精确语意传递(参数列表分别为**左值引用**和**右值引用**形成参数重载)
- 移动构造函数:
   - 概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.
   - 实现:
      - 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。
      - 也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。
      - **作为参数的右值将不会再调用析构函数。**
      - move语句，就是将一个左值变成一个将亡值。
   - 优点
      - 避免了无谓的对下销毁和构造的开销
      - 当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生
## 函数指针

- 什么是函数指针?
   - 函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.
- 函数指针的声明方法
   - int (*pf)(const int&, const int&); (1)
   - pf是一个返回类型为int, 参数为两个const int&的函数。**注意*pf 两边的括号是必须的**
      - 否则上面的定义就变成了：
      - int *pf(const int&, const int&); // 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&参数.
- 为什么有函数指针
   - 可以通过函数指针进行函数调用
   - 而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数
   - 另外还能将函数指针作为函数参数进行传递.
   - 通过函数指针可以把函数的调用者与被调函数分开。
      - 调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,
      - 而不需要知道具体是哪个函数被调用.
- 两种方法赋值：
   - 指针名 = 函数名
   - 指针名 = &函数名
## C++和其他语言的区别
### 和C的区别

1. C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性
2. C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete
3. C++中有函数重载和引用等概念，C中没有
### 和Java的区别

1. C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高
2. C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法
3. C++有指针，Java没有指针，只有引用
4. JAVA和C++都有构造函数，但是C++有析构函数但是Java没有
### 和python的区别

1. python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。
2. python可以很方便的跨平台，但是效率没有C++高
