---
title: Cpp基础知识点(五)
date: 2023-12-03 23:08:46
tags: Cpp
abstract: Cpp中的STL的基础知识
---
本文是关于一些Cpp中STL的基础知识整理。
## STL组件
### 容器
各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。
### 算法
各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)。
### 迭代器
容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。
### 仿函数
行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。
### 配接器
一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。
### 配置器
负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。
## STL中的哈希
它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，默认的桶大小是10。
### 哈希冲突解决
线性探查；二次平方探查；二次哈希法；开链法；建立公共溢出区。
## STL中的map
### map
底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(<)。
### unordered_map
使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。
## STL中的vector
### 概念
STL中的vector是封装了动态数组的顺序容器。
### 扩充规则
每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。
### 缺陷
vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。
### 与list的对比 
list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。
### vector的迭代器失效

- 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效。
- 当vector在插入的时候，end迭代器肯定会失效。
- 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。
## STL中的string
### 概念
string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。
### 扩充规则
string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。
## STL中的sort实现
STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。
## set/map/vector插入复杂度

- set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。
- unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)。
- vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝。
