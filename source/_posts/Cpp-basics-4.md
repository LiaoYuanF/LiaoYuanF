---
title: Cpp基础知识点(四)
date: 2023-12-03 22:13:35
tags: Cpp
abstract: Cpp面向对象的基础知识
---
本文是关于一些Cpp中面向对象的基础知识整理。
## 面向对象特性
### 封装
封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public。
### 继承
继承使得子类可以复用父类的成员和方法，实现了代码重用。
### 多态
多态是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。
## 基类必须定义
因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类仅有声明是不够的，必须有定义。
## 构造函数
### 默认构造函数
当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。
### 重载构造函数
称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。
### 拷贝构造函数
在发生对象复制的时候调用的。
#### 拷贝构造函数的调用

1. 对象以值传递的方式传入函数参数
```java
 void func(Dog dog){};
```

2. 对象以值传递的方式从函数返回
```java
Dog func(){ Dog d; return d;} 
```

3. 对象需要通过另外一个对象进行初始化
## 绑定方式
### 动态绑定
就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。
### 静态绑定
就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。
## 多态实现
### 编译时多态
函数重载和模板
### 运行时多态
虚函数
## 多态的实现：模板
### 函数模板的实现
编译器从函数模板通过具体类型产生不同的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。
### 类模板的优点

1. 它是类型无关的，具有可复用性
2. 它是平台无关的，具有可移植性
3. 它在编译时而不是运行时检查数据类型，保证了类型安全
## 多态的实现：函数重载
### 重载
重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。
### 重写
重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。
## 多态的实现：虚函数
### 虚函数
在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。
### 纯虚函数
是只有声明没有实现的虚函数，是对子类的约束，是接口继承;包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。
### 纯虚函数的使用场景
当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。
### 虚函数指针
如果类中有virtual关键字,则会有虚函数指针,指向虚函数表。
### 虚函数表
虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址,一个类的所有实例都共享同一张虚函数表。
### 多继承与多重继承
多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前，多重继承的情况下越是祖先的父类的虚函数更靠前。
#### 多继承

- 多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承。
- 在多继承中，任何父类的指针都可以指向子类的对象，在实例化子类时，先根据继承的顺序依次调用父类的构造函数，然后再调用该子类自己的构造函数。
- 用delete销毁该基类对象时，如果该基类的析构函数不是虚析构函数，且该基类的继承顺序在第一个，delete 父类的时候只会调用父类Worker的析构函数，系统不会出错，但是如果继承的时候顺序不是在第一位，如果父类的析构函数是虚析构函数，那么销毁的时候会先调用子类的析构函数再调用所有父类的析构函数，注意，此时，子类的父类的析构函数都会被调用。
#### 多重继承

- 多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承。
- 当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。
- 无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。
### 编译器处理虚函数
如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。
### 构造为什么不能是虚函数

1. 因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等。
2. 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。
### 析构为什么可以是虚函数
当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。
### 构造或析构中调用虚函数
这两个操作都不提倡，因为操作结果不可以预料。

- 在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。
- 在析构函数中调用虚函数，此时调用的是子类的函数实现方式，但是此时子类的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
### 构造函数和析构函数能否抛出异常

- 构造函数异常
   - 后果:
      - **(原因):**C++拒绝为**没有完成构造函数的对象**调用**析构函数**，原因是避免开销
      - 构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏
      - 例如: 在对象b 的构造函数中发生异常，对象b 的析构函数不会被调用。**因此会造成内存泄漏**。
   - 解决方案:
      - 使用**智慧指针**来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.
      - **一般建议不要在构造函数里做过多的资源分配。**
- 析构函数异常
   - 后果:
      - 在异常传递的**堆栈辗转展开**的过程中, 如果发生析构异常, C++会调用terminate终止程序
      - 如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。
   - 解决方法：
      - 如果异常不可避免，则应在析构函数内捕获，而不应当抛出。
      - 在析构函数中使用try-catch块屏蔽所有异常。
   - 附加说明:
      - **(后果1):** 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)
### 类函数是否可以同时template和virtual
C++的编译与链接模型是"分离"的，C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知，一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。但是，虚函数利用了虚函数表，虚函数表的内存布局需要在这个类编译完成的时候就被完全确定。
